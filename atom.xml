<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟蓑笠翁，独钓寒江雪</title>
  <subtitle>程序猿的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-14T14:27:47.781Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>寒江蓑笠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>区块链 -- 区块链基础100问</title>
    <link href="http://yoursite.com/2018/05/02/block-chain-basic-questions/"/>
    <id>http://yoursite.com/2018/05/02/block-chain-basic-questions/</id>
    <published>2018-05-02T02:00:00.000Z</published>
    <updated>2018-09-14T14:27:47.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比特币及区块链的发展历史"><a href="#比特币及区块链的发展历史" class="headerlink" title="比特币及区块链的发展历史"></a>比特币及区块链的发展历史</h1><h2 id="1-从物物交换到比特币"><a href="#1-从物物交换到比特币" class="headerlink" title="1.从物物交换到比特币"></a>1.从物物交换到比特币</h2><p>　　货币一开始是实物货币，如贝壳、金银等，因为他们具有稀缺性，用于充当一般等价物。<br>　　后来我们开始用纸币进行支付。面值100元的纸币制作成本可能只有几厘钱，却能够换取价值100元的物品，这是因为有国家的信用背书，让人们相信这一文不值的纸币能够换100元的商品。<br>　　随着互联网的发展，我们从纸币过度到记账货币，比如发工资只是在银行卡账户上做数字的加法，买衣服只是做减法。整个过程中都是银行在记账，且只有银行有记账权。<br>　　在2008全球经济危机中，美国政府因为有记账权所以可以无限增发货币。中本聪觉得这样很不靠谱，于是他想创建一种新型支付体系：大家都有权来记账，货币不能超发，整个账本完全公开透明，十分公平。这就是比特币产生的原因和动机。</p>
<h2 id="2-什么是比特币"><a href="#2-什么是比特币" class="headerlink" title="2.什么是比特币"></a>2.什么是比特币</h2><p>　　比特币（Bitcoin，简写BTC）概念由中本聪（化名）提出，是一种点对点、去中心化的数字资产；2009年，中本聪打包了第一个区块，并获得50枚比特币的挖矿奖励，挖矿奖励每4年减半一次，按此计算，比特币预计2140年发行完毕，总量为2100万枚。<br>　　随着比特币的发展，比特币逐渐受到认可：德国为全球首个接受比特币支付的国家；微软、戴尔等知名企业也纷纷接受比特币支付。<br>　　举个栗子，你能直接用比特币买到美国本土生产的外星人电脑。不仅如此，投资者们还可以在火币网等交易平台投资比特币，交易获利。<br>　　现在明白什么是比特币了吗？不明白就继续往下看呗！“区块链100问”让你变身区块链砖家。</p>
<h2 id="3-比特币白皮书的诞生"><a href="#3-比特币白皮书的诞生" class="headerlink" title="3.比特币白皮书的诞生"></a>3.比特币白皮书的诞生</h2><p>　　2008年的美国发生金融危机，波及到世界各地，各国法定货币大幅贬值，人们手里的钱变得不值钱了。<br>　　2008年11月1日，这个历史性的时刻，一位自称中本聪的人在网络上发表了一篇《比特币：一种点对点的电子现金系统》的论文，文中描述了一个全新的货币系统：比特币。<br>　　比特币系统是一种去中心化的数字货币系统，它解决了在没有中心机构的情况下，总量恒定的货币的发行和流通问题。通过比特币系统转账，信息公开透明，可以放心地将比特币转给地球另一端的人，每一笔转账信息都会被全网记录。白皮书的问世，也标志着比特币的底层技术区块链的诞生。</p>
<h2 id="4-第一个比特币诞生了"><a href="#4-第一个比特币诞生了" class="headerlink" title="4.第一个比特币诞生了"></a>4.第一个比特币诞生了</h2><p>　　北京时间2009年1月4日，距离比特币白皮书的发布已经过去3个月了。<br>　　终于，在这个伟大的日子里，白皮书的作者中本聪在位于芬兰赫尔辛基的一个小型服务器上，亲手创建了第一个区块——即比特币的创世区块（Genesis Block），并获得了第一笔50枚比特币的奖励，第一个比特币就此问世。<br>　　当时正处于08年金融危机，为了纪念比特币的诞生，中本聪将当天的《泰晤士报》头版标题——“The Times 03/Jan/2009 ，Chancellor on brink of second bailout for banks”刻在了第一个区块上。<br>　　中本聪这一举动，清晰地展示着比特币的诞生时间，厉害了我的中本聪！</p>
<h2 id="5-谁是中本聪"><a href="#5-谁是中本聪" class="headerlink" title="5.谁是中本聪"></a>5.谁是中本聪</h2><p>　　中本聪是比特币的开发者兼创始者。<br>　　2008年11月1日中本聪发表了比特币白皮书，并于2009年1月3日首次挖出比特币，谁能动用创世区块里的比特币谁便是中本聪本人，所以谁是中本聪呢？<br>　　历史上出现过很多个“中本聪”：<br>　　2013年，有人爆料在数学领域有过卓越贡献的望月新一就是中本聪，但是并没有提出直接证据。<br>　　2014年，黑客黑进了中本聪用过的邮箱，并找到了邮件的主人多利安·中本（Dorian Nakamoto），随后多利安表示自己只是偶然获取了邮箱的地址和密码，并不是中本聪。<br>　　2016年，克雷格·赖特（Craig Wright）表示他是中本聪，且能提供中本聪的私钥。但随后，赖特因为无法面对大家的质疑而撤回自己的声明。</p>
<h2 id="6-密码朋克邮件组是什么"><a href="#6-密码朋克邮件组是什么" class="headerlink" title="6.密码朋克邮件组是什么"></a>6.密码朋克邮件组是什么</h2><p>　　中本聪的比特币白皮书最早发布于“密码朋克”。狭义地说，“密码朋克”是一套加密的电子邮件系统。<br>　　1992年，英特尔的高级科学家Tim May发起了密码朋克邮件列表组织。1993年，埃里克·休斯写了一本书，叫《密码朋克宣言》。这也是“密码朋克”（cypherpunk）一词首次出现。<br>　　“密码朋克”用户约1400人，讨论的话题包括数学、加密技术、计算机技术、政治和哲学，也包括私人问题。早期的成员有非常多IT精英，比如“维基解密”的创始人阿桑奇、BT下载的作者布拉姆·科恩、万维网发明者蒂姆·伯纳斯-李爵士、提出了智能合约概念的尼克·萨博、Facebook的创始人之一肖恩·帕克。<br>　　当然，还包括比特币的发明人中本聪。 据统计，比特币诞生之前，密码朋克的成员讨论、发明过失败的数字货币和支付系统多达数10个。</p>
<h2 id="7-比特币是怎么发行的"><a href="#7-比特币是怎么发行的" class="headerlink" title="7.比特币是怎么发行的"></a>7.比特币是怎么发行的</h2><p>　　比特币没有特定的发行机构，而是依靠一套去中心化的发行机制，逐步将比特币发行出去。<br>　　比特币系统相当于一个去中心化大账本，每个区块就是这个账本中的一页，系统自动生成比特币作为奖励激励矿工参与记账。<br>　　每10分钟，全体矿工一起计算一道问题，最先算出答案的矿工获得记一页账的权利，记账完成后，他将自动获得一定量的比特币，这就是新增比特币的发行过程。<br>　　根据中本聪的设计，最开始每记一次账奖励50个比特币，每记21万页账（也就是21万个区块，大约需要4年），记账的奖励就会减少一半，直到大约2140年，比特币将无法继续细分，至此，比特币发行完毕，总量2100万。所以，挖矿要趁早噢~</p>
<h2 id="8-什么批萨居然卖到3亿多"><a href="#8-什么批萨居然卖到3亿多" class="headerlink" title="8.什么批萨居然卖到3亿多"></a>8.什么批萨居然卖到3亿多</h2><p>　　2010年5月22日，早期比特币爱好者——美国程序员拉兹洛（Laszlo Hanyecz）希望能用比特币交换实物商品。<br>　　他在一个比特币论坛发帖说：希望用10000个比特币交换2个价值25美元的披萨。一位英国志愿者与拉兹洛达成交易，获得了10000个比特币的报酬。<br>　　这是比特币第一次有了价格，在整个加密社区引起了很大的轰动，人们为了纪念这次交易，把每年的5月22日称为“比特币披萨日”，比特币爱好者们聚在一起吃披萨庆祝。<br>　　以现在比特币的比特币价格计算，当时的2块披萨价值约3亿人民币，买披萨的拉兹洛哥哥哭晕在厕所。</p>
<h2 id="9-中本聪的继任者–加文-安德烈森"><a href="#9-中本聪的继任者–加文-安德烈森" class="headerlink" title="9.中本聪的继任者–加文.安德烈森"></a>9.中本聪的继任者–加文.安德烈森</h2><p>　　加文·安德烈森是比特币核心开发团队的成员之一，中本聪从互联网上销声匿迹之前用邮件保持联系的少数几个人之一。<br>　　2010年，加文开始接触比特币，并开始向中本聪提交代码，以优化比特币的核心系统，中本聪逐渐对加文的代码有了信赖。<br>　　最终有一天，中本聪问加文是否可以把他的邮箱放在比特币的主页上，加文同意了。从此，中本聪退到了幕后，加文变成了比特币的领导者。<br>　　加文组建了比特币核心开发团队，致力于修复比特币代码的安全漏洞，提升比特币软件的稳定性使其更易用。<br>　　2012年，加文创建了非盈利性的比特币基金会。比特币的发展壮大，加文及其组建的比特币核心开发团队功不可没。</p>
<h2 id="10-比特水龙头是什么"><a href="#10-比特水龙头是什么" class="headerlink" title="10.比特水龙头是什么"></a>10.比特水龙头是什么</h2><p>　　在刚诞生那几年，比特币很便宜，并且非常容易获得。2010年年底，为了让更多人知道并尝试使用比特币，程序员加文·安德烈森花50美元买入10000个比特币。<br>　　并创建了名为“比特水龙头”的网站，向所有访问网站的人无偿赠送5个比特币，当时大约价值5美分，此举对人们接受比特币有显著的效果。<br>　　后来，有人模仿加文，建立类似比特币水龙头的网站，一方面给访问网站的用户派送小额比特币，另一方面，由于这些网站往往可以获得了大量的浏览量，因此比特币水龙头网站可以通过给主要比特币网站导流赚取广告费。<br>　　比特币水龙头网站甚至形成一种新型商业模式，早期有约50%的比特币网站靠其导流。</p>
<h1 id="比特币有哪些特点"><a href="#比特币有哪些特点" class="headerlink" title="比特币有哪些特点"></a>比特币有哪些特点</h1><h2 id="11-比特币为什么还没有挖完"><a href="#11-比特币为什么还没有挖完" class="headerlink" title="11.比特币为什么还没有挖完"></a>11.比特币为什么还没有挖完</h2><p>　　每10分钟，全网矿工共同计算一道难题，竞争记账权及比特币奖励。如果全网算力不断增长，比特币将很快被挖完。<br>　　为了保证比特币稳定在约10分钟挖出一个区块，中本聪设计矿工挖矿获得比特币的难度每过2016个区块（约2周时间）动态调整一次，调整后的难度使得每生成一个区块的预期时间为10分钟。<br>　　现在的难度系数约为480PH/s，大约是创世区块的680亿倍，也就是说，以现在的算力，全网矿工需要经过约3000万亿亿次哈希运算才能找到一个符合条件的答案，生成新的区块。</p>
<h2 id="12-比特币如何实现总量恒定"><a href="#12-比特币如何实现总量恒定" class="headerlink" title="12.比特币如何实现总量恒定"></a>12.比特币如何实现总量恒定</h2><p>　　比特币是一种通缩型虚拟货币，总量是2100万个，你知道怎么来的吗？<br>　　中本聪在设计比特币的时候，规定每个比特币可以细分到小数点后8位，每个区块发行 50个比特币，每21万个区块后，每个区块的比特币产量减半。<br>　　因为比特币每10分钟产生一个区块，21万个区块大约是四年的时间，截止2017年，比特币产量已经减半2次，当前每个区块发行12.5个比特币。大约在2045年，99.95%的比特币将会发行完毕，到2140年，比特币无法继续细分，至此比特币完全发行完毕，发行总量约为2100万枚比特币（注：实际是20999999.97690000个）。<br>　　尽管比特币通缩的货币政策是否合理在货币学上争议很大，但这一发行机制激励着矿工尽早投入到比特币挖矿中，使得比特币系统获得了大量算力和安全性。</p>
<h2 id="13-比特币和Q币有哪些不同"><a href="#13-比特币和Q币有哪些不同" class="headerlink" title="13.比特币和Q币有哪些不同"></a>13.比特币和Q币有哪些不同</h2><p>　　比特币是一种去中心化的数字资产，没有发行主体。Q币是由腾讯公司发行的电子货币，类似于电子积分，其实不是货币。<br>　　Q币需要有中心化的发行机构，Q币因为腾讯公司的信用背书，才能被认可和使用。使用范围也局限在腾讯的游戏和服务中，Q币的价值完全基于人们对腾讯公司的信任。<br>　　比特币不通过中心化机构发行，但却能够得到全球的广泛认可，是因为比特币可以自证其信，比特币的发行和流通由全网矿工共同记账，不需要中心机构也能确保任何人都无法窜改账本。</p>
<h2 id="14-各国对区块链资产的态度如何"><a href="#14-各国对区块链资产的态度如何" class="headerlink" title="14.各国对区块链资产的态度如何"></a>14.各国对区块链资产的态度如何</h2><p>　　从全球范围来看，各国政府对于区块链、区块链资产的态度不一，但整体来说都还处于探索期。<br>　　欧美国家积极监管。德国是最早将比特币等数字资产认定为私有财产的国家。美国CFTC（美国商品期货委员会）将比特币定性为大宗商品。纽约州目前颁发了3张BitLicense。<br>　　亚洲的情况不一样。日本积极支持。今年4月，日本实施了《支付服务法案》，正式承认比特币是一种合法的支付方式。<br>　　韩国积极监管。7月，韩国《比特币监管法案》面世，设置了5亿韩元的投资者准入门槛。<br>　　中国严格监管。9月，中国人民银行等七部委联合发布《关于防范代币发行融资风险的公告》，规定在中国，交易平台不得从事法定货币与 “虚拟货币”之间的兑换业务。</p>
<h1 id="比特币转帐的原理"><a href="#比特币转帐的原理" class="headerlink" title="比特币转帐的原理"></a>比特币转帐的原理</h1><h2 id="15-比特币怎么转帐"><a href="#15-比特币怎么转帐" class="headerlink" title="15.比特币怎么转帐"></a>15.比特币怎么转帐</h2><p>　　生活中我们都有自己的银行账户，转账是在银行账户之间进行的。同样，比特币转账就是把比特币从一个比特币地址转移到另一个比特币地址上的过程。<br>　　如果你想要转账比特币给别人，你需要在比特币交易平台、比特币钱包或者比特币客户端中，输入你的比特币地址、接收方地址、转账金额和手续费金额。<br>　　确定支付后交易信息会在比特币网络进行全网广播。矿工每隔10分钟会将比特币网络中未被记账的交易打包进一个区块，这就完成了一次确认，此时比特币已转到对方账户。<br>　　通常需要经过6次确认，确保交易记录不能被任何人窜改，转账才算真正完成。</p>
<h2 id="16-比特币转帐要付多少手续费"><a href="#16-比特币转帐要付多少手续费" class="headerlink" title="16.比特币转帐要付多少手续费"></a>16.比特币转帐要付多少手续费</h2><p>　　比特币转账手续费是交易者付给矿工的一笔费用，用于激励矿工竞争记账，为比特币提供足够的算力，从而确保比特币网络的安全，有的地方也叫做矿工费。<br>　　用户在比特币网络发起一笔转账时，一般需要支付给记账矿工一定的转账手续费。转账手续费一般为0.001-0.0015个比特币，由于区块能容纳交易记录的容量有限，矿工会优先打包手续费高的交易，所以多付手续费可以更快被记账。<br>　　比特币交易手续费的存在能提高转账门槛，有效防止区块链中充斥垃圾信息，并且能够保证在比特币被挖完之后矿工仍有动力维护比特币网络。</p>
<h2 id="17-区块链转帐居然按字节收费"><a href="#17-区块链转帐居然按字节收费" class="headerlink" title="17.区块链转帐居然按字节收费"></a>17.区块链转帐居然按字节收费</h2><p>　　我们经常在银行间进行转账，银行间转账手续费一般是按照转账金额的一定比例收取。<br>　　比如跨行转账手续费约为5‰，异地转账的手续费为1‰-1%不等，而跨国转账除了支付以上手续费以外，还需支付50-200元每笔的电报费。<br>　　而区块链资产之间的转账手续费与转账的金额大小无关，按字节收费。以比特币转账为例，一笔普通交易约占250字节，手续费约为0.001-0.0015个比特币（约20-30元）。如果你需要在一笔交易中同时转账给多个比特币地址，那么这笔交易所占字节数会更大，所以你需要多付一些手续费，才会有矿工及时打包你的交易。<br>　　即便如此，从转账成本来看，用区块链进行跨国转账还是有很大的优势。</p>
<h2 id="18-比特币地址是什么"><a href="#18-比特币地址是什么" class="headerlink" title="18.比特币地址是什么"></a>18.比特币地址是什么</h2><p>　　比特币地址是一串由字母和数字组成的26位到34位字符串，看起来有些像乱码。<br>　　通过区块链可以查到每个比特币地址的所有转账记录。<br>　　比特币地址就是个人的比特币账户，相当于你的银行卡卡号，任何人都可以通过你的比特币地址给你转账比特币。<br>　　如何获取自己专属的比特币地址呢？你可以下载一个比特币钱包，或者在交易平台上注册。每个人的比特币地址都是独一无二的。有地址就可以进行比特币转账啦。下载比特币客户端或者比特币钱包，也能注册自己的比特币地址。快去创建你的专属比特币地址吧~</p>
<h2 id="19-比特币节点是什么"><a href="#19-比特币节点是什么" class="headerlink" title="19.比特币节点是什么"></a>19.比特币节点是什么</h2><p>　　比特币是一种点对点的电子现金系统，更直接地说，是节点对节点。每笔交易由发起方向周围的节点进行广播，节点收到之后再广播给自己周围的节点，最终扩散至全网。<br>　　每一个比特币钱包都是一个节点，其中拥有完整区块链账本的节点叫做全节点。2017年10月，比特币全网约有9300个全节点，负责比特币转账交易的广播和验证。<br>　　转账交易发生后，由所有节点共同广播至全网，挖矿的节点验证该交易正确后会记录至区块链账本。<br>　　美国、德国、法国拥有的比特币全节点数最多，中国的全节点数量约占全球5%（数据来源于： bitnodes.21.co）。运行比特币节点不提供任何奖励，且不需要全节点也可以进行比特币转账，所以比特币的全节点数只占节点数的一小部分。</p>
<h2 id="20-从发出交易到矿工打包需要几步"><a href="#20-从发出交易到矿工打包需要几步" class="headerlink" title="20.从发出交易到矿工打包需要几步"></a>20.从发出交易到矿工打包需要几步</h2><p>　　当你发起一笔比特币转账后，你需要将交易广播至全网，挖矿节点接到这笔交易后，先将其放入本地内存池进行一些基本验证，比如该笔交易花费的比特币是否是未被花费的交易。<br>　　如果验证成功，则将其放入“未确认交易池”（Unconfirm Transaction），等待被打包；如果验证失败，则该交易会被标记为“无效交易”（Invalid Transaction），不会被打包。也就是说，挖矿节点在比拼算力的同时还需要及时验证每笔交易，更新自己的“未确认交易池”。节点抢到记账权后，将从“未确认交易池”中抽取约近千笔“未确认交易”进行打包。<br>　　有时候我们的交易不能被及时打包，是因为“未确认交易池”中的交易笔数太多，而每个区块能记录的交易笔数有限，这时候就会造成区块拥堵。</p>
<h2 id="21-比特币的数字签名是什么"><a href="#21-比特币的数字签名是什么" class="headerlink" title="21.比特币的数字签名是什么"></a>21.比特币的数字签名是什么</h2><p>　　比特币的数字签名，就是只有比特币转账的转出方生成的，一段防伪造的字符串。通过验证该数字串，一方面证明该交易是转出方发起的，另一方面证明交易信息在传输中没有被更改。<br>　　数字签名通过数字摘要技术把交易信息缩短成固定长度的字符串。举个栗子，牛牛发起一笔比特币转账，需要先将该交易进行数字摘要，缩短成一段字符串，然后用自己的私钥对摘要进行加密，形成数字签名。完成后，牛牛需要将原文（交易信息）和数字签名一起广播给矿工，矿工用牛牛的公钥进行验证，如果验证成功，说明该笔交易确实是牛牛发出的，且信息未被更改。<br>　　同时，数字签名加密的私钥和解密的公钥不一致，采用非对称加密技术。看起来好复杂，其实转账只需要你输入私钥就瞬间完成啦！</p>
<h2 id="22-比特币交易和找零机制是怎样的"><a href="#22-比特币交易和找零机制是怎样的" class="headerlink" title="22.比特币交易和找零机制是怎样的"></a>22.比特币交易和找零机制是怎样的</h2><p>　　比特币转账可以一次把多个地址的余额转出，也可以一次转入多个地址。<br>　　举个栗子，你需要支付给牛牛5个比特币，但是你的A/B/C 3个地址里各有1/2/2个比特币，每个地址的余额都不足以支付5个比特币。<br>　　这时候，你可以发起一笔转账，同时把A/B/C三个地址共5个比特币转账给牛牛。再举个栗子，如果你的比特币地址有5个比特币，但是你只需要转1个给牛牛。你需要在转账的时候告诉矿工：我有5个比特币，其中1个转给牛牛，另外4个转回给我自己（可以是原地址或创建新的地址）。<br>　　千万别忘了说哦，不然剩余的4个比特币就全给矿工当手续费了。这就是比特币的找零机制。</p>
<h1 id="区块链产业链上游–挖矿"><a href="#区块链产业链上游–挖矿" class="headerlink" title="区块链产业链上游–挖矿"></a>区块链产业链上游–挖矿</h1><h2 id="23-挖矿是什么"><a href="#23-挖矿是什么" class="headerlink" title="23.挖矿是什么"></a>23.挖矿是什么</h2><p>　　挖矿是将一段时间内比特币系统中发生的交易进行确认，并记录在区块链上形成新区块的过程，挖矿的人叫做矿工。简单说来，挖矿就是记账的过程，矿工是记账员，区块链就是账本。<br>　　怎样激励矿工来挖矿呢？比特币系统的记账权力是去中心化的，即每个矿工都有记账的权利。成功抢到记账权的矿工，会获得系统新生的比特币奖励。因此，挖矿就是生产比特币的过程。<br>　　中本聪最初设计比特币时规定每产生210000个区块，比特币奖励减半一次，直至比特币不能再被细分。因为比特币和黄金一样总量有限。所以比特币被称为数字黄金，比特币生产也俗称挖矿。</p>
<h2 id="24-比特币怎么挖矿"><a href="#24-比特币怎么挖矿" class="headerlink" title="24.比特币怎么挖矿"></a>24.比特币怎么挖矿</h2><p>　　比特币通过挖矿产生。每10分钟，全网矿工一起计算一道算术题，谁先算出答案，就相当于挖到了这个区块，该矿工便能获得系统新生的比特币奖励。<br>　　在比特币刚诞生的时候，通过计算机的CPU便可以挖矿。随着挖矿的矿工越来越多，目前用CPU已经不能挖出比特币了，大家开始用矿机挖矿。<br>　　如果你想挖矿，首先需要准备好矿机、比特币地址、挖矿软件等。但是目前比特币网络算力太大，个人购置少量矿机也很难挖出区块。很多矿工加入矿池一起挖矿，矿场只负责计算，矿池负责信息打包。<br>　　矿池挖到比特币之后根据矿场的算力占比分配收益，以此保证更加稳定的投入产出。</p>
<h2 id="26-矿工是怎么挖矿的"><a href="#26-矿工是怎么挖矿的" class="headerlink" title="26.矿工是怎么挖矿的"></a>26.矿工是怎么挖矿的</h2><p>　　在区块链兴起之前，矿工专指挖煤矿的工人，群体印象是浑身沾满了煤屑，衣服以外都是黝黑皮肤的人。<br>　　区块链诞生之后，矿工不再只是煤矿工人的简称，有了一种全新的含义：从事虚拟货币挖矿的人。<br>　　和传统的“矿工”不同，区块链产业区块链领域的矿工具有更多的科技色彩。矿工的主要工作是交易确认和数据打包，如果你想成为一名矿工，其实也比较简单，购买一台专用的计算设备，下载挖矿软件，就可以开始挖矿了。挖矿不需要矿工亲自动手，实际是由电脑在执行特定的运算，对于矿工来说只要保证矿机电力供应和网络连接就可以了。</p>
<h2 id="27-矿机是什么"><a href="#27-矿机是什么" class="headerlink" title="27.矿机是什么"></a>27.矿机是什么</h2><p>　　以比特币为例，比特币矿机就是通过运行大量计算争夺记账权从而获得新生比特币奖励的专业设备，一般由挖矿芯片、散热片和风扇组成，只执行单一的计算程序，耗电量较大。<br>　　挖矿实际是矿工之间比拼算力，拥有较多算力的矿工挖到比特币的概率更大。随着全网算力上涨，用传统的设备（CPU、GPU）挖到比特的难度越来越大，人们开发出专门用来挖矿的芯片。芯片是矿机最核心的零件。芯片运转的过程会产生大量的热，为了散热降温，比特币矿机一般配有散热片和风扇。<br>　　用户在电脑上下载比特币挖矿软件，用该软件分配好每台矿机的任务，就可以开始挖矿了。每种币的算法不同，所需要的矿机也各不相同。</p>
<h2 id="28-比特币挖矿机的进化史"><a href="#28-比特币挖矿机的进化史" class="headerlink" title="28.比特币挖矿机的进化史"></a>28.比特币挖矿机的进化史</h2><p>　　自从比特币诞生以来，比特币挖矿经历了以下四个阶段：<br>　　CPU挖矿-GPU挖矿-专业矿机挖矿-矿池挖矿。<br>　　2009年1月3日，比特币创始人中本聪用电脑CPU挖出了第一批比特币。<br>　　随着大家对比特币的认可，挖矿的人越来越多，全网算力不断上升，挖矿难度逐渐上涨。<br>　　2010年9月18日第一个显卡挖矿软件发布。一张显卡相当于几十个CPU，挖矿能力得到明显提升。<br>　　之后又有人发明了基于挖矿芯片的专业挖矿设备，即矿机。目前行业领先的蚂蚁矿机装有将近200张BM1387芯片，相当于3万多张GPU的算力。<br>　　随着更多矿机加入挖矿，单独的矿机也很难挖到比特币了。于是，矿工将自己的矿机集中起来，形成了矿场和矿池。</p>
<h2 id="29-矿场长什么样"><a href="#29-矿场长什么样" class="headerlink" title="29.矿场长什么样"></a>29.矿场长什么样</h2><p>　　矿场是集中管理矿机的场所，一般选址在电费相对比较便宜并且比较稳定的地方。早期的矿场运营比较粗放，就是搭一个架子，然后把矿机放上去，就可以开始运营了。后来发现这种运行方式下，矿机损坏率高，维修成本太高了。<br>　　后来开始有了通风、还有隔尘等方案，再往后发展，就有了有室内温度和湿度的严格控制。现在整个矿场的运营方案还在不断升级和进化。<br>　　因为矿机运行起来噪音比较大，一台矿机运转时，在一米处测试噪音达73dB(a)左右，几千台矿机运转起来的时候对周围的影响可想而知，所以有些地方经过设计和装修改造，出现了静音矿场。</p>
<h2 id="29-矿池怎么挖矿"><a href="#29-矿池怎么挖矿" class="headerlink" title="29.矿池怎么挖矿"></a>29.矿池怎么挖矿</h2><p>　　随着参与挖矿的人数越来越多，比特币全网的算力不断上涨，单个设备或少量的算力都很难再挖到比特币。这时候，矿池诞生了。<br>　　矿池突破地理位置的限制，将分散在全球的矿工及矿场的算力进行联结，一起挖矿。矿池负责信息打包，接入进来的矿场负责竞争记账权。由于集合了很多矿工的算力，所以矿池的算力占比大，挖到比特币的概率更高。矿池挖矿所产生的比特币奖励会按照每个矿工贡献算力的占比进行分配。相较单独挖矿，加入矿池可以获得更加稳定的收益。<br>　　目前全球算力较大的矿池有鱼池（F2Pool）、蚁池（AntPool）、币网（BW Pool）、国池（BTCC Pool）、BitFury。除了BitFury，其余都来自中国。</p>
<h2 id="30-算力是什么"><a href="#30-算力是什么" class="headerlink" title="30.算力是什么"></a>30.算力是什么</h2><p>　　在通过“挖矿”得到比特币的过程中，我们需要找到其相应的解，而要找到其解，并没有固定算法，只能靠计算机随机的哈希碰撞。<br>　　一台矿机每秒钟能做多少次哈希碰撞，就是其“算力”的代表，单位写成hash/s。<br>　　算力可以简单的理解为计算能力。目前主流的矿机为14T左右的计算量级，即一台矿机就能每秒做至少1.4*10的13次方次哈希碰撞，我们可以说，这一台14T规格的矿机就有14T的算力。矿工所掌握的所有矿机占比特币全网总算力的百分比是多少，就代表TA在这10分钟竞争中能够获胜的概率就是多少。<br>　　举个例子，如果比特币现在全网的算力是100，而某个矿工拥有10的算力，那么TA每次竞争记账成功的概率就是1/10。</p>
<h2 id="31-竞争记账是什么"><a href="#31-竞争记账是什么" class="headerlink" title="31.竞争记账是什么"></a>31.竞争记账是什么</h2><p>　　竞争记账是比特币系统的记账方式，它解决了如何在去中心化的记账系统中，保证比特币账本一致性的问题。比特币系统中没有中心化的记账机构，每一个节点都有记账权，如何保证账本一致性是一个重要的问题。<br>　　在比特币网络中，全网矿工共同参与算力竞争，算力高的矿工计算能力更强，更容易获得记账权。成功抢到记账权的矿工负责记账，并将账本信息同步给整个网络。作为回报，矿工将获得系统新生成的比特币奖励。<br>　　随着比特币价格上涨，为了获得比特币，越来越多人参与竞争比特币记账权，全网算力难度呈指数级上升。</p>
<h1 id="区块链产业链中游–交易"><a href="#区块链产业链中游–交易" class="headerlink" title="区块链产业链中游–交易"></a>区块链产业链中游–交易</h1><h2 id="32-如何投资区块链资产"><a href="#32-如何投资区块链资产" class="headerlink" title="32.如何投资区块链资产"></a>32.如何投资区块链资产</h2><p>　　从2008年中本聪发布比特币白皮书至今，区块链资产的种类日益增加，投资方式也更加丰富。<br>　　2009年比特币刚诞生那会儿，投资者以极客为主，但是随着更多专业投资者的加入，区块链资产的投资方式更加丰富。<br>　　目前，投资者参与区块链资产投资的渠道很多，场内交易、场外交易、中心化交易平台、去中心化交易平台都可以进行投资。不仅投资渠道变多了，投资方式也更丰富了，投资者可以通过趋势交易、对冲、跨平台搬砖等交易方式投资获利。</p>
<h2 id="33-如何在交易平台投资区块链资产"><a href="#33-如何在交易平台投资区块链资产" class="headerlink" title="33.如何在交易平台投资区块链资产"></a>33.如何在交易平台投资区块链资产</h2><p>　　相较于点对点交易、挖矿等，在交易平台购买是目前获得区块链资产最主流的方式，即场内交易。<br>　　区块链资产的场内交易和股票类似，由平台帮你撮合，你不知道也不需要知道跟你成交的对手是谁，你的成交对手有可能是一个人，也有可能是很多人。<br>　　无论是买入还是卖出，交易平台会记录所有人的挂单价格，买卖双方通过实时买卖盘可以获取最新成交价格。同时，交易平台会将历史成交价格及成交量汇总成K线图，方便投资者用于分析行情走势。<br>　　比如huobi.pro就是全球比较主流的交易平台。</p>
<h2 id="34-量化交易是什么"><a href="#34-量化交易是什么" class="headerlink" title="34.量化交易是什么"></a>34.量化交易是什么</h2><p>　　量化交易，有时候也称自动化交易，是指以先进的数学模型替代人为的主观判断。<br>　　极大地减少了投资者情绪波动的影响，避免在市场极度狂热或悲观的情况下做出非理性的投资决策。<br>　　量化交易有很多种，包括跨平台搬砖、趋势交易、对冲等。跨平台搬砖是指，当不同目标平台价差达到一定金额，在价高的平台卖出，在价低的平台买入。<br>　　趋势交易会更加复杂一些，它根据趋势的指标来发出卖出和买入的信号。对冲是指同时进行两笔与行情相关、买卖方向相反、数量相当、盈亏相抵的交易，以达到对冲风险的效果。量化交易是成熟交易市场的标志。</p>
<h2 id="35-区块链资产如何在场外交易"><a href="#35-区块链资产如何在场外交易" class="headerlink" title="35.区块链资产如何在场外交易"></a>35.区块链资产如何在场外交易</h2><p>　　场外交易也叫OTC交易。用户需要自己寻找交易对手，不通过撮合成交，成交价格由交易双方协商确定，交易双方可以借助当面协商或者电话通讯等方式充分沟通。<br>　　场外交易是最原始的交易方式。比特币刚诞生的时候，并没有交易平台，投资者只能通过场外交易交易比特币，且大多采用一手交钱一手交货的交易方式。<br>　　现在，已经有很多规范化的场外交易平台，投资者可以直接在交易平台上选择交易对手方，和场内交易一样便捷。通过交易平台，可以有效避免在场外交易中因信息不对称导致人货两空的情况。<br>　　目前比较主流的场外交易平台有 Localbitcoins 和 huobi.pro 等。</p>
<h2 id="36-去中心化交易平台是什么"><a href="#36-去中心化交易平台是什么" class="headerlink" title="36.去中心化交易平台是什么"></a>36.去中心化交易平台是什么</h2><p>　　2013年至今，诞生了很多去中心化交易平台。与中心化交易平台不同，去中心化交易平台不需要注册账户，使用个人数字资产账户即可参与交易。<br>　　其次，去中心化交易平台每笔交易都通过区块链进行，需要等待区块链的确认才算交易成功。同时，去中心化交易平台不负责保管用户的资产和私钥等信息，一方面避免了交易平台的道德风险，另一方面要求你千万保管好自己的私钥。<br>　　由于去中心化交易平台普遍存在流动性低、交易处理速度慢等特点，目前交易总量仅占全球数字资产交易总量的0.03%。目前，去中心化交易平台项目Airswap、Kyber、0x、OmiseGo的代币都可以在huobi.pro上进行交易。</p>
<h2 id="37-币币交易是什么"><a href="#37-币币交易是什么" class="headerlink" title="37.币币交易是什么"></a>37.币币交易是什么</h2><p>　　随着区块链资产种类的增加，传统的法定货币对区块链资产的交易已经不能满足全球投资者的投资需求，更多专业投资者开始尝试币币交易。<br>　　币币交易是指用一种区块链资产定价另一种区块链资产，比如说用比特币定价以太坊会产生ETH/BTC交易对。该交易对的价格表示你需要用多少比特币可以买到一个以太坊。<br>　　通过币币交易，你可以直接用一种区块链资产换取另一种区块链资产，中间不涉及法定货币的中转或者结算。现在全球比特币的交易量，将近一半来自币币交易，法定货币与比特币交易的比例逐渐缩小。目前比较知名的币币交易交易平台有huobi.pro等。</p>
<h1 id="区块链产业链中游–存储"><a href="#区块链产业链中游–存储" class="headerlink" title="区块链产业链中游–存储"></a>区块链产业链中游–存储</h1><h2 id="38-比特币钱包是干嘛的"><a href="#38-比特币钱包是干嘛的" class="headerlink" title="38.比特币钱包是干嘛的"></a>38.比特币钱包是干嘛的</h2><p>　　比特币是一种点对点的电子现金系统，没有实物形态，可以存储在比特币钱包里。比特币钱包里存储着你的比特币信息，包括比特币地址（类似于你的银行卡账号）、私钥（类似于你银行卡的密码）。<br>　　就像实物钱包里可以存放多张银行卡，比特币钱包里也可以存储多个比特币地址，以及每个比特币地址所对应的独立的私钥。比特币钱包的核心功能就是保护你的私钥，如果钱包丢失，你将永远失去这笔比特币。<br>　　比特币钱包有很多种形态，如PC或手机钱包客户端、在线网页钱包、甚至是记录了比特币私钥的小本本（纸钱包）或者大脑（脑钱包）。你可以根据需求来选择适合自己的钱包。俗话说“鸡蛋不要放在一个篮子里”，采用多种方式分散存储也是降低风险的有效方式。</p>
<h2 id="39-冷钱包-热钱包"><a href="#39-冷钱包-热钱包" class="headerlink" title="39.冷钱包 热钱包"></a>39.冷钱包 热钱包</h2><p>　　比特币钱包按照私钥的存储方式，可以分为冷钱包、热钱包两种。<br>　　冷钱包是指网络不能访问到你私钥的钱包。冷钱包往往依靠“冷”设备确保比特币私钥的安全，比如不联网的电脑、手机、写着私钥地址的小本本等。冷钱包避免了被黑客盗取私钥的风险，但是可能面临物理安全风险，比如电脑丢失损坏等。<br>　　热钱包是指互联网能购访问你私钥的钱包。热钱包往往是在线钱包的形式。使用热钱包时，最好在不同平台设置不同密码，且开启二次认证，以确保自己的资产安全。<br>　　无论是使用冷钱包还是热钱包，只要其他人知道了你的比特币私钥，就能转走你的比特币。记住，谁手握私钥，谁才是比特币真正的主人。</p>
<h2 id="40-全节点钱包和轻钱包"><a href="#40-全节点钱包和轻钱包" class="headerlink" title="40.全节点钱包和轻钱包"></a>40.全节点钱包和轻钱包</h2><p>　　前面我们知道了钱包的多种形态，也知道了钱包其实就是“私钥、地址和区块链数据的管理工具”。根据区块链数据的维护方式和钱包的去中心化程度，我们可以把钱包分为：全节点钱包、轻钱包、中心化钱包。<br>　　全节点的代表是 bitcoin-core 核心钱包，需要同步所有区块链数据，占用很大的内存，但是可以完全实现去中心化。轻钱包依赖比特币网络上其他全节点，仅同步与自己相关的数据，基本可以实现去中心化。<br>　　中心化钱包不依赖比特币网络，所有的数据均从自己的中心化服务器中获得，但是交易效率很高，可以实时到账，你在交易平台注册的账号就是中心化钱包。</p>
<h1 id="区块链产业链下游"><a href="#区块链产业链下游" class="headerlink" title="区块链产业链下游"></a>区块链产业链下游</h1><h2 id="41-比特币可以用于支付吗"><a href="#41-比特币可以用于支付吗" class="headerlink" title="41.比特币可以用于支付吗"></a>41.比特币可以用于支付吗</h2><p>　　比特币作为一种数字资产，目前在部分国家可以用于支付，比如日本和德国。大部分商家通过第三方支付机构间接接受比特币，即买方购物支付比特币，第三方机构收到比特币后立即兑换成法币，商家收到的是法币而不是比特币。<br>　　商家这种把交易限定在第三方平台内的做法，使得交易时不用真的转账比特币，只是双方资产数字的变化，让比特币“秒到账”成为了现实。<br>　　用比特币支付操作很简单，一般是打开手机上的比特币钱包扫描二维码，或者点击比特币地址跳转到PC客户端进行支付就可以。和微信、支付宝等在线支付不同，使用比特币支付，扫码之后会先展示比特币的实时汇率，买卖双方确认后再进行支付。</p>
<h1 id="区块链到底长什么样"><a href="#区块链到底长什么样" class="headerlink" title="区块链到底长什么样"></a>区块链到底长什么样</h1><h2 id="42-区块链和比特币是什么关系"><a href="#42-区块链和比特币是什么关系" class="headerlink" title="42.区块链和比特币是什么关系"></a>42.区块链和比特币是什么关系</h2><p>　　区块链技术是比特币的底层技术，比特币是区块链的第一个应用。前面提到，比特币的交易信息都被记录在一个去中心化的账本上面，这个账本就是区块链。<br>　　如果我们把区块链类比成一个实物账本，那么每个区块就相当于这个账本中的一页，每10分钟生成一页新的账本，每一页账本上记载着比特币网络这10分钟的交易信息。每个区块之间依据密码学原理，按照时间顺序依次相连，形成链状结构，因此得名区块链。<br>　　自白皮书《比特币：一种点对点的电子现金系统》诞生后，国内外各大金融机构争相研究比特币底层技术区块链，并寻求区块链技术的实际应用。</p>
<h2 id="43-区块链技术的发展历史"><a href="#43-区块链技术的发展历史" class="headerlink" title="43.区块链技术的发展历史"></a>43.区块链技术的发展历史</h2><p>　　比特币刚诞生的时候，并没有“区块链”这个概念，人们用bitcoin（小写b）表示比特币，用Bitcoin（大写B）表示其底层技术，也就是我们现在说的区块链技术。<br>　　2015年，经济学人发布了封面文章《重塑世界的区块链技术》后，区块链技术在全球掀起一股金融科技狂潮，世界各大金融机构、银行争相研究区块链技术，仅2016年就有数十亿美元投资到区块链相关企业当中。<br>　　2017年9月，中国政府网（www.gov.cn）发表文章《我国区块链产业有望走在世界前列》，公开支持区块链技术发展，并向13亿中国人民普及了区块链技术。区块链在金融、保险、零售、公证等实体经济领域的应用开始加速落地。</p>
<h2 id="44-区块链，制造信用的机器"><a href="#44-区块链，制造信用的机器" class="headerlink" title="44.区块链，制造信用的机器"></a>44.区块链，制造信用的机器</h2><p>　　区块链并不是新发明的一种技术，而是一系列技术的集成，包括非对称加密技术、时间戳、共识机制等。<br>　　以比特币为例，区块链通过时间戳（Timestamp）和工作量证明（Proof of Work）机制解决了双重支付（Double Spending）和拜占庭将军问题（Byzantine Generals’ Problem），即保证同一笔比特币不可能被花费2次，并且在整个去中心化的区块链网络中，在所有节点间保持一致。<br>　　非对称加密机制保证私钥的安全性，时间戳保证区块按顺序连接成链，工作量证明机制解决了在去中心化系统中如何公平地分发2100万个比特币的问题。<br>　　区块链技术具有匿名性、去中心化、公开透明等特点。所以，区块链被誉为制造信用的机器。</p>
<h2 id="45-区块如何连接成区块链"><a href="#45-区块如何连接成区块链" class="headerlink" title="45.区块如何连接成区块链"></a>45.区块如何连接成区块链</h2><p>　　区块链由一串使用密码学算法产生的区块连接而成。每一个区块上写满了交易记录，区块按顺序相连形成链状结构，也就是区块链大账本。<br>　　以比特币为例，矿工在生成新区块时，需要根据前一个区块的哈希值、新交易区块和随机数，来计算新的哈希值和随机数。也就是说每一个区块都是在前一个区块数据的基础上生成的，该机制保证了区块链数据的唯一性。<br>　　因为交易记录细微的变化也会彻底改变哈希值的结果，所以矿工在进行算力竞争的时候无法作弊，每个矿工都必须等前一个区块生成之后才能根据前一个区块的数据开始计算符合条件的随机数，保证了挖矿的公平性。</p>
<h2 id="46-区块链记录哪些信息"><a href="#46-区块链记录哪些信息" class="headerlink" title="46.区块链记录哪些信息"></a>46.区块链记录哪些信息</h2><p>　　区块链是比特币网络的大账本，而每个区块相当于账本中的一页。那么“账本”内记载了哪些信息呢？目前比特币每个区块内主要记载了区块头、交易详情、交易计数器和区块大小等数据。<br>　　“区块头”内包含了除交易信息以外的所有信息，主要包括上一区块头哈希值：用于保证区块按顺序串连；时间戳：记录该区块的生成时间；随机数：即全网矿工一起PK的算术题答案；难度目标：该算术题的难度系数打分。<br>　　“交易详情”详细记载了每笔交易的转出方、收入方、金额及转出方的数字签名，是每个区块内的主要内容。<br>　　“交易计数器”表述每个区块中包含交易的数量。<br>　　“区块大小”表示每个区块数据的大小，当前每个区块限定在1MB以内，不排除以后有扩大的可能。</p>
<h2 id="47-时间戳是什么"><a href="#47-时间戳是什么" class="headerlink" title="47.时间戳是什么"></a>47.时间戳是什么</h2><p>　　区块链通过时间戳保证每个区块依次顺序相连。时间戳使区块链上每一笔数据都具有时间标记。简单来说，时间戳证明了区块链上什么时候发生了什么事情，且任何人无法篡改。<br>　　时间戳在区块链中扮演公证人的角色，而且比传统的公证制度更为可信，因为区块链上记录的信息无法被任何人以任何方式修改。<br>　　因为运用了时间戳，区块链技术很适合用于知识产权保护等领域。举个例子，你写了一篇论文，在发布之前想先找行业专家指点一下，但是你担心专家直接用他的名义发表。这时候你只需先保存在链上，便可以轻松证明版权。</p>
<h2 id="48-最长区块链才是正确的区块链"><a href="#48-最长区块链才是正确的区块链" class="headerlink" title="48.最长区块链才是正确的区块链"></a>48.最长区块链才是正确的区块链</h2><p>　　比特币白皮书规定，节点永远认为最长链是正确的区块链，并将持续在它上面延长。所有矿工都在最长链上挖矿，有利于区块链账本的唯一性。如果给你转账的比特币交易不记录在最长链上，你将有可能面临财产损失。<br>　　怎样算是“最长的区块链”呢？因为全世界的矿工同时在挖矿，有可能同时有2个矿工算出了正确的答案，那么区块链就会形成分叉，剩下的矿工有可能在其中任意一条分叉上继续挖矿，延长区块链。<br>　　所以我们通常要求在比特币转账被打包之后，还需要经历6个区块的确认，确保矿工不会再回到另一条分叉上挖矿时，才算真正的转账成功。</p>
<h2 id="49-区块链的分类–公有链，私有链和联盟链"><a href="#49-区块链的分类–公有链，私有链和联盟链" class="headerlink" title="49.区块链的分类–公有链，私有链和联盟链"></a>49.区块链的分类–公有链，私有链和联盟链</h2><p>　　区块链按准入机制分成3类：公有链，私有链和联盟链。以后还可能诞生其他类型的区块链。<br>　　公有链公开透明。世界上任何个体或者团体都可以在公有链发送交易，且交易能够获得该区块链的有效确认。每个人都可以竞争记账权。比特币区块链就是公有链的典型代表。<br>　　联盟链半公开。是某个群体或组织内部使用的区块链，需要预先指定几个节点为记账人，每个区块的生成由所有预选记账人共同决定，其他节点可以交易，但是没有记账权。<br>　　私有链则完全封闭。仅采用区块链技术进行记账，记账权并不公开，且只记录内部的交易，由公司或者个人独享。</p>
<h1 id="区块链资产都有哪些特点"><a href="#区块链资产都有哪些特点" class="headerlink" title="区块链资产都有哪些特点"></a>区块链资产都有哪些特点</h1><h2 id="50-区块链资产的特点–全球流通"><a href="#50-区块链资产的特点–全球流通" class="headerlink" title="50.区块链资产的特点–全球流通"></a>50.区块链资产的特点–全球流通</h2><p>　　区块链资产有几大特点，其中之一就是全球流通。区块链资产首先是基于互联网的。只要有互联网的地方，区块链资产就可以进行流通。这里的互联网可以是万维网，也可以是各种局域网，所以，区块链资产是全球流通的。<br>　　甚至你在月球、火星上，你只要有互联网，我就可以把我的区块链资产转账给你。<br>　　相较于中心化的方式，区块链资产在全球流通的转账手续费非常低。比如比特币早期转账手续费为0.0001BTC，现在就稍微有点贵了，其他如Bitcoin Cash网络转账手续费为0.0001BCC，达世转账手续费为0.002Dash，以太坊的转账手续费为0.01ETH，折合人民币才几块钱，非常便宜。相对于传统转账来说，区块链资产到账也非常快，一般几分钟到1小时就能到账。</p>
<h2 id="51-区块链资产的特点–匿名性"><a href="#51-区块链资产的特点–匿名性" class="headerlink" title="51.区块链资产的特点–匿名性"></a>51.区块链资产的特点–匿名性</h2><p>　　区块链资产的第二大特点是匿名性。就是别人无法知道你的区块链资产有多少，以及和谁进行了转账。这种匿名性是分不同程度的。<br>　　比特币的匿名性是最基本的。你在区块链网络上只能查到转账记录，但是不知道地址背后是谁。但是，一旦知道这个地址背后对应的人是谁，也就能查到其所有相关的转账记录及资产。达世币和门罗币匿名性做得更高。即使你查到了这个地址背后的人是谁，你也无法知道它所有的转账信息。<br>　　而Zcash将匿名性做到极致，只有拥有私钥的人才能查到所有的转账信息。</p>
<h2 id="52-区块链资产的特点–去中心化"><a href="#52-区块链资产的特点–去中心化" class="headerlink" title="52.区块链资产的特点–去中心化"></a>52.区块链资产的特点–去中心化</h2><p>　　区块链资产的第三大特点是记账去中心化。<br>　　你给别人的转账，不会因为记账机构要放假，所以延迟几天到账；不会因为记账机构要盈利，所以要付很高手续费；更不会因为记账机构作弊，而受到损失。<br>　　因为它的记账是全网共同进行的。你给别人转账记录的账本，不会因为你这里或者对方那里的账本数据丢失，而无法统一，因为这个账本是全网共同维护，每个全节点都有备份。如果你转账0.5个币给火币牛牛，你们俩一起看全网的记录数据就好：有没有到账、几个确认了等等，十分透明公正。</p>
<h2 id="53-区块链资产的特点–不可复制"><a href="#53-区块链资产的特点–不可复制" class="headerlink" title="53.区块链资产的特点–不可复制"></a>53.区块链资产的特点–不可复制</h2><p>　　区块链资产的第四大特点就是不可复制。互联网上信息的传播方式是拷贝。我发送给火币牛牛一个很好玩的图片，网络是把我手里的照片复制了一份给牛牛，并不是真的从我这里拿走，我的手机里依然保存着这张图片。<br>　　网络上的著作权一直是个大问题。文字、图片、影像很容易被拷贝，给它们的版权所有者带来很大困扰。<br>　　区块链资产之所以能够成为资产，很重要的因素就是因为它的不可复制性。它可传递是通过加密技术而不是拷贝。一份价值1000元的区块链资产，我发送给牛牛，这1000元资产就从我的账户转移到牛牛的账户里，我不再拥有这1000元资产。不可复制性，是保证它成为资产的一个重要因素。</p>
<h1 id="区块链有哪些技术原理"><a href="#区块链有哪些技术原理" class="headerlink" title="区块链有哪些技术原理"></a>区块链有哪些技术原理</h1><h2 id="54-区块链的共识机制是什么？"><a href="#54-区块链的共识机制是什么？" class="headerlink" title="54.区块链的共识机制是什么？"></a>54.区块链的共识机制是什么？</h2><p>　　在区块链系统当中，没有一个像银行一样的中心化记账机构，保证每一笔交易在所有记账节点上的一致性，即让全网达成共识至关重要。共识机制解决的就是这个问题。<br>　　目前主要的共识机制有工作量证明机制PoW和权益证明机制PoS。<br>　　PoW通过评估你的工作量来决定你获得记账权的机率，工作量越大，就越有可能获得此次记账机会。<br>　　PoS通过评估你持有代币的数量和时长来决定你获得记账权的机率。这就类似于股票的分红制度，持有股权相对多的人能够获得更多的分红。<br>　　DPOS与POS原理相似，只是选了一些“人大代表”。 与PoS的主要区别在于节点选举若干代理人，由代理人验证和记账。<br>　　随着技术的发展，未来可能还会诞生更先进的共识机制。</p>
<h2 id="55-工作量证明机制（POW）是什么"><a href="#55-工作量证明机制（POW）是什么" class="headerlink" title="55.工作量证明机制（POW）是什么"></a>55.工作量证明机制（POW）是什么</h2><p>　　工作量证明（Proof of Work，简称POW）是共识机制的一种，可简单理解为一份证明，证明你做过一定量的工作，即我通过查看工作结果就能知道你完成了指定量的工作。<br>　　比特币挖矿采用的就是工作量证明机制，比特币网络通过调节计算难度，保证每次竞争记账都需要全网矿工计算约10分钟，才能算出一个满足条件的结果。该结果即“区块头”里包含的随机数。<br>　　工作量证明是指，如果矿工找到了一个满足条件的结果，我们便可以认为全网矿工完成了指定难度系数的工作量。获得记账权的几率取决于矿工工作量占比全网的比例，如果占比30%，那么获得记账权的几率也是30%。所以提高工作量占比才能提高竞争力，才能获得更多新诞生的比特币！</p>
<h2 id="56-权益证明机制（PoS）是什么"><a href="#56-权益证明机制（PoS）是什么" class="headerlink" title="56.权益证明机制（PoS）是什么"></a>56.权益证明机制（PoS）是什么</h2><p>　　权益证明机制（Proof of Stake），简称POS，也称股权证明机制，类似于把资产存在银行里，银行会通过你持有数字资产的数量和时间给你分配相应的收益。<br>　　同理，采用PoS的数字资产，系统根据你的币龄给你分配相应的权益，币龄是你持币数量和时间的乘积。比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000。<br>　　相较PoW（工作量证明机制），PoS存在2个优势。第一，PoS不会造成过多的电力浪费，因为PoS不需要靠比拼算力挖矿。第二，POS更难进行51%攻击。拥有51%币才能发起攻击，网络受到攻击却会造成自己利益受损，显然很不划算。<br>　　目前，有很多数字资产用PoW发行新币，用PoS维护区块链网络安全。</p>
<h2 id="57-股权授权证明机制（DPoS）是什么"><a href="#57-股权授权证明机制（DPoS）是什么" class="headerlink" title="57.股权授权证明机制（DPoS）是什么"></a>57.股权授权证明机制（DPoS）是什么</h2><p>　　股份授权证明机制，简称DPoS，类似于董事会投票，持币者投出一定数量的节点，代理他们进行验证和记账。为了激励更多人参与竞选，系统会生成少量代币作为奖励。比特股、点点币等数字资产都采用该方式。<br>　　DPoS有点像议会制度或人民代表大会制度。如果代表不能履行他们的职责，比如轮到他们记账时，他们没能完成则会被除名，网络会选出新的节点来取代他们。<br>　　DPoS的每个客户端都有能力决定哪些节点可以被信任。相较PoW（工作量证明机制），DPoS大幅提高区块链处理数据的能力，甚至可以实现秒到账，同时也大幅降低维护区块链网络安全的费用，从而使数字资产的交易速度接近Visa等中心化结算系统。</p>
<h2 id="58-零知识证明是什么"><a href="#58-零知识证明是什么" class="headerlink" title="58.零知识证明是什么"></a>58.零知识证明是什么</h2><p>　　零知识证明是指证明者能够在不向验证者提供信息本身内容的情况下，使验证者相信某个论断是真实可信的一种技术。目前匿名性非常突出的数字资产ZCash的匿名交易就是依靠“零知识证明”实现的。<br>　　举个例子，A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时候，A可以选择把钥匙交给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。<br>　　或者A自己用钥匙打开房间，从房间里拿出来一个物体出示给B，B知道这个物体确实只有房间里有。方法二的原理就是零知识证明。<br>　　零知识证明可以在不泄漏信息本身内容的情况下，证明我知道这个秘密，可以有效解决许多验证问题。</p>
<h2 id="59-哈希算法是什么"><a href="#59-哈希算法是什么" class="headerlink" title="59.哈希算法是什么"></a>59.哈希算法是什么</h2><p>　　哈希算法是一种只能加密，不能解密的密码学算法，可以将任意长度的信息转换成一段固定长度的字符串。<br>　　这段字符串有两个特点：<br>　　1. 就算输入值只改变一点，输出的哈希值也会天差地别。<br>　　2. 只有完全一样的输入值才能得到完全一样的输出值。<br>　　3. 输入值与输出值之间没有规律，所以不能通过输出值算出输入值。要想找到指定的输出值，只能采用枚举法：不断更换输入值，寻找满足条件的输出值。<br>　　哈希算法保证了比特币挖矿不能逆向推导出结果。所以，矿工持续不断地进行运算，本质上是在暴力破解正确的输入值，谁最先找到谁就能获得比特币奖励。</p>
<h2 id="60-非对称加密是什么"><a href="#60-非对称加密是什么" class="headerlink" title="60.非对称加密是什么"></a>60.非对称加密是什么</h2><p>　　对称加密算法是指在加密和解密时使用的是同一个秘钥。与对称加密算法不同，非对称加密算法需要公钥和私钥。公钥和私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。<br>　　非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。<br>　　而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，在通讯前不需要先同步秘钥，避免了在同步私钥过程中被黑客盗取信息的风险。</p>
<h1 id="区块链扩容和分叉的故事"><a href="#区块链扩容和分叉的故事" class="headerlink" title="区块链扩容和分叉的故事"></a>区块链扩容和分叉的故事</h1><h2 id="61-扩容是什么"><a href="#61-扩容是什么" class="headerlink" title="61.扩容是什么"></a>61.扩容是什么</h2><p>　　在比特币诞生之初，比特币的创始人中本聪并没有特意限制区块的大小，区块最大可以达到32MB。<br>　　当时，平均每个区块大小为1-2KB，有人认为区块链上限过高容易造成计算资源的浪费，还容易发生DDOS攻击。因此，为了保证比特币系统的安全和稳定，中本聪决定临时将区块大小限制在1MB。<br>　　那时比特币的用户数量少，交易量也没有那么大，并不会造成区块拥堵。2013年至今，比特币价格直线飙升，用户越来越多，比特币网络拥堵、交易费用上升的问题逐渐涌现出来。<br>　　比特币社区开始探索如何给比特币“扩容”，即通过修改比特币底层代码，从而达到提高交易处理能力的目的。</p>
<h2 id="62-比特币为什么要扩容"><a href="#62-比特币为什么要扩容" class="headerlink" title="62.比特币为什么要扩容"></a>62.比特币为什么要扩容</h2><p>　　目前比特币区块大小为1M，每秒大约只能处理7个交易。随着比特币交易量不断增长，比特币网络已经难以迅速地进行转账交易确认，比特币网络出现拥堵。<br>　　比特币区块链上最高时有上万笔交易积压，比特币转账交易费高达几十美元，网络拥堵时，比特币交易甚至需要花费好几天才能被打包。大家开始讨论如何扩容。<br>　　自2013年起，人们提出了很多关于比特币扩容的方案，有人说要提高区块大小上限、有人说要拿出区块内部分无用信息……但是这些方案都没有获得广泛认可。因此，比特币扩容一直争论不休。<br>　　2017年8月，隔离见证激活，比特币单个区块的信息处理能力提高至以前的1.7倍。隔离见证是Segwit2X扩容方案的第一步。</p>
<h2 id="63-隔离见证是什么"><a href="#63-隔离见证是什么" class="headerlink" title="63.隔离见证是什么"></a>63.隔离见证是什么</h2><p>　　隔离见证是区块链扩容的一种方法，已经在莱特币和比特币上成功实施。<br>　　目前区块链上每个区块内不仅记录了每笔转账交易的具体信息，即在哪个时间点账户收到或转出多少比特币，还包含了每笔交易的数字签名，用来验证该交易的合法性。矿工在打包区块的时候需要用数字签名一一验证每笔交易，确认没有问题之后才会将该笔交易记录在区块里。<br>　　但是对于普通用户来说，他只关心每个账户有多少资产，并不需要一一验证每笔交易。隔离见证就是把区块内的数字签名信息拿出去，让每个区块可以承载更多笔交易，从而达到扩容的目的。</p>
<h2 id="64-区块链分叉是什么"><a href="#64-区块链分叉是什么" class="headerlink" title="64.区块链分叉是什么"></a>64.区块链分叉是什么</h2><p>　　在中心化系统中升级软件十分简单，在应用商店点击“升级”即可。但是在区块链等去中心化系统中，“升级”并不是那么简单，甚至可能一言不合造成区块链分叉。<br>　　简单说，分叉是指区块链在进行“升级”时发生了意见分歧，从而导致区块链分叉。因为没有中心化机构，比特币等数字资产每次代码升级都需要获得比特币社区的一致认可，如果比特币社区无法达成一致，区块链很可能形成分叉。<br>　　以比特币为例，2017年7月，为了解决比特币区块链拥堵问题，一些比特币爱好者提出了bitcoin cash分叉方案，导致比特币区块链一分为二。<br>　　根据分叉后的区块链是否能兼容旧区块链，分叉又分为“硬分叉”和“软分叉”。</p>
<h2 id="65-比特币居然生儿子了"><a href="#65-比特币居然生儿子了" class="headerlink" title="65.比特币居然生儿子了"></a>65.比特币居然生儿子了</h2><p>　　现在比特币社区有很多种扩容方案，如果有某种扩容方案可以获得足够的算力支持，成功激活，那么比特币网络将避免分叉的风险。<br>　　但是，因为比特币没有中心化的权利机构，很难达成共识。如果没有任何一种方案获得足够的算力支持，比特币区块链将形成分叉，届时将会产生多种比特币分叉币。原先持有比特币的人，在分叉后将自动且免费拥有分叉后产生的每种分叉币。因为分叉币都是免费获得的，所以又被称为糖果。<br>　　2017年8月，社区就扩容方案达成共识，激活了隔离见证扩容方案，比特币区块链的处理速度扩大至1.8倍。随后4个月里，比特币相继发生了多次分叉，产生了多个分叉币，很多比特币爱好者戏称比特币”生了很多儿子“。</p>
<h2 id="66-软分叉和硬分叉是什么"><a href="#66-软分叉和硬分叉是什么" class="headerlink" title="66.软分叉和硬分叉是什么"></a>66.软分叉和硬分叉是什么</h2><p>　　硬分叉，是指当比特币代码发生改变后，旧节点拒绝接受由新节点创造的区块。不符合原规则的区块将被忽略，矿工会按照原规则，在他们最后验证的区块之后创建新的区块。<br>　　而软分叉是指旧的节点并不会意识到比特币代码发生改变，并继续接受由新节点创造的区块。矿工们可能会在他们完全没有理解，或者验证过的区块上进行工作。<br>　　软分叉和硬分叉都”向后兼容”，这样才能保证新节点可以从头验证区块链。向后兼容是指新软件接受由旧软件所产生的数据或者代码，比如说Windows 10可以运行Windows XP的应用。而软分叉还可以”向前兼容”。向前兼容是指旧软件可以接受由新软件所产生的数据以及代码，比如你用Word 2013保存的文档，假如仍然可以用Word 2011打开，就是一种“向前兼容”。</p>
<h2 id="67-重放攻击是什么"><a href="#67-重放攻击是什么" class="headerlink" title="67.重放攻击是什么"></a>67.重放攻击是什么</h2><p>　　如果比特币真的发生分叉，作为普通用户，最大的风险就是重放攻击。<br>　　重放攻击是什么呢？如果比特币分裂为一种或多种比特币，如BTC1/BTC2/BTC3等，每个比特币账户内将根据他的比特币余额，同时存在对应数量的所有分叉币。<br>　　由于每条链上的地址和私钥、算法等都相同，交易格式也完全相同，导致在其中一条区块链上发起的交易，完全可以放到另一条区块链上去重新广播，可能也会得到确认。这就是“重放攻击”。<br>　　简单来说，在你转账BTC1的时候，你的BTC2/BTC3也可能同时被转走。<br>　　但是，目前很多分叉币做了双向防重放攻击处理，避免了分叉后被重放攻击的风险。</p>
<h2 id="68-硬分叉的故事–以太经典ETC"><a href="#68-硬分叉的故事–以太经典ETC" class="headerlink" title="68.硬分叉的故事–以太经典ETC"></a>68.硬分叉的故事–以太经典ETC</h2><p>　　以太坊（ETH）和以太经典（ETC）是硬分叉的典型案例。<br>　　The DAO计划基于以太坊智能合约建立一个众筹平台，于2016年5月正式发布，截止当年6月，募集资金超过1.6亿美元。之后，The DAO被黑客利用智能合约的漏洞，转移了市值五千万美元的以太币。为了挽回投资者资产，以太坊社区投票表决决定将更改以太坊代码，希望索回资金。为此，以太坊在第1920000区块进行硬分叉，回滚所有以太币（包括被黑客占有的）。<br>　　但是，有一部分人认为以太坊这种作法违背了区块链的去中心化和不可篡改精神，坚持在原链上挖矿，从而形成两条链，一条为不承认回滚交易的链-以太经典（ETC），一条为承认回滚交易的链即以太坊（ETH），各自代表不同的社区共识以及价值观。分叉时持有以太币的人在分叉后会同时持有ETH和ETC。</p>
<h1 id="区块链项目分类和应用"><a href="#区块链项目分类和应用" class="headerlink" title="区块链项目分类和应用"></a>区块链项目分类和应用</h1><h2 id="69-区块链项目分类和应用"><a href="#69-区块链项目分类和应用" class="headerlink" title="69.区块链项目分类和应用"></a>69.区块链项目分类和应用</h2><p>　　从目前主流的区块链项目来看，区块链项目主要为四类：第一类：币类；第二类：平台类；第三类：应用类；第四类：资产代币化。<br>　　币类主要充当区块链资产领域的“交换媒介”，交换媒介指一般等价物，比如以前的黄金、银票等。<br>　　平台类项目是指建立技术平台，用于满足各种区块链应用开发，可以降低在区块链上开发应用的门槛。<br>　　应用类项目范围比较广泛，涵盖金融、社交、游戏、产权保护等诸多领域，也是目前区块链资产增长最快的领域。<br>　　资产代币化项目是指是实物资产的区块链映射，也就是实物资产上链，目前不超过10个品种。<br>　　下面几期节目，火小币将深入介绍每类区块链项目的典型代表~</p>
<h2 id="70-区块链项目之一–币类"><a href="#70-区块链项目之一–币类" class="headerlink" title="70.区块链项目之一–币类"></a>70.区块链项目之一–币类</h2><p>　　第一类是币类项目，也是最早的区块链项目。币类项目主要包括比特币和莱特币等项目。<br>　　此外，还有一类资产具有匿名的特点，主要功能包括实现支付的同时可以保护支付双方的隐私，比较知名的有达世币（Dash）、门罗币（Monero）及采用零知识证明的大零币（Zcash）等。<br>　　币类主要充当区块链资产领域的“交换媒介”，交换媒介就是你用来换取商品的一般等价物，比如以前黄金、白银、银票可以作为交换媒介。<br>　　目前全球的数字资产种类超过1000个品种，币类区块链项目数量增长不快，截止2018年1月市值最大的依旧是比特币。比特币大家已经很熟悉了，接下来几集火小币将详细介绍一下莱特币、新经币、达世币、门罗币、Zcash。</p>
<h2 id="71-莱特币是什么"><a href="#71-莱特币是什么" class="headerlink" title="71.莱特币是什么"></a>71.莱特币是什么</h2><p>　　莱特币，英文叫Litecoin，简称LTC，诞生于2011年11月9日，创始人是查理·李（Charlie Lee）。<br>　　莱特币的宗旨是改进比特币，所以它和比特币有很多相似之处，在行业中有“比特金，莱特银”的说法。相较比特币，莱特币总量更大一些，确认速度更快一些。<br>　　莱特币总量是比特币的四倍，8400万枚；它的产量减半时间和比特币一样都是4年；它的共识机制和比特币一样都是工作量证明机制（PoW）；它的区块时间是2.5分钟，是比特币的四分之一，每2.5分钟打包一个区块；莱特币的区块奖励最早是50枚莱特币，截止目前（2018年1月）莱特币区块奖励为25莱特币，已发行量约为5400万。</p>
<h2 id="72-达世币Dash是什么"><a href="#72-达世币Dash是什么" class="headerlink" title="72.达世币Dash是什么"></a>72.达世币Dash是什么</h2><p>　　达世币诞生于2014年1月18日，匿名程度较比特币更高。<br>　　达世币有三种转账方式，一是像比特币一样的普通转账；二是即时交易。不需要矿工打包确认，就可以确认交易，几乎可以实现秒到；三是匿名交易。从区块链上看不到是谁和谁进行了转账。<br>　　达世币如何进行匿名交易呢？达世币中除了普通节点之外，还有一种节点叫“主节点”。主节点可以提供一系列服务，如：匿名交易和即时支付。想进行匿名交易的交易者发起匿名申请，由主节点进行混币，一般是3笔交易一起进行混币。举个例子，一桌人把自己的钱都放在桌上，混在一起，然后再分别拿回相应面值的钱，这样就不知道你手里的钱到底是谁的了，这就是混币。混币后，网络就不知道究竟谁转账给了谁。</p>
<h2 id="73-新经币是什么"><a href="#73-新经币是什么" class="headerlink" title="73.新经币是什么"></a>73.新经币是什么</h2><p>　　新经币，简称NEM，诞生于2015年4月1日，是第一个采用测试驱动开发模式开发出来的数字资产。<br>　　什么是测试驱动呢？就是先进行测试，然后再进行编程。举个常用的例子，建筑工人在盖房子的时候，喜欢先锤一根线下来，然后按照这根线去垒砖，就能把墙砌得笔直。如果直接垒砖，后面有可能会把墙砌歪了。测试驱动开发就是仅用通过测试的代码开发。<br>　　新经币采用重要性证明PoI共识机制（配音备注：poi），根据交易量、活跃度等维度决定记账权利，所以它每60秒就能打包一个区块，相较比特币、莱特币快很多。<br>　　它的总量是90亿枚，并且在发布的最初就将所有的新经币发行完成，所以每个新区块不产生新的新经币奖励，区块奖励仅为交易手续费，对于后进者的激励不够。</p>
<h2 id="74-门罗币Monero是什么"><a href="#74-门罗币Monero是什么" class="headerlink" title="74.门罗币Monero是什么"></a>74.门罗币Monero是什么</h2><p>　　门罗币，简称XMR，诞生于2014年4月18日，比达世币晚3个月，它的总量为1844万，目前（2018年1月）已发行1562万。门罗币的区块大小没有限制，所以不存在扩容风险。<br>　　门罗币通过环形签名的方式提供匿名性。环形签名是什么意思呢？在门罗币的区块链网络里面，网络首先将签名者的公钥和另外一个公钥进行一起混合，然后对消息进行签名，使得外界无法区分集合中哪个公钥对应真正的签名者。<br>　　这很像中国古代联名上书的时候，为了不暴露哪一个是发起人，所以通常采用由所有人签名形成一个环状，没有前后顺序，这样就不知道谁是发起者了。门罗币的匿名性甚至可以做到让发送币的人不知道币打给了哪个地址、接受币的人仅打开钱包也不知道是谁打来的币。</p>
<h2 id="75-大零币Zcash是什么"><a href="#75-大零币Zcash是什么" class="headerlink" title="75.大零币Zcash是什么"></a>75.大零币Zcash是什么</h2><p>　　Zcash，全称Zero Cash，简称ZEC，中文叫大零币，研发者为Zooko Wilcox，诞生于2011年11月9日。<br>　　采用零知识证明机制提供完全的支付保密性，是目前匿名性最强的数字资产。零知识证明是什么？请回顾区块链100问第58集。目前Zcash匿名转账的时间周期比较长，大概需要20分钟。网络可以选择普通转账或匿名转账，对隐私保护级别有所影响。<br>　　Zcash的大部分代码与比特币极其相似，例如它每4年减半一次，总量是2100万枚。Zcash进一步完善了比特币匿名功能方面的不足，发行时引起了密码学和区块链界的轰动，导致其刚诞生时价格一度飙升至比特币的7倍以上。Zcash采用PoW共识机制，区块时间为2.5分钟，区块奖励为12.5个ZEC，前4年20%挖矿所得自动分配给Zcash团队和投资者。</p>
<h2 id="76-区块链项目–平台类"><a href="#76-区块链项目–平台类" class="headerlink" title="76.区块链项目–平台类"></a>76.区块链项目–平台类</h2><p>　　区块链项目第二类是平台类。平台类项目主要功能为建立技术平台，满足各种区块链应用开发所需的技术要求。<br>　　简单地说，平台类应用让开发者可以在区块链上直接发行数字资产、编写智能合约等。智能合约就是在区块链数据库上运行的计算机程序，可以在满足其源代码设定条件下自行执行。<br>　　举个例子，你在区块链上开发一个基于房屋租金协议的智能合约，当业主收到租金时就会触发自动执行，并将公寓的安全密钥给到租户。<br>　　平台类区块链项目的主要功能是建立底层的技术平台，让开发者在底层技术平台上做应用开发，相当一部分平台尚处于开发状态当中，截止到2018年1月份，市值最大的是以太坊。</p>
<h2 id="77-以太坊是什么"><a href="#77-以太坊是什么" class="headerlink" title="77.以太坊是什么"></a>77.以太坊是什么</h2><p>　　以太坊是一个可编程、可视化、更易用的区块链，它允许任何人编写智能合约和发行代币。<br>　　就像比特币一样，以太坊是去中心化的，由全网共同记账，账本公开透明且不可窜改。<br>　　与比特币不同的是，以太坊是可编程的区块链，它提供了一套图灵完备的脚本语言，因此，开发人员可以直接用C语言等高级语言编程，转换成汇编语言，大大降低了区块链应用的开发难度。类似于安卓系统，提供了非常丰富的API 和接口，让用户可以开发出各种App。<br>　　从诞生到现在，有200多个以太坊应用诞生，俄罗斯银行也与以太坊基金会达成合作，截止目前（2017年9月）以太坊市值仅次于比特币，排行第2位。</p>
<h2 id="78-EOS是什么"><a href="#78-EOS是什么" class="headerlink" title="78.EOS是什么"></a>78.EOS是什么</h2><p>　　EOS是一个区块链开发平台，具有可扩展性强、支持大规模商业应用等特点。<br>　　首先，EOS采取DPoS共识算法及其他技术手段预期实现每秒百万级别交易请求，将能够支持数千个商业级的DAPPs。<br>　　以太坊是一条公链，在以太坊链上运行的每一个应用都会消耗整条链的资源，但EOS只是区块链基础架构，开发者可以自由地在EOS上创建公链，链与链之间不会影响彼此的资源使用，不会出现因个别应用资源消耗巨大而造成网络大面积拥堵。<br>　　其次，在EOS上转账与运行智能合约并不需要消耗EOS代币，这将吸引更多的用户。<br>　　最后，EOS上出现系统错误时，其“宪法”可用于区分此错误是否确实为bug，判断社区的修复举措是否得当。</p>
<h2 id="79-以太坊是什么"><a href="#79-以太坊是什么" class="headerlink" title="79.以太坊是什么"></a>79.以太坊是什么</h2><p>　　以太坊（Ethereum），简称ETH。2013年底，Vitalik发布以太坊白皮书，2014年7月，开始以太币的预售。那时候圈内人称这种代币发行叫“币众筹”。通过为期42天的预售，以太坊团队通过预售60102216个以太币，募集了3万多个比特币；另外还对预售之前参与开发的早期贡献者、长期从事项目研究的开发者分别按照当时以太币发售总量的9.9%进行分配。所以以太坊正式发行时有 7200多万个以太币。<br>　　以太坊预售结束后，采用工作量证明机制PoW进行挖矿，每年按照当时发行总量的26%奖励矿工。2014年10月，以太坊将区块的出块时间从60秒缩减到了12秒，目前基本稳定在15秒，每个区块奖励5个以太币。<br>　　虽然都是采用PoW挖矿机制，但是以太坊的出块机制和比特币还是有所区别。由于以太坊的出块时间短，导致以太坊很容易形成孤块，孤块是指不在最长链上的区块。比特币的孤块没有任何区块奖励，但是在以太坊中，孤块可以被引用，被引用的孤块被称为“叔块”（uncle block），它们打包的数据也会记录在区块链中。和比特币不一样，以太坊的叔块有奖励，每个叔块最多可以获得4.375个以太币的奖励。<br>　　以太坊是一个可编程的、图灵完备的区块链开发平台，相当于一个去中心化的全球计算机。在一个编程系统之上，通常会有一些编译和执行的虚拟机来去做支撑。JAVA有JVM，在以太坊里，也有以太坊的虚拟机EVM，可以执行任意复杂的算法代码。开发者可以使用现有的JavaScript 或Python等编程语言，在以太坊上创造出自己想要的应用。通过以太坊的虚拟机，你可以很简便地发行数字资产，编写智能合约，建立和运行去中心化的应用，成立去中心化自治组织等。<br>　　以太币（ETH）又被称为以太坊内部的燃料。和币类数字资产不同，以太坊除了用于转账，还用于支付智能合约的费用。<br>　　为了避免以太坊区块链上充斥垃圾合约和垃圾应用，在以太坊上建立和运行智能合约，你必须用ETH支付智能合约费用。举个例子，在以太坊区块链上转账你新创造的数字资产，需要用ETH支付手续费，而不是你新创造的数字资产。</p>
<h2 id="80-区块链项目–应用类"><a href="#80-区块链项目–应用类" class="headerlink" title="80.区块链项目–应用类"></a>80.区块链项目–应用类</h2><p>　　区块链项目第三类是应用类。应用类项目就是基于区块链开发平台（例如以太坊）开发的能够解决实体经济各个领域诸多问题的区块链项目。<br>　　例如基于区块链的预测平台Augur，基于区块链的算力交易平台Golem，基于区块链的奢侈品溯源平台VeChain，基于区块链提供资产兑换及转移服务的OmiseGo。利用区块链技术，这些项目可以更好地解决信任问题、跨国界流通等问题，同时，利用区块链上的智能合约和代币，可以更好地实现自动执行，大大提高社会经济活动的效率。<br>　　应用类区块链项目范围比较广泛，涵盖金融、社交、游戏、产权保护等诸多领域，也是目前区块链项目市值增长最快的领域。</p>
<h2 id="81-Augur是什么"><a href="#81-Augur是什么" class="headerlink" title="81.Augur是什么"></a>81.Augur是什么</h2><p>　　Augur是基于以太坊区块链打造的去中心化预测平台，于2015年6月正式发布，是以太坊上的第一款应用。<br>　　Augur采用了一个叫“群体智慧”的概念，它的意思是，一群人的智慧会高于这群人中最聪明的人。所以，Augur的预测结果往往比较接近事情的真实走向。<br>　　依靠群体智慧来预判事件的发展结果，可以有效地消除对手方风险和服务器的中心化风险。同时，利用区块链全球流通的属性，Augur创建了一个全球性的市场。如何保证每个人都作出理性的预测呢？用户用Augur代币进行预测和下注，如果预测正确，你将获得对手方的筹码，如果预测错误，你将损失下注的成本。</p>
<h2 id="82-Golem是什么"><a href="#82-Golem是什么" class="headerlink" title="82.Golem是什么"></a>82.Golem是什么</h2><p>　　Golem是第一个基于以太坊区块链打造的计算资源交易平台。通过区块链，Golem能链接全球的算力资源，从而实现计算能力的全球共享。应用所有者和个体用户（算力“请求方”）可以点对点地从其他用户处租用算力（算力“供应商”）。<br>　　当前，算力市场垄断严重，他们借助市场优势享受高额利润，进而导致算力价格居高不下。<br>　　去中心化的算力交易平台或许可以显著降低算力价格，但是其发展非常依赖平台参与者的数量。<br>　　Golem代币简称GNT，在使用算力资源时需要支付GNT酬劳给算力供应商、软件开发商。GNT总量为10亿枚，82%的GNT在外面出售和流通，18%的GNT保留在Golem团队手里。</p>
<h2 id="83-区块链项目–资产数字化"><a href="#83-区块链项目–资产数字化" class="headerlink" title="83.区块链项目–资产数字化"></a>83.区块链项目–资产数字化</h2><p>　　第四类是资产代币化区块链项目。资产代币化是指将区块链资产挂钩黄金和美元等实物资产，是实物资产的区块链映射，目前只有不超过10个品种，比较典型的代表是对标美元的USDT，对标黄金的Digix Dao，DigixDAO每个代币代表1克由伦敦金银市场协会认证的黄金。<br>　　资产代币化具有方便交易，便于保管等优势。首先，资产代币化更方便交易。因为区块链资产可以拆分，具有更好地流动性。举个例子，目前房产需要整体转让，如果房产可以代币化，便可以拆分购买，更方便交易。<br>　　其次，实物资产代币化更利于保管。黄金等在实物交易中，很容易形成磨损，造成损失。但是实物资产代币化后并不需要进行实物转移，更利于实物资产的保管。</p>
<h2 id="84-DigixDao是什么"><a href="#84-DigixDao是什么" class="headerlink" title="84.DigixDao是什么"></a>84.DigixDao是什么</h2><p>　　黄金是避险的不二选择。Digix发行的黄金代币则是数字资产世界里的黄金，其代币简称DGX，能够在数字资产世界中起到避险的作用。<br>　　DGX如何实现对标黄金呢？它将黄金资产进行了上链（即：区块链）操作。举个例子，假如你有1公斤黄金准备出售，你可以将黄金切割出售，但这样太麻烦，而且容易形成损耗。<br>　　你也可以将1公斤黄金寄到新加坡，让伦敦金银协会（LBMA) 验证黄金，验证合格后会给你发放黄金资产所有权的证书。<br>　　该数字化证书可以转换为1000枚DGX代币，即1个DGX代币=1克黄金。大大地提高了黄金的流通效率。同理，需要提取黄金时，只要你拥有相应的代币，即可换成证书去提取黄金。</p>
<h2 id="85-Tether是什么"><a href="#85-Tether是什么" class="headerlink" title="85.Tether是什么"></a>85.Tether是什么</h2><p>　　USDT是Tether公司推出的对标美元（USD）的代币Tether USD。1USDT=1美元，用户可以随时使用USDT与USD进行1:1兑换。Tether公司执行1:1准备金保证制度，即每个USDT代币，都会有1美元的准备金保障，对USDT价格的恒定形成支撑。某个数字资产单价是多少USDT，也就相当于是它的单价是多少美元（USD）。<br>　　由于USDT与等量的美元是等值的，因此它是价值比较稳定的数字资产。在市场价格波动剧烈时，用户可以将账户中的区块链资产替换成USDT，达到保值避险的作用。<br>　　用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易平台，比如otc.huobipro.com换取USDT。赎回美元时，反向操作即可。用户也可在交易平台用比特币换取USDT。</p>
<h2 id="86-山寨币和竞争币是什么"><a href="#86-山寨币和竞争币是什么" class="headerlink" title="86.山寨币和竞争币是什么"></a>86.山寨币和竞争币是什么</h2><p>　　山寨币是指以比特币代码为模板，对其底层技术区块链进行了一些修改的区块链资产，其中有技术性创新或改进的又称为竞争币。<br>　　因为比特币代码开源，导致比特币的抄袭成本很低，甚至只需复制比特币的代码，修改一些参数，便可以生成一条全新的区块链。<br>　　目前已存在的山寨币有数百种。大多数山寨币由于创始人技术实力弱、缺少技术维护、缺少市场推广等原因并不被市场认可，不具有投资价值。少数技术实力、创新能力都很强的团队开发的优秀竞争币才能被市场认可，具有投资价值，我们比较熟悉的竞争币有莱特币、以太坊等。</p>
<h2 id="87-区块链能像互联网一样改变世界"><a href="#87-区块链能像互联网一样改变世界" class="headerlink" title="87.区块链能像互联网一样改变世界"></a>87.区块链能像互联网一样改变世界</h2><p>　　互联网是一种去中心化的信息传输体系，区块链是一种去中心化的价值传输体系。两者都被誉为改变时代的伟大技术。<br>　　互联网的主要用途是实现信息的快速发送和接收，在互联网上传输word文档，其实是信息的拷贝，你有一份，别人也有一份。<br>　　区块链用于价值传输，在区块链上传递比特币，本质上是传递所有权，你的比特币变成了别人的比特币。<br>　　区块链上的数据具有高度的防篡改性，经过全网多数节点验证方可使用，一旦记录便无法修改。区块链上的每一次价值传输都被明确记录，且可以溯源。区块链能在各中心间建立信任，有人说区块链能像互联网一样改变世界。</p>
<h2 id="88-区块链有那些缺点"><a href="#88-区块链有那些缺点" class="headerlink" title="88.区块链有那些缺点"></a>88.区块链有那些缺点</h2><p>　　区块链的优势很多，劣势也很明显。<br>　　区块链上的信息公开透明，可以有效地防止黑箱操作等现象。但也意味着如果知道某个人的账户，我就能知道他的所有财富和每一笔交易，没有隐私可言。<br>　　区块链上的信息不可修改，意味着如果你转账信息填错，谁也无法帮你找回损失。<br>　　区块链是去中心化的，节点之间无需中心化机构便可以自证其信，但也意味着每个人都需有一本完整的账本，随着时间推进，账本越来越大，普通计算机可能难以运行。同时，去中心化意味着没有中心化机构替你保存密钥，一旦丢失便永远无法找回。<br>　　去中心化网络网络在各个节点之间达成一致的效率很低，很难像中心化支付方式那样快速。</p>
<h2 id="89-区块链适合应用于哪些领域"><a href="#89-区块链适合应用于哪些领域" class="headerlink" title="89.区块链适合应用于哪些领域"></a>89.区块链适合应用于哪些领域</h2><p>　　区块链是去中心化的价值传输体系，具有信息公开透明、不可篡改、全球联通且交易成本低等特点。适合运用于暂时无信任中心、解决信任的成本非常高、跨中心间价值传输等领域。目前，区块链的应用领域广泛。<br>　　档案管理、专利保护等社会管理领域，物品溯源、防伪等物联网领域，慈善捐款等公益领域均运用了区块链上信息公开透明且不可篡改的特点；<br>　　交易清算结算、私募等金融服务领域运用了区块链低交易成本的特点；<br>　　社交、通讯领域，共享租赁等共享经济领域运用了区块链全球联通的特点。<br>　　区块链的应用前景巨大，将彻底革新现有价值传输体系。</p>
<h2 id="90-目前区块链联盟盘点"><a href="#90-目前区块链联盟盘点" class="headerlink" title="90.目前区块链联盟盘点"></a>90.目前区块链联盟盘点</h2><p>　　在区块链行业发展早期阶段，很多企业、机构等组成区块链联盟，共享区块链技术研究成果，寻求区块链技术更广泛的应用。<br>　　近两年，区块链联盟涌现，截止2017年7月，目前已有由约40多家国际银行组成的R3、由Linux基金会发起的超级账本（hyperledger）、位于中国互联网核心腹地的中关村区块链产业联盟、由11家机构共同发起的China Ledger联盟、由25家金融机构联合成立的金链盟、被称为“俄罗斯版R3”的俄罗斯区块链联盟、寻求与微金融结合点的区块链微金融产业联盟、由深圳前海管理局主导的前海国际区块链生态圈联盟、位于陆家嘴的陆家嘴区块链金融发展联盟。<br>　　众人拾柴火焰高，众多机构和人才加入推动区块链的蓬勃发展。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://tech.sina.com.cn/zt_d/blockchain_100/" target="_blank" rel="external">http://tech.sina.com.cn/zt_d/blockchain_100/</a></p>
]]></content>
    
    <summary type="html">
    
      区块链基础100问，让你变身区块链达人
    
    </summary>
    
      <category term="区块链" scheme="http://yoursite.com/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- 事件响应流程</title>
    <link href="http://yoursite.com/2018/04/16/open-source-weex-android-event-reponse/"/>
    <id>http://yoursite.com/2018/04/16/open-source-weex-android-event-reponse/</id>
    <published>2018-04-16T02:00:00.000Z</published>
    <updated>2018-06-12T10:58:52.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">├── WXComponent.addEvents()</div><div class="line">    ├── WXComponent.addEvent(String type)</div><div class="line">        ├── WXComponent.addClickListener()</div><div class="line">        ├── WXComponent.addFocusChangeListener()</div><div class="line">    ├── WXComponent.setActiveTouchListener()</div></pre></td></tr></table></figure>
<h3 id="响应流程"><a href="#响应流程" class="headerlink" title="响应流程"></a>响应流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">├── WXComponent.addClickListener</div><div class="line">    ├── onClick()</div><div class="line">        ├── WXComponent.OnClickListener.onHostViewClick()</div><div class="line">            ├── WXComponent.fireEvent()</div><div class="line">                ├── WXSDKInstance.fireEvent()</div><div class="line">                    ├── WXBridgeManager.fireEventOnNode()</div><div class="line">                        ├── WXBridgeManager.addJSEventTask()</div><div class="line">                        ├── WXBridgeManager.sendMessage(WXJSBridgeMsgType.CALL_JS_BATCH)</div><div class="line">                        ----------------------------------------------------------------</div><div class="line">                        ├── WXBridgeManager.handleMessage(WXJSBridgeMsgType.CALL_JS_BATCH)</div><div class="line">                            ├── WXBridgeManager.invokeCallJSBatch()</div><div class="line">                                ├── WXJsonUtils.wsonWXJSObject(tasks)</div><div class="line">                                ├── WXBridgeManager.invokeExecJS()</div><div class="line">                                    ├── WXBridge.execJS()</div></pre></td></tr></table></figure>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="注册流程-1"><a href="#注册流程-1" class="headerlink" title="注册流程"></a>注册流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private void addEvents() &#123;</div><div class="line">  int count = mDomObj.getEvents().size();</div><div class="line">  for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">    addEvent(mDomObj.getEvents().get(i));</div><div class="line">  &#125;</div><div class="line">  setActiveTouchListener();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addEvents()</code> 会获取 <code>mDomObj</code> 中的所有事件，然后根据每个时间的名称在 <code>addEvent()</code> 方法中为每一个事件注册监听器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void addEvent(String type) &#123;</div><div class="line">  if (TextUtils.isEmpty(type)</div><div class="line">          || mAppendEvents.contains(type)</div><div class="line">          || getRealView() == null) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  mAppendEvents.add(type);</div><div class="line"></div><div class="line">  View view = getRealView();</div><div class="line">  if (type.equals(Constants.Event.CLICK) &amp;&amp; view != null) &#123;</div><div class="line">    addClickListener(mClickEventListener);</div><div class="line">  &#125; else if ((type.equals( Constants.Event.FOCUS) || type.equals( Constants.Event.BLUR)) ) &#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="响应流程-1"><a href="#响应流程-1" class="headerlink" title="响应流程"></a>响应流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void onHostViewClick() &#123;</div><div class="line">  Map&lt;String, Object&gt; param= WXDataStructureUtil.newHashMapWithExpectedSize(1);</div><div class="line">  Map&lt;String, Object&gt; position = WXDataStructureUtil.newHashMapWithExpectedSize(4);</div><div class="line">  int[] location = new int[2];</div><div class="line">  mHost.getLocationOnScreen(location);</div><div class="line">  position.put(&quot;x&quot;, WXViewUtils.getWebPxByWidth(location[0],mInstance.getInstanceViewPortWidth()));</div><div class="line">  position.put(&quot;y&quot;, WXViewUtils.getWebPxByWidth(location[1],mInstance.getInstanceViewPortWidth()));</div><div class="line">  position.put(&quot;width&quot;, WXViewUtils.getWebPxByWidth(mDomObj.getLayoutWidth(),mInstance.getInstanceViewPortWidth()));</div><div class="line">  position.put(&quot;height&quot;, WXViewUtils.getWebPxByWidth(mDomObj.getLayoutHeight(),mInstance.getInstanceViewPortWidth()));</div><div class="line">  param.put(Constants.Name.POSITION, position);</div><div class="line">  fireEvent(Constants.Event.CLICK,param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>WXComponent.onHostViewClick()</code> 方法中会把当前 <code>View</code> 的 location 和宽高作为参数传递给 <code>fireEvent</code> 方法。</p>
<p>来看一下 <code>WXBridgeManager.fireEventOnNode()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public void fireEventOnNode(final String instanceId, final String ref,</div><div class="line">                            final String type, final Map&lt;String, Object&gt; data,</div><div class="line">                            final Map&lt;String, Object&gt; domChanges, List&lt;Object&gt; params,  EventResult callback) &#123;</div><div class="line">  if (TextUtils.isEmpty(instanceId) || TextUtils.isEmpty(ref)</div><div class="line">      || TextUtils.isEmpty(type) || mJSHandler == null) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  if (!checkMainThread()) &#123;</div><div class="line">    throw new WXRuntimeException(</div><div class="line">        &quot;fireEvent must be called by main thread&quot;);</div><div class="line">  &#125;</div><div class="line">  // 这里会根据是否注册回调函数分两种不同情况来执行</div><div class="line">  if(callback == null) &#123;</div><div class="line">    // 没有注册回调，添加fireEvent事件到待执行的JSEventTask列表，并向 mJSHandler 发送 CALL_JS_BATCH 消息</div><div class="line">    addJSEventTask(METHOD_FIRE_EVENT, instanceId, params, ref, type, data, domChanges);</div><div class="line">    sendMessage(instanceId, WXJSBridgeMsgType.CALL_JS_BATCH);</div><div class="line">  &#125;else&#123;</div><div class="line">    // 注册了回调函数，则在 JS 线程立即执行，并执行回调函数。</div><div class="line">    asyncCallJSEventWithResult(callback, METHD_FIRE_EVENT_SYNC, instanceId, params, ref, type, data, domChanges);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里 <code>onClick</code> 事件并没有注册回调函数，因此会向 <code>mJSHandler</code> 发送 <code>CALL_JS_BATCH</code> 消息。<br>后面执行的 <code>invokeCallJSBatch</code> 和前面博客 <a href="http://www.heqiangfly.com/2018/04/10/open-source-weex-android-module-register-callback/" target="_blank" rel="external">Module 注册、调用和回调函数的执行流程</a> 执行流程是一样的，这里不在介绍。<br>这里 <code>WXBridge.execJS</code> 执行的参数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&#123;&quot;args&quot;:[&quot;11&quot;,&quot;click&quot;,&#123;&quot;position&quot;:&#123;&quot;height&quot;:19.791666,&quot;width&quot;:106.25,&quot;x&quot;:321.875,&quot;y&quot;:1315.625&#125;&#125;,null],&quot;method&quot;:&quot;fireEvent&quot;&#125;]</div></pre></td></tr></table></figure>
<p>把参数传递给前端后会根据 instanceId 和当前元素的 Id 执行对应的方法。</p>
]]></content>
    
    <summary type="html">
    
      介绍 Weex 事件响应流程
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- Module 注册、调用和回调函数的执行流程</title>
    <link href="http://yoursite.com/2018/04/10/open-source-weex-android-module-register-callback/"/>
    <id>http://yoursite.com/2018/04/10/open-source-weex-android-module-register-callback/</id>
    <published>2018-04-10T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册-Module"><a href="#注册-Module" class="headerlink" title="注册 Module"></a>注册 Module</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── WXSDKEngine.registerModule()</div><div class="line">    └── WXModuleManager.registerModule()</div><div class="line">        ├── WXModuleManager.registerNativeModule()</div><div class="line">        └── WXModuleManager.WXSDKManager.getInstance().registerModules()</div><div class="line">            └── WXBridgeManager.registerModules()</div><div class="line">                 └── WXBridgeManager.invokeRegisterModules()</div><div class="line">                     └── WXBridge.execJS()</div></pre></td></tr></table></figure>
<p>注册 Module 的流程和注册 Component 流程比较类似。<br><code>registerModule()</code> 也有多个重载方法，但最终调用的是 <code>WXModuleManager.registerModule()</code> 方法。<br>在介绍 <code>WXModuleManager.registerModule()</code> 方法之前，我们先看一下它的参数之一 <code>ModuleFactory</code>。这个类和注册 Component 时的 ComponentHolder 类比较类似。<br>一般情况下，我们会调用 <code>registerModule(String moduleName, Class&lt;T&gt; moduleClass,boolean global)</code> 方法来注册 Module，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">registerModule(&quot;modal&quot;, WXModalUIModule.class, false);</div></pre></td></tr></table></figure>
<p>WXSDKEngine.registerModule(String moduleName, Class<t> moduleClass,boolean global)</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends WXModule&gt; boolean registerModule(String moduleName, Class&lt;T&gt; moduleClass,boolean global) throws WXException &#123;</div><div class="line">  return moduleClass != null &amp;&amp; registerModule(moduleName, new TypeModuleFactory&lt;&gt;(moduleClass), global);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候会以 <code>WXModalUIModule.class</code> 为参数生成一个 <code>TypeModuleFactory</code> 实例。它有三个作用分别对应三个方法：</p>
<ul>
<li>buildInstance()：生成一个 Module 对应 class 的实例</li>
<li>getMethods()：获取 class 所有的 JSMethod 注解的方法 </li>
<li>getMethodInvoker(String name)：获取注册 Module 提供的API的执行体</li>
<li>generateMethodMap()：解析该模块中的所有方法，并为它生成一个方法的执行体 <code>MethodInvoker</code></li>
</ul>
<p>先来看一下 <code>TypeModuleFactory.generateMethodMap()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">private void generateMethodMap() &#123;</div><div class="line">  if(WXEnvironment.isApkDebugable()) &#123;</div><div class="line">    WXLogUtils.d(TAG, &quot;extractMethodNames:&quot; + mClazz.getSimpleName());</div><div class="line">  &#125;</div><div class="line">  HashMap&lt;String, Invoker&gt; methodMap = new HashMap&lt;&gt;();</div><div class="line">  try &#123;</div><div class="line">    for (Method method : mClazz.getMethods()) &#123;</div><div class="line">      // 获取该方法的所有注解</div><div class="line">      for (Annotation anno : method.getDeclaredAnnotations()) &#123;</div><div class="line">        if (anno != null) &#123;</div><div class="line">          if(anno instanceof JSMethod) &#123;</div><div class="line">            JSMethod methodAnnotation = (JSMethod) anno;</div><div class="line">            String name = JSMethod.NOT_SET.equals(methodAnnotation.alias())? method.getName():methodAnnotation.alias();</div><div class="line">            // 生成MethodInvoker实例，methodAnnotation.uiThread() 是@JSMethod(uiThread = true)注解的uiThread参数，</div><div class="line">            // 方法执行时会根据不同的uiThread参数在不同的线程执行</div><div class="line">            methodMap.put(name, new MethodInvoker(method, methodAnnotation.uiThread()));</div><div class="line">            break;</div><div class="line">          &#125;else if(anno instanceof WXModuleAnno) &#123;</div><div class="line">            WXModuleAnno methodAnnotation = (WXModuleAnno)anno;</div><div class="line">            methodMap.put(method.getName(), new MethodInvoker(method,methodAnnotation.runOnUIThread()));</div><div class="line">            break;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; catch (Throwable e) &#123;</div><div class="line">    WXLogUtils.e(&quot;[WXModuleManager] extractMethodNames:&quot;, e);</div><div class="line">  &#125;</div><div class="line">  // 生成所有方法的 Map</div><div class="line">  mMethodMap = methodMap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WXModuleManager.registerModule() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public static boolean registerModule(final String moduleName, final ModuleFactory factory, final boolean global) throws WXException &#123;</div><div class="line">  ...</div><div class="line">  // 在JS线程中执行注册任务</div><div class="line">  WXBridgeManager.getInstance()</div><div class="line">      .post(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      ...</div><div class="line">      // 如果这个Module是全局的，则直接生成该Module对象，然后存储在 sGlobalModuleMap 中，那么就可以通过 WXModuleManager.findModule() 方法直接调用 Module 的方法。</div><div class="line">      if (global) &#123;</div><div class="line">        try &#123;</div><div class="line">          WXModule wxModule = factory.buildInstance();</div><div class="line">          wxModule.setModuleName(moduleName);</div><div class="line">          sGlobalModuleMap.put(moduleName, wxModule);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">          WXLogUtils.e(moduleName + &quot; class must have a default constructor without params. &quot;, e);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // 在 Java 层注册 Module</div><div class="line">      try &#123;</div><div class="line">        registerNativeModule(moduleName, factory);</div><div class="line">      &#125; catch (WXException e) &#123;</div><div class="line">        WXLogUtils.e(&quot;&quot;, e);</div><div class="line">      &#125;</div><div class="line">      // 在 JS 层注册 Module</div><div class="line">      registerJSModule(moduleName, factory);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return true;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Native 层的注册过程很简单，在 <code>sModuleFactoryMap</code> 中保存了 Module 的 Name 及对应的 <code>ModuleFactory</code>，提供给 <code>callModuleMethod()</code> 方法调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static boolean registerNativeModule(String moduleName, ModuleFactory factory) throws WXException &#123;</div><div class="line">    if (factory == null) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">      sModuleFactoryMap.put(moduleName, factory);</div><div class="line">    &#125;catch (ArrayStoreException e)&#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>JS 层的注册也比较简单，调用 <code>WXBridge.execJS()</code> 注册。<br>WXBridgeManager.invokeRegisterModules()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void invokeRegisterModules(Map&lt;String, Object&gt; modules, List&lt;Map&lt;String, Object&gt;&gt; failReceiver) &#123;</div><div class="line">  ...</div><div class="line">  // 生成参数：&#123;&quot;modal&quot;:[&quot;confirm&quot;,&quot;removeAllEventListeners&quot;,&quot;toast&quot;,&quot;prompt&quot;,&quot;alert&quot;,&quot;addEventListener&quot;]&#125;</div><div class="line">  WXJSObject[] args = &#123;new WXJSObject(WXJSObject.JSON,</div><div class="line">      WXJsonUtils.fromObjectToJSONString(modules))&#125;;</div><div class="line">  try &#123;</div><div class="line">  // 通过jni运行js方法</div><div class="line">    mWXBridge.execJS(&quot;&quot;, null, METHOD_REGISTER_MODULES, args);</div><div class="line">  &#125; catch (Throwable e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Module-方法调用流程"><a href="#Module-方法调用流程" class="headerlink" title="Module 方法调用流程"></a>Module 方法调用流程</h2><h3 id="方法执行流程图"><a href="#方法执行流程图" class="headerlink" title="方法执行流程图"></a>方法执行流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">├── WXBridge.callNativeModule</div><div class="line">    ├── WXModuleManager.callModuleMethod</div><div class="line">        ├── WXModuleManager.findModule</div><div class="line">        ├── TypeModuleFactory.getMethodInvoker</div><div class="line">        ├── WXModuleManager.dispatchCallModuleMethod</div><div class="line">            ├── NativeInvokeHelper.invoke</div><div class="line">                ├── NativeInvokeHelper.prepareArguments</div><div class="line">                ├── MethodInvoker.isRunOnUIThread()</div></pre></td></tr></table></figure>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public Object invoke(final Object target,final Invoker invoker,JSONArray args) throws Exception &#123;</div><div class="line">  // 解析执行方法的参数</div><div class="line">  final Object[] params = prepareArguments(</div><div class="line">      invoker.getParameterTypes(),</div><div class="line">      args);</div><div class="line">  // 如果设置@JSMethod(uiThread = true)，那么在UI线程执行，返回值为null。</div><div class="line">  if (invoker.isRunOnUIThread()) &#123;</div><div class="line">    WXSDKManager.getInstance().postOnUiThread(new Runnable() &#123;</div><div class="line">      @Override</div><div class="line">      public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">          // 在UI线程执行方法</div><div class="line">          invoker.invoke(target, params);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">          throw new RuntimeException(target + &quot;Invoker &quot; + invoker.toString() ,e);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;, 0);</div><div class="line">  &#125; else &#123;</div><div class="line">    //设置@JSMethod(uiThread = false)的话走到这里</div><div class="line">    return invoker.invoke(target, params);</div><div class="line">  &#125;</div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法我们可以看出，如果模块的自定义方法需要返回值，那么就只能设置 <code>@JSMethod(uiThread = false)</code>。相当于同步方法。</p>
<p>解析参数：<br><code>paramClazzs</code> 是模块中定义的方法的参数类型数组，<code>args</code> 是JS传递过来的参数数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">private Object[] prepareArguments(Type[] paramClazzs, JSONArray args) throws Exception &#123;</div><div class="line">  Object[] params = new Object[paramClazzs.length];</div><div class="line">  Object value;</div><div class="line">  Type paramClazz;</div><div class="line">  // 遍历参数</div><div class="line">  for (int i = 0; i &lt; paramClazzs.length; i++) &#123;</div><div class="line">    paramClazz = paramClazzs[i];</div><div class="line">    // 确保args中的参数在模块方法定义的范围之内。</div><div class="line">    if(i&gt;=args.size())&#123;</div><div class="line">      if(!paramClazz.getClass().isPrimitive()) &#123;</div><div class="line">        params[i] = null;</div><div class="line">        continue;</div><div class="line">      &#125;else &#123;</div><div class="line">        throw new Exception(&quot;[prepareArguments] method argument list not match.&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    //  从数组中获取单个参数，并放入params数组</div><div class="line">    value = args.get(i);</div><div class="line">    if (paramClazz == JSONObject.class) &#123;</div><div class="line">      // 如果是 JSONObject 类型</div><div class="line">      if(value instanceof  JSONObject || value == null) &#123;</div><div class="line">        params[i] = value;</div><div class="line">      &#125;else if (value instanceof String)&#123;</div><div class="line">        params[i] = JSON.parseObject(value.toString());</div><div class="line">      &#125;</div><div class="line">    &#125; else if(JSCallback.class == paramClazz)&#123;</div><div class="line">      // 如果是 callback类型参数，这里的 value 其实是JS定义的callbackID。</div><div class="line">      if(value instanceof String)&#123;</div><div class="line">        // 根据sdkInstanceId和 callbackId 创建一个 SimpleJSCallback 实例对象</div><div class="line">        params[i] = new SimpleJSCallback(mInstanceId,(String)value);</div><div class="line">      &#125;else&#123;</div><div class="line">        throw new Exception(&quot;Parameter type not match.&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">      params[i] = WXReflectionUtils.parseArgument(paramClazz,value);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return params;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="callback执行流程"><a href="#callback执行流程" class="headerlink" title="callback执行流程"></a>callback执行流程</h2><p>为了测试 callback 的执行流程，我们自定义了下面模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public class MyModule extends WXModule &#123;</div><div class="line">  @JSMethod(uiThread = true)</div><div class="line">  public void testCallback(JSONObject options, JSCallback callback1, JSCallback callback2) &#123;</div><div class="line">    Log.e(&quot;Test&quot;,&quot;testCallback = &quot;+options.toString());</div><div class="line">    if(callback1 != null) &#123;</div><div class="line">      callback1.invoke(new Data(&quot;success&quot;,&quot;paraSuccess1&quot;,&quot;paraSuccess2&quot;));</div><div class="line">    &#125;</div><div class="line">    if(callback2 !=null)&#123;</div><div class="line">      callback2.invoke(&quot;Test2&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static class Data&#123;</div><div class="line">    public String method;</div><div class="line">    public Object paras;</div><div class="line">    public Data(String method, Object... objArr)&#123;</div><div class="line">      this.method = method;</div><div class="line">      this.paras = objArr;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用该模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">weex.requireModule(&apos;myModule&apos;).testCallback(&#123;</div><div class="line">  type:&quot;test&quot;, </div><div class="line">  data:2</div><div class="line">  &#125;,</div><div class="line">  function (e) &#123;</div><div class="line">    console.log(&quot;callback1&quot;);</div><div class="line">  &#125;,</div><div class="line">  function (e) &#123;</div><div class="line">    console.log(&quot;callback2&quot;);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>下面来看一下 callback1 的调用流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">├── SimpleJSCallback.invoke()</div><div class="line">    ├── WXBridgeManager.callbackJavascript</div><div class="line">        ├── WXBridgeManager.addJSTask()</div><div class="line">            ├── WXBridgeManager.addJSTask()</div><div class="line">                ├── WXBridgeManager.addJSEventTask()</div><div class="line">        ├── sendMessage(WXJSBridgeMsgType.CALL_JS_BATCH)</div><div class="line">        -------------------------------------------------</div><div class="line">        ├── WXBridgeManager.handleMessage(WXJSBridgeMsgType.CALL_JS_BATCH)</div><div class="line">            ├── WXBridgeManager.invokeCallJSBatch</div><div class="line">                ├── WXJsonUtils.wsonWXJSObject(tasks)</div><div class="line">                ├── WXBridgeManager.invokeExecJS</div><div class="line">                    ├── WXBridge.execJS</div></pre></td></tr></table></figure>
<p>在 <code>callbackJavascript()</code> 方法中，先通过 <code>addJSTask()</code> 方法在JS线程把执行回调函数的任务放到 <code>mNextTickTasks</code> 中，等待下次执行 <code>invokeCallJSBatch()</code> 时执行该任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void callbackJavascript(final String instanceId, final String callback,</div><div class="line">                        final Object data, boolean keepAlive) &#123;</div><div class="line">  if (TextUtils.isEmpty(instanceId) || TextUtils.isEmpty(callback)</div><div class="line">      || mJSHandler == null) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  // 在JS线程把callback加入到执行队列中</div><div class="line">  addJSTask(METHOD_CALLBACK, instanceId, callback, data, keepAlive);</div><div class="line">  // 发送 CALL_JS_BATCH，执行一次批处理任务</div><div class="line">  sendMessage(instanceId, WXJSBridgeMsgType.CALL_JS_BATCH);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">private void addJSEventTask(final String method, final String instanceId, final List&lt;Object&gt; params, final Object... args) &#123;</div><div class="line">  post(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      if (args == null || args.length == 0) &#123;</div><div class="line">        return;</div><div class="line">      &#125;</div><div class="line">      // 把参数放到参数列表中，包括回调函数传递的 callbackid，回调参数（data 参数），keepAlive参数</div><div class="line">      ArrayList&lt;Object&gt; argsList = new ArrayList&lt;&gt;();</div><div class="line">      for (Object arg : args) &#123;</div><div class="line">        argsList.add(arg);</div><div class="line">      &#125;</div><div class="line">      if (params != null) &#123;</div><div class="line">        ArrayMap map = new ArrayMap(4);</div><div class="line">        map.put(KEY_PARAMS, params);</div><div class="line">        argsList.add(map);</div><div class="line">      &#125;</div><div class="line">      // 把要执行的方法类型和参数列表放到 map 中。</div><div class="line">      WXHashMap&lt;String, Object&gt; task = new WXHashMap&lt;&gt;();</div><div class="line">      task.put(KEY_METHOD, method);</div><div class="line">      task.put(KEY_ARGS, argsList);</div><div class="line"></div><div class="line">      // 把该callback放到和instanceId对应的列表中，等待下次批处理执行。</div><div class="line">      if (mNextTickTasks.get(instanceId) == null) &#123;</div><div class="line">        ArrayList&lt;WXHashMap&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        list.add(task);</div><div class="line">        mNextTickTasks.put(instanceId, list);</div><div class="line">      &#125; else &#123;</div><div class="line">        mNextTickTasks.get(instanceId).add(task);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">private void invokeCallJSBatch(Message message) &#123;</div><div class="line">  // 如果待执行队列中没有任务或者是未初始化framework则退出</div><div class="line">  if (mNextTickTasks.isEmpty() || !isJSFrameworkInit()) &#123;</div><div class="line">    if (!isJSFrameworkInit()) &#123;</div><div class="line">      WXLogUtils.e(&quot;[WXBridgeManager] invokeCallJSBatch: framework.js uninitialized!!  message:&quot; + message.toString());</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  try &#123;</div><div class="line">    Object instanceId = message.obj;</div><div class="line">    // 轮询队列中的所有instance，看对应是否有待执行任务</div><div class="line">    ArrayList&lt;WXHashMap&lt;String, Object&gt;&gt; task = null;</div><div class="line">    Stack&lt;String&gt; instanceStack = mNextTickTasks.getInstanceStack();</div><div class="line">    int size = instanceStack.size();</div><div class="line">    for (int i = size - 1; i &gt;= 0; i--) &#123;</div><div class="line">      instanceId = instanceStack.get(i);</div><div class="line">      task = mNextTickTasks.remove(instanceId);</div><div class="line">      // 发现待执行任务则退出轮询流程</div><div class="line">      if (task != null &amp;&amp; !((ArrayList) task).isEmpty()) &#123;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    Object[] tasks = ((ArrayList) task).toArray();</div><div class="line">    // 解析参数：</div><div class="line">    WXJSObject[] args = &#123;</div><div class="line">        new WXJSObject(WXJSObject.String, instanceId),</div><div class="line">        WXJsonUtils.wsonWXJSObject(tasks)&#125;;</div><div class="line">    // 执行方法</div><div class="line">    invokeExecJS(String.valueOf(instanceId), null, METHOD_CALL_JS, args);</div><div class="line">    task.clear();</div><div class="line">    for(int i=0; i&lt;tasks.length; i++)&#123;</div><div class="line">      args[i] = null;</div><div class="line">    &#125;</div><div class="line">    args = null;</div><div class="line">  &#125; catch (Throwable e) &#123;</div><div class="line">    WXLogUtils.e(&quot;WXBridgeManager&quot;, e);</div><div class="line">    String err = &quot;invokeCallJSBatch#&quot; + WXLogUtils.getStackTrace(e);</div><div class="line"> WXExceptionUtils.commitCriticalExceptionRT(null, WXErrorCode.WX_ERR_JS_FRAMEWORK.getErrorCode(),</div><div class="line">	  &quot;invokeCallJSBatch&quot;, err, null);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 如果还有待执行任务，则继续发CALL_JS_BATCH消息执行</div><div class="line">  if (!mNextTickTasks.isEmpty()) &#123;</div><div class="line">    mJSHandler.sendEmptyMessage(WXJSBridgeMsgType.CALL_JS_BATCH);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析参数：<br>WXJsonUtils.wsonWXJSObject(tasks)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static final WXJSObject wsonWXJSObject(Object tasks)&#123;</div><div class="line">  //CompatibleUtils.checkDiff(tasks);</div><div class="line">  if(USE_WSON) &#123;</div><div class="line">    return new WXJSObject(WXJSObject.WSON, Wson.toWson(tasks));</div><div class="line">  &#125;else&#123;</div><div class="line">    return new WXJSObject(WXJSObject.JSON, WXJsonUtils.fromObjectToJSONString(tasks));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用 <code>JSON.toJSONString(obj)</code> 方法把对象解析为 json 数据。<br>解析成 <code>WXJSObject</code> 类型的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&#123;&quot;args&quot;:[&quot;1&quot;,&#123;&quot;method&quot;:&quot;success&quot;,&quot;paras&quot;:[&quot;paraSuccess1&quot;,&quot;paraSuccess2&quot;]&#125;,false],&quot;method&quot;:&quot;callback&quot;&#125;]</div></pre></td></tr></table></figure></p>
<!-- 
http://weex.apache.org/cn/wiki/module-introduction.html
-->
]]></content>
    
    <summary type="html">
    
      介绍 Weex Module 注册、调用流程以及回调函数的执行流程
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- 渲染过程</title>
    <link href="http://yoursite.com/2018/03/26/open-source-weex-android-component-render/"/>
    <id>http://yoursite.com/2018/03/26/open-source-weex-android-component-render/</id>
    <published>2018-03-26T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>先来看一下网上有开发者绘制的渲染流程图。</p>
<p><img src="/images/open-source-weex-android-component-render/render_process.png" alt="效果图"></p>
<p>这里目前的版本和这张图相比已经有了改变，比如 <code>WXDomStatement</code> -&gt; <code>DOMActionContextImpl</code>，<code>WXRenderStatement</code> -&gt; <code>RenderActionContextImpl</code>。<br>渲染的流程包括：</p>
<ol>
<li>通过 transformer 将 .we 文件转为 Js Bundle</li>
<li>JS framework 根据 Js Bundle 生成 Virtual Dom </li>
<li>通过 JS 引擎把渲染数据传给 Native 端</li>
<li>Native 端执行渲染工作，首次渲染时，会将所有结点都交给 Native Render 渲染，在 UI 更新时，计算出最小 dif，让 Native 仅渲染发生改变的结点。</li>
</ol>
<p>本文着重介绍2-4步骤的渲染工作。</p>
<h2 id="渲染流程图"><a href="#渲染流程图" class="headerlink" title="渲染流程图"></a>渲染流程图</h2><p>这个过程我们从 Demo 中的 <code>WXSDKInstance.render()</code> 说起，到 <code>IWXRenderListener.onViewCreated()</code> 回调调用结束。<br>在渲染执行之前，先注册了渲染监听器，渲染监听器，当渲染结束时，把生成的 <code>RenderContainer</code> 返回。<br>看一下流程图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">├── WXSDKInstance.registerRenderListener()</div><div class="line">└── WXSDKInstance.render()</div><div class="line">    └── WXSDKInstance.renderInternal()</div><div class="line">        └── WXSDKManager.createInstance()</div><div class="line">            ├── WXRenderManager.registerInstance()</div><div class="line">            └── WXBridgeManager.createInstance()</div><div class="line">                ├── WXModuleManager.createDomModule()</div><div class="line">                └── WXBridgeManager.invokeCreateInstance()</div><div class="line">                    ├── WXSDKInstance.setTemplate()</div><div class="line">                    └── invokeExecJS()</div><div class="line">                        └── WXBridge.execJS()</div><div class="line">                        ---------JS Engine----------</div><div class="line">                            └── WXBridge.callNative()</div><div class="line">                                └── WXBridgeManager.callNative()</div><div class="line">                                    ├── WXBridgeManager.getDomModule()</div><div class="line">                                    └── WXDomModule.callDomMethod()</div><div class="line">                                        └── WXDomModule.callDomMethod</div><div class="line">                                            └── WXDomModule.postAction()</div><div class="line">                                                └── WXDomManager.postAction()</div><div class="line">                                                    ├── WXDomManager.sendMessageDelayed()</div><div class="line">                                                ----------------------------</div><div class="line">                                                    └── WXDomHandler.handleMessage()</div><div class="line">                                                        ├── WXDomManager.executeAction()</div><div class="line">                                                            ├── CreateBodyAction.executeDom()</div><div class="line">                                                                └── AbstractAddElementAction.addDomInternal()</div><div class="line">                                                                    ├── WXDomObject.parse()</div><div class="line">                                                                    ├── AbstractAddElementAction.appendDomToTree()</div><div class="line">                                                                    ├── AbstractAddElementAction.createComponent()</div><div class="line">                                                                        ├── AbstractAddElementAction.generateComponentTree()</div><div class="line">                                                                            ├── WXComponentFactory.newInstance()</div><div class="line">                                                                            └── DOMActionContextImpl.registerComponent()</div><div class="line">                                                                                └── WXRenderManager.registerComponent()</div><div class="line">                                                                                    └── RenderActionContextImpl.registerComponent()</div><div class="line">                                                                    └── DOMActionContextImpl.postRenderTask(CreateBodyAction)</div><div class="line">                                                            ****************************</div><div class="line">                                                            ├── AddElementAction.executeDom()</div><div class="line">                                                                └── AbstractAddElementAction.addDomInternal()</div><div class="line">                                                                    ├── WXDomObject.parse()</div><div class="line">                                                                    ├── AbstractAddElementAction.appendDomToTree()</div><div class="line">                                                                    ├── AbstractAddElementAction.createComponent()</div><div class="line">                                                                    └── DOMActionContextImpl.postRenderTask(AddElementAction)</div><div class="line">                                                            ****************************</div><div class="line">                                                            ├── UpdateAttributeAction.executeDom()</div><div class="line">                                                            ****************************</div><div class="line">                                                            ├── CreateFinishAction.executeDom()</div><div class="line">                                                            ****************************</div><div class="line">                                                            ├── UpdateStyleAction.executeDom()</div><div class="line">                                                            ****************************</div><div class="line">                                                            ├── UpdateFinishAction.executeDom()</div><div class="line">                                                            ****************************</div><div class="line">                                                        ├── WXDomManager.batch()</div><div class="line">                                                            └── DOMActionContextImpl.layout()</div><div class="line">                                                                └── DOMActionContextImpl.consumeRenderTasks()</div><div class="line">                                                                    ├── WXRenderManager.runOnThread()</div><div class="line">                                                                        └── RenderActionTask.execute()</div><div class="line">                                                                            └── CreateBodyAction.executeRender()</div><div class="line">                                                                                ├── WXComponent(WXDiv).createView()</div><div class="line">                                                                                ├── WXComponent(WXDiv).applyLayoutAndEvent()</div><div class="line">                                                                                ├── WXComponent.bindData()</div><div class="line">                                                                                    ├── WXComponent.updateStyle()</div><div class="line">                                                                                    ├── WXComponent.updateAttrs()</div><div class="line">                                                                                    └── WXComponent.updateExtra()</div><div class="line">                                                                                ├── WXSDKInstance.onRootCreated()</div><div class="line">                                                                                ├── WXSDKInstance.onCreateFinish()</div><div class="line">                                                                                    └── RenderListener.onViewCreated()</div><div class="line">                                                                                        └── TestWeexActivity.onViewCreated()</div><div class="line">                                                                                        (调用setContentView(view))</div><div class="line">                                                                                └── WXComponent(WXDiv).onRenderFinish()</div><div class="line">                                                                    *******************************************</div><div class="line">                                                                    ├── WXRenderManager.runOnThread()</div><div class="line">                                                                        └── RenderActionTask.execute()</div><div class="line">                                                                            └── AddElementAction.executeRender()</div><div class="line">                                                                                ├── WXVContainer(WXDiv).addChild()</div><div class="line">                                                                                ├── WXVContainer(WXDiv).createChildViewAt()</div><div class="line">                                                                                ├── WXComponent(WXImage).applyLayoutAndEvent()</div><div class="line">                                                                                ├── WXComponent(WXImage).bindData()</div><div class="line">                                                                                └── WXComponent(WXImage).onRenderFinish()</div><div class="line">                                                                    *******************************************</div></pre></td></tr></table></figure>
<h2 id="解析-JS"><a href="#解析-JS" class="headerlink" title="解析 JS"></a>解析 JS</h2><p>这一过成比较简单，调用 <code>WXSDKInstance.render()</code> 方法把转换成的 JS 代码给 JS 引擎处理。<br>这里需要说明一下在 <code>WXSDKManager.createInstance()</code> 方法中，会调用 <code>WXRenderManager.registerInstance</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void registerInstance(WXSDKInstance instance) &#123;</div><div class="line">  mRegistries.put(instance.getInstanceId(), new RenderActionContextImpl(instance));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会获取当前 <code>WXSDKInstance</code> 的 ID，并生成 <code>RenderActionContextImpl</code> 放入到 <code>ConcurrentHashMap</code> 中去。<br><code>WXSDKInstance</code> 的 ID 在 <code>WXSDKManager</code> 中生成，每个 <code>WXSDKInstance</code> 实例在上一个基础上加一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String generateInstanceId() &#123;</div><div class="line">  return String.valueOf(sInstanceId.incrementAndGet());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="指令分发"><a href="#指令分发" class="headerlink" title="指令分发"></a>指令分发</h2><h3 id="WXDomModule-分发JS发出的指令"><a href="#WXDomModule-分发JS发出的指令" class="headerlink" title="WXDomModule 分发JS发出的指令"></a>WXDomModule 分发JS发出的指令</h3><p><code>WXDomModule</code> 是派发渲染指令的枢纽，提供了 callDomMethod() 和 postAction()方法来派发渲染指令。<br>先看一下在 <code>WXDomModule.callDomMethod()</code> 方法中对指令的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public Object callDomMethod(String method, JSONArray args, long... parseNanos) &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  try &#123;</div><div class="line">    Action action = Actions.get(method,args);</div><div class="line">    if(action == null)&#123;</div><div class="line">      WXLogUtils.e(&quot;Unknown dom action.&quot;);</div><div class="line">    &#125;</div><div class="line">    if(action instanceof DOMAction)&#123;</div><div class="line">      postAction((DOMAction)action, CREATE_BODY.equals(method) || ADD_RULE.equals(method));</div><div class="line">    &#125;else &#123;</div><div class="line">      postAction((RenderAction)action);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">  &#125; catch (IndexOutOfBoundsException e) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以处理的 Action 包括：</p>
<ul>
<li>CreateBodyAction</li>
<li>UpdateAttributeAction</li>
<li>UpdateStyleAction</li>
<li>RemoveElementAction</li>
<li>AddElementAction</li>
<li>MoveElementAction</li>
<li>AddEventAction</li>
<li>RemoveEventAction</li>
<li>CreateFinishAction</li>
<li>RefreshFinishAction</li>
<li>UpdateFinishAction</li>
<li>ScrollToElementAction</li>
<li>AddRuleAction：参考 <a href="http://weex.apache.org/cn/references/modules/dom.html" target="_blank" rel="external">官网说明</a></li>
<li>GetComponentRectAction</li>
<li>InvokeMethodAction</li>
</ul>
<p>这里的大部分 Action 是既实现了 <code>DOMAction</code> 又实现了 <code>RenderAction</code> 接口的，这种 Action 会执行 <code>WXDomModule.postAction(DOMAction action, boolean createContext)</code> 方法，先在 WeeXDomThread 线程中执行构建 DOM 的操作。然后通过 <code>DOMActionContextImpl.postRenderTask()</code> 生成 <code>RenderActionTask</code>，再后面的批处理操作中处理这些渲染动作。<br>如果是没有实现 <code>DOMAction</code> 接口的 Action，就执行 <code>WXDomModule.postAction(RenderAction action)</code>，直接立即在 UI 线程中执行渲染操作。</p>
<h3 id="WXDomHandler-处理构建客户端DOM的指令"><a href="#WXDomHandler-处理构建客户端DOM的指令" class="headerlink" title="WXDomHandler 处理构建客户端DOM的指令"></a>WXDomHandler 处理构建客户端DOM的指令</h3><p><code>WXDomHandler</code> 处理 WXDomModule 发过来的操作指令，比如 </p>
<ul>
<li>MsgType.WX_EXECUTE_ACTION：接受一下 Dom 指令：CreateBodyAction、AddElementAction、UpdateStyleAction、UpdateAttributeAction、CreateFinishAction、UpdateFinishAction</li>
<li>MsgType.WX_DOM_BATCH：批处理前面的 Dom 操作，执行渲染动作。这个不是 WXDomModule 发过来的，在 WXDomHandler 这边生成的。2ms 执行一次批处理操作。</li>
<li>MsgType.WX_DOM_UPDATE_STYLE：被弃用的方法，更新 style。其实在 <code>MsgType.WX_EXECUTE_ACTION</code> 是可以处理 JS 端发出的 <code>UpdateStyleAction</code> 操作的了，这里保留是为了有些在 Java 侧直接调用的 UPDATE STYLE 操作。</li>
<li>MsgType.WX_CONSUME_RENDER_TASKS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">public boolean handleMessage(Message msg) &#123;</div><div class="line">  if (msg == null) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  int what = msg.what;</div><div class="line">  Object obj = msg.obj;</div><div class="line">  WXDomTask task = null;</div><div class="line">  </div><div class="line">  if (obj != null &amp;&amp; obj instanceof WXDomTask) &#123;</div><div class="line">    task = (WXDomTask) obj;</div><div class="line">    Object action = ((WXDomTask) obj).args.get(0);</div><div class="line">    if (action != null &amp;&amp; action instanceof TraceableAction) &#123;</div><div class="line">      ((TraceableAction) action).mDomQueueTime = SystemClock.uptimeMillis() - msg.getWhen();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  // 这里为了每隔三秒执行一次批处理操作</div><div class="line">  if (!mHasBatch) &#123;</div><div class="line">    mHasBatch = true;</div><div class="line">    if(what != WXDomHandler.MsgType.WX_DOM_BATCH) &#123;</div><div class="line">      int delayTime = DELAY_TIME;</div><div class="line">      if(what == MsgType.WX_DOM_TRANSITION_BATCH)&#123;</div><div class="line">        delayTime = TRANSITION_DELAY_TIME;</div><div class="line">      &#125;</div><div class="line">      mWXDomManager.sendEmptyMessageDelayed(WXDomHandler.MsgType.WX_DOM_BATCH, delayTime);</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">  switch (what) &#123;</div><div class="line">    case MsgType.WX_EXECUTE_ACTION:</div><div class="line">      mWXDomManager.executeAction(task.instanceId, (DOMAction) task.args.get(0), (boolean) task.args.get(1));</div><div class="line">      break;</div><div class="line">    case MsgType.WX_DOM_UPDATE_STYLE:</div><div class="line">      //keep this for direct native call</div><div class="line">      mWXDomManager.executeAction(task.instanceId, Actions.getUpdateStyle((String) task.args.get(0),</div><div class="line">          (JSONObject) task.args.get(1),</div><div class="line">          task.args.size() &gt; 2 &amp;&amp; (boolean) task.args.get(2)),false);</div><div class="line">      break;</div><div class="line">    case MsgType.WX_DOM_BATCH:</div><div class="line"></div><div class="line">      mWXDomManager.batch();</div><div class="line">      mHasBatch = false;</div><div class="line">      break;</div><div class="line">    case MsgType.WX_CONSUME_RENDER_TASKS:</div><div class="line">      mWXDomManager.consumeRenderTask(task.instanceId);</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下 <code>WXDomManager.executeAction()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public void executeAction(String instanceId, DOMAction action, boolean createContext) &#123;</div><div class="line">  // 这里的 createContext 仅在 CreateBodyAction 和 AddRuleAction 时为 true</div><div class="line">  DOMActionContext context = mDomRegistries.get(instanceId);</div><div class="line">  // 这是是确保了 CreateBodyAction 之后才能执行其他 Action，AddRuleAction 是不需要 DOM 根节点的</div><div class="line">  if(context == null)&#123;</div><div class="line">    if(createContext)&#123;</div><div class="line">      DOMActionContextImpl oldStatement = new DOMActionContextImpl(instanceId, mWXRenderManager);</div><div class="line">      mDomRegistries.put(instanceId, oldStatement);</div><div class="line">      context = oldStatement;</div><div class="line">    &#125;else&#123;</div><div class="line">      // 如果是执行其他 action，在 context 为空的情况下会提示错误并返回。</div><div class="line">WXSDKInstance instance =  WXSDKManager.getInstance().getSDKInstance(instanceId);</div><div class="line">if(action != null &amp;&amp; instance!= null &amp;&amp; !instance.getismIsCommitedDomAtionExp())&#123;</div><div class="line">  String className = action.getClass().getSimpleName();</div><div class="line">  WXLogUtils.e(&quot;WXDomManager&quot;, className + &quot; Is Invalid Action&quot;);</div><div class="line">  if(className.contains(&quot;CreateFinishAction&quot;))&#123;</div><div class="line">	WXExceptionUtils.commitCriticalExceptionRT(instanceId,</div><div class="line">			WXErrorCode.WX_KEY_EXCEPTION_DOM_ACTION_FIRST_ACTION.getErrorCode(),</div><div class="line">			&quot;executeAction&quot;,</div><div class="line">			WXErrorCode.WX_KEY_EXCEPTION_DOM_ACTION_FIRST_ACTION.getErrorMsg() + &quot;|current action is&quot; +className, null);</div><div class="line">	instance.setmIsCommitedDomAtionExp(true);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">return;</div><div class="line"> &#125;</div><div class="line">  &#125;</div><div class="line">  long domStart = System.currentTimeMillis();</div><div class="line">  long domNanos = System.nanoTime();</div><div class="line">  // 对应的 Action 执行 Dom 操作</div><div class="line">  action.executeDom(context);</div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="构建客户端-DOM"><a href="#构建客户端-DOM" class="headerlink" title="构建客户端 DOM"></a>构建客户端 DOM</h2><p>这一节我们以处理 <code>CreateBodyAction</code> 为例来介绍一下渲染过程中构建客户端 DOM 的处理。<br>先来看一下 <code>CreateBodyAction.addDomInternal()</code> 方法。<br><code>dom</code> 参数是代表类似这样 json 字符串的一个对象。<br><code>{&quot;attr&quot;:{},&quot;ref&quot;:&quot;_root&quot;,&quot;style&quot;:{&quot;alignItems&quot;:&quot;center&quot;,&quot;height&quot;:800,&quot;justifyContent&quot;:&quot;center&quot;,&quot;width&quot;:750},&quot;type&quot;:&quot;div&quot;}</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">protected void addDomInternal(DOMActionContext context, JSONObject dom) &#123;</div><div class="line">  ......</div><div class="line">  Stopwatch.tick();</div><div class="line">  // 把json对象转换为 WXDomObject 对象</div><div class="line">  WXDomObject domObject = WXDomObject.parse(dom, instance, null);</div><div class="line">  Stopwatch.split(&quot;parseDomObject&quot;);</div><div class="line"></div><div class="line">  if (domObject == null || context.getDomByRef(domObject.getRef()) != null) &#123;</div><div class="line">    ...</div><div class="line"> return;</div><div class="line">  &#125;</div><div class="line">  appendDomToTree(context, domObject);</div><div class="line">  Stopwatch.split(&quot;appendDomToTree&quot;);</div><div class="line"></div><div class="line">  domObject.traverseTree(</div><div class="line">      context.getAddDOMConsumer(),</div><div class="line">      context.getApplyStyleConsumer()</div><div class="line">  );</div><div class="line">  Stopwatch.split(&quot;traverseTree&quot;);</div><div class="line"></div><div class="line"></div><div class="line">  //Create component in dom thread</div><div class="line">  WXComponent component = createComponent(context, domObject);</div><div class="line">  if (component == null) &#123;</div><div class="line"> return;</div><div class="line">  &#125;</div><div class="line">  Stopwatch.split(&quot;createComponent&quot;);</div><div class="line"></div><div class="line">  context.addDomInfo(domObject.getRef(), component);</div><div class="line">  //Dom 构建完成，这里把当前Action放入到待 Render 列表中，等待后面的批处理进行Render操作。</div><div class="line">  context.postRenderTask(this);</div><div class="line">  addAnimationForDomTree(context, domObject);</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析JSON：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public static  @Nullable WXDomObject parse(JSONObject json, WXSDKInstance wxsdkInstance, WXDomObject parentDomObject)&#123;</div><div class="line">    ......</div><div class="line">    // 获取跟节点的类型，CreateBodyAction时一般为div</div><div class="line">    String type = (String) json.get(TYPE);</div><div class="line"></div><div class="line">    if (wxsdkInstance.isNeedValidate()) &#123;</div><div class="line">      ....</div><div class="line">    &#125;</div><div class="line">    // 生成 WXDomObject</div><div class="line">    WXDomObject domObject = WXDomObjectFactory.newInstance(type);</div><div class="line"></div><div class="line">    domObject.setViewPortWidth(wxsdkInstance.getInstanceViewPortWidth());</div><div class="line"></div><div class="line">    if(domObject == null)&#123;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line">    // 设置属性值，包括 style、attr、event、ref（结点的唯一标识符）、parent、children等</div><div class="line">    domObject.parseFromJson(json);</div><div class="line">    domObject.mDomContext = wxsdkInstance;</div><div class="line">    domObject.parent = parentDomObject;</div><div class="line">    // 添加一些子节点信息</div><div class="line">    Object children = json.get(CHILDREN);</div><div class="line">    if (children != null &amp;&amp; children instanceof JSONArray) &#123;</div><div class="line">      JSONArray childrenArray = (JSONArray) children;</div><div class="line">      int count = childrenArray.size();</div><div class="line">      for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">        domObject.add(parse(childrenArray.getJSONObject(i),wxsdkInstance, domObject),-1);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    domObject.mDomThreadNanos = System.nanoTime() - startNanos;</div><div class="line">    domObject.mDomThreadTimestamp = timestamp;</div><div class="line">    return domObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成 WXComponent：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">protected WXComponent generateComponentTree(DOMActionContext context, WXDomObject dom, WXVContainer parent) &#123;</div><div class="line">  if (dom == null) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  long startNanos = System.nanoTime();</div><div class="line">  // 生成 WXComponent，CreateBodyAction时一般为 WXDiv</div><div class="line">  WXComponent component = WXComponentFactory.newInstance(context.getInstance(), dom, parent);</div><div class="line">  if (component != null) &#123;</div><div class="line">    component.mTraceInfo.domThreadStart = dom.mDomThreadTimestamp;</div><div class="line">    component.mTraceInfo.rootEventId = mTracingEventId;</div><div class="line">    component.mTraceInfo.domQueueTime = mDomQueueTime;</div><div class="line">  &#125;</div><div class="line">  // 把生成的组件注册给 RenderActionContextImpl</div><div class="line">  context.registerComponent(dom.getRef(), component);</div><div class="line">  if (component instanceof WXVContainer) &#123;</div><div class="line">    WXVContainer parentC = (WXVContainer) component;</div><div class="line">    int count = dom.childCount();</div><div class="line">    WXDomObject child = null;</div><div class="line">    // 添加子节点</div><div class="line">    for (int i = 0; i &lt; count; ++i) &#123;</div><div class="line">      child = dom.getChild(i);</div><div class="line">      if (child != null) &#123;</div><div class="line">        WXComponent createdComponent = generateComponentTree(context, child, parentC);</div><div class="line">        if(createdComponent != null) &#123;</div><div class="line">          parentC.addChild(createdComponent);</div><div class="line">        &#125;else&#123;</div><div class="line">          ......</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  if (component != null) &#123;</div><div class="line">    component.mTraceInfo.domThreadNanos = System.nanoTime() - startNanos;</div><div class="line">  &#125;</div><div class="line">  return component;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>这一节我们以处理 <code>CreateBodyAction</code> 为例来介绍一下渲染过程中对构建客户端 DOM 的渲染处理。<br>渲染阶段的类和生成 Native 组件的类有些是一一对应的，比如：DOMActionContextImpl – RenderActionContextImpl、DOMAction – RenderAction 等。<br><code>CreateBodyAction.executeRender()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public void executeRender(RenderActionContext context) &#123;</div><div class="line">  WXComponent component = context.getComponent(WXDomObject.ROOT);</div><div class="line">  WXSDKInstance instance = context.getInstance();</div><div class="line">  ...</div><div class="line">  try &#123;</div><div class="line">    Stopwatch.tick();</div><div class="line">    long start = System.currentTimeMillis();</div><div class="line">    // 调用 WxComponent.initComponentHostView() 生成Host View，前面介绍过，`initComponentHostView()` 是组件必须实现的方法。</div><div class="line">    component.createView();</div><div class="line">    ...</div><div class="line">    start = System.currentTimeMillis();</div><div class="line">    // 设置lalyout，padding和事件监听</div><div class="line">    component.applyLayoutAndEvent(component);</div><div class="line">    ...</div><div class="line">    // 设置style、attrs和extra</div><div class="line">    component.bindData(component);</div><div class="line"></div><div class="line">    ...</div><div class="line">    if (component instanceof WXScroller) &#123;</div><div class="line">      WXScroller scroller = (WXScroller) component;</div><div class="line">      if (scroller.getInnerView() instanceof ScrollView) &#123;</div><div class="line">        instance.setRootScrollView((ScrollView) scroller.getInnerView());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    // 通知一些回调</div><div class="line">    instance.onRootCreated(component);</div><div class="line">    if (instance.getRenderStrategy() != WXRenderStrategy.APPEND_ONCE) &#123;</div><div class="line">      instance.onCreateFinish();</div><div class="line">    &#125;</div><div class="line">    component.mTraceInfo.uiQueueTime = mUIQueueTime;</div><div class="line">    component.onRenderFinish(WXComponent.STATE_ALL_FINISH);</div><div class="line">  &#125; catch (Exception e) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成 Host View：<br>其实就是生成对应的Android View的过程。</p>
<p><code>WXComponent.createViewImpl()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">protected void createViewImpl() &#123;</div><div class="line">  if (mContext != null) &#123;</div><div class="line">    mHost = initComponentHostView(mContext);</div><div class="line">    if (mHost == null &amp;&amp; !isVirtualComponent()) &#123;</div><div class="line">      //compatible</div><div class="line">      initView();</div><div class="line">    &#125;</div><div class="line">    if(mHost != null)&#123;</div><div class="line">      mHost.setId(WXViewUtils.generateViewId());</div><div class="line">      ComponentObserver observer;</div><div class="line">      if ((observer = getInstance().getComponentObserver()) != null) &#123;</div><div class="line">        observer.onViewCreated(this, mHost);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    onHostViewInitialized(mHost);</div><div class="line">  &#125;else&#123;</div><div class="line">    WXLogUtils.e(&quot;createViewImpl&quot;,&quot;Context is null&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WXDiv.initComponentHostView()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected WXFrameLayout initComponentHostView(@NonNull Context context) &#123;</div><div class="line">  WXFrameLayout frameLayout = new WXFrameLayout(context);</div><div class="line">  frameLayout.holdComponent(this);</div><div class="line">  return frameLayout;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，渲染流程介绍完毕。</p>
]]></content>
    
    <summary type="html">
    
      介绍 Weex Component 的渲染过程
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- Component 和 DomObject 注册过程</title>
    <link href="http://yoursite.com/2018/03/20/open-source-weex-android-component-module-register/"/>
    <id>http://yoursite.com/2018/03/20/open-source-weex-android-component-module-register/</id>
    <published>2018-03-20T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.976Z</updated>
    
    <content type="html"><![CDATA[<p>在 WXSDKEngine 的 <code>register()</code> 方法中进行。这个方法里面是注册 Weex 原生自带的一些组件、模块以及 DomObject，如果你想扩展组件或者模块，也是需要走注册流程的，流程和这里的是一样的。<br><a href="http://weex.apache.org/cn/guide/extend-android.html" target="_blank" rel="external">扩展 Android 的功能 </a></p>
<h2 id="注册-Component"><a href="#注册-Component" class="headerlink" title="注册 Component"></a>注册 Component</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">├── WXSDKEngine.registerComponent()</div><div class="line">    └── WXComponentRegistry.registerComponent()</div><div class="line">        ├── WXComponentRegistry.registerNativeComponent()</div><div class="line">        └── WXComponentRegistry.registerJSComponent()</div><div class="line">            └── WXSDKManager.registerComponents()</div><div class="line">                └── WXBridgeManager.registerComponents()</div><div class="line">                    └── WXBridgeManager.invokeRegisterComponents()</div></pre></td></tr></table></figure>
<p>注册 <code>Component</code> 是在 <code>WXSDKEngine.registerComponent()</code> 方法中进行的，这个方法有几个重载方法，但最终都会执行到这个方法中来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">registerComponent</span><span class="params">(IFComponentHolder holder, <span class="keyword">boolean</span> appendTree, String ... names)</span> <span class="keyword">throws</span> WXException </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> result =  <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">for</span>(String name:names) &#123;</div><div class="line">    Map&lt;String, Object&gt; componentInfo = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">if</span> (appendTree) &#123;</div><div class="line">      componentInfo.put(<span class="string">"append"</span>, <span class="string">"tree"</span>);</div><div class="line">    &#125;</div><div class="line">    result  = result &amp;&amp; WXComponentRegistry.registerComponent(name, holder, componentInfo);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来介绍一下 <code>IFComponentHolder</code> 这个参数。我们就以 <code>WXText</code> 的注册过来介绍一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">registerComponent(</div><div class="line">  new SimpleComponentHolder(</div><div class="line">    WXText.class,</div><div class="line">    new WXText.Creator()</div><div class="line">  ),</div><div class="line">  false,</div><div class="line">  WXBasicComponentType.TEXT</div><div class="line">);</div></pre></td></tr></table></figure>
<p>注册是实例化了一个 <code>SimpleComponentHolder</code> 类。这个类有几个方法，对应它的几个主要作用：</p>
<ul>
<li>createInstance()：生成 Component 实现类的一个实例，比如 <code>WXText</code></li>
<li>getMethods(Class clz)：获取实现类中 <code>WXComponentProp</code> 和 <code>JSMethod</code> 注解标记的属性和方法。</li>
<li>getMethods()：获取所有 <code>JSMethod</code> 注解标记方法。</li>
<li>getMethodInvoker(String name)：获取某个方法对应的实现类的实体方法。</li>
<li>getPropertyInvoker(String name)：获取某个属性对应的实现类的实体方法。</li>
</ul>
<p><img src="http://www.plantuml.com/plantuml/svg/TP1DIWD148NtVOeYgyaYEO6BG40SKH4YA8YBihiI6xkhXkxAGFmvYQTmBNWRyHfECX8qCxFzUFNUHysoOj9r3ERAQo0OBNoi0iqbLiB4UYB1KVf-__Xw-nmPurafBT4IbCS76NWs0BLu1q7GbSiBuJDysXJZ1fTSosCJMP5U9gaewUON5GjDdbV066biNlyCxEldYL2bxR--sMEmMqubPqMsLFo_FiKQiqs-qjqGtWU2NKExTtktTJadVH2N3nLRF21e0-OClLyofkDyz3ATTbzbUko6eXtI12UJ0O4PiLl7y0C0" alt="效果图"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public SimpleComponentHolder(Class&lt;? extends WXComponent&gt; clz,ComponentCreator customCreator) &#123;</div><div class="line">  this.mClz = clz;</div><div class="line">  this.mCreator = customCreator;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里传入的两个参数分别是 <code>Class</code> 和 <code>ComponentCreator</code>。<br>我们来看一下 <code>WXText.Creator()</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public static class Creator implements ComponentCreator &#123;</div><div class="line">  public WXComponent createInstance(WXSDKInstance instance, WXDomObject node, WXVContainer parent) throws IllegalAccessException, InvocationTargetException, InstantiationException &#123;</div><div class="line">    return new WXText(instance, node, parent);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WXText.Creator()</code> 类实现了 <code>ComponentCreator</code>，在 <code>createInstance()</code> 方法中实例化了 <code>WXText</code> 类，这样就建立了和 Native Java 类的连接。<br>我们知道，<code>IFComponentHolder</code> 是继承自 <code>ComponentCreator</code> 的，那么这里在实例化 <code>SimpleComponentHolder</code> 又传入一个 <code>ComponentCreator</code> 实例是用来做什么的呢？<br>我们再来看一下 <code>SimpleComponentHolder</code> 实现的 <code>createInstance()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public synchronized WXComponent createInstance(WXSDKInstance instance, WXDomObject node, WXVContainer parent) throws IllegalAccessException, InvocationTargetException, InstantiationException &#123;</div><div class="line">  WXComponent component = mCreator.createInstance(instance,node,parent);</div><div class="line">  component.bindHolder(this);</div><div class="line">  return component;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是调用的 <code>WXText.Creator()</code> 实例的 <code>createInstance()</code> 方法，并把 <code>SimpleComponentHolder</code> 绑定到生成的 <code>WXComponent</code> 上。这个方法什么时候使用我们后面再说。</p>
<p>再来看一下 <code>WXComponentRegistry.registerComponent()</code> 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static boolean registerComponent(final String type, final IFComponentHolder holder, final Map&lt;String, Object&gt; componentInfo) throws WXException &#123;</div><div class="line">  ...</div><div class="line">  // 在js线程中执行注册操作</div><div class="line">  WXBridgeManager.getInstance()</div><div class="line">      .post(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">      try &#123;</div><div class="line">        Map&lt;String, Object&gt; registerInfo = componentInfo;</div><div class="line">        if (registerInfo == null)&#123;</div><div class="line">          registerInfo = new HashMap&lt;&gt;();</div><div class="line">        &#125;</div><div class="line">        // 将 component 名字作为类型</div><div class="line">        registerInfo.put(&quot;type&quot;,type);</div><div class="line">        // 获取 `JSMethod` 注解标记的方法</div><div class="line">        // 这里或许有个疑问，自定义的属性去哪里了？</div><div class="line">        registerInfo.put(&quot;methods&quot;,holder.getMethods());</div><div class="line">        registerNativeComponent(type, holder);</div><div class="line">        registerJSComponent(registerInfo);</div><div class="line">        sComponentInfos.add(registerInfo);</div><div class="line">      &#125; catch (WXException e) &#123;</div><div class="line">        WXLogUtils.e(&quot;register component error:&quot;, e);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private void invokeRegisterComponents(List&lt;Map&lt;String, Object&gt;&gt; components, List&lt;Map&lt;String, Object&gt;&gt; failReceiver) &#123;</div><div class="line">  ...</div><div class="line">  // 生成参数：[&#123;&quot;methods&quot;:[&quot;recoverImageList&quot;,&quot;releaseImageList&quot;],&quot;type&quot;:&quot;container&quot;&#125;]</div><div class="line">  WXJSObject[] args = &#123;new WXJSObject(WXJSObject.JSON,</div><div class="line">      WXJsonUtils.fromObjectToJSONString(components))&#125;;</div><div class="line">  try &#123;</div><div class="line">  // 通过jni运行js方法，注册到js</div><div class="line">    mWXBridge.execJS(&quot;&quot;, null, METHOD_REGISTER_COMPONENTS, args);</div><div class="line">  &#125; catch (Throwable e) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里再来介绍一下 <code>appendTree</code> 这个参数。<br>Weex 注册的 <code>Component</code> 有两种类型，一类是有 <code>{@&quot;append&quot;:@&quot;tree&quot;}</code> 属性的标签，另一类是没有 <code>{@&quot;append&quot;:@&quot;tree&quot;}</code> 属性的标签。</p>
<h2 id="注册-DomObject"><a href="#注册-DomObject" class="headerlink" title="注册 DomObject"></a>注册 DomObject</h2><p>前面博客中也说过，DomObject 包括了 <code>&lt;template&gt;</code> 在 Dom 树中的所有信息，如 style、attr、event、ref（结点的唯一标识符）、parent、children 等。<br>在源码中注册过 Component 和 Moudle 后，紧接着是注册 DomObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">registerDomObject(WXBasicComponentType.TEXT, WXTextDomObject.class);</div></pre></td></tr></table></figure>
<p>注册流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">├── WXSDKEngine.registerDomObject()</div><div class="line">    ├── WXDomRegistry.registerDomObject()</div></pre></td></tr></table></figure>
<p>WXDomRegistry.registerDomObject():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static boolean registerDomObject(String type, Class&lt;? extends WXDomObject&gt; clazz) throws WXException &#123;</div><div class="line">  if (clazz == null || TextUtils.isEmpty(type)) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (sDom.containsKey(type)) &#123;</div><div class="line">    if (WXEnvironment.isApkDebugable()) &#123;</div><div class="line">      throw new WXException(&quot;WXDomRegistry had duplicate Dom:&quot; + type);</div><div class="line">    &#125; else &#123;</div><div class="line">      WXLogUtils.e(&quot;WXDomRegistry had duplicate Dom: &quot; + type);</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  sDom.put(type, clazz);</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这部分是比较简单的。仅仅是把注册的 <code>WXDomObject</code> 放到一个 <code>Map</code> 中去，在生成 Native Dom 的时候再生成 <code>WXDomObject</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">├── AbstractAddElementAction.addDomInternal()</div><div class="line">    ├── WXDomObject.parse()</div><div class="line">        ├── WXDomObjectFactory.newInstance(type)</div><div class="line">            ├── WXDomRegistry.getDomObjectClass()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      介绍 Weex Component 和 DomObject注册过程
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- 初始化过程</title>
    <link href="http://yoursite.com/2018/03/15/open-source-weex-android-init/"/>
    <id>http://yoursite.com/2018/03/15/open-source-weex-android-init/</id>
    <published>2018-03-15T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>从本篇博客开始，会陆续进行一些 Weex 源码分析的文章，源码的 Weex SDK Version 是基于0.17.0，JS Framework 是基于 0.23.9， 平台是基于 Android 来进行分析的。</p>
<h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><h3 id="WXSDKEngine-初始化"><a href="#WXSDKEngine-初始化" class="headerlink" title="WXSDKEngine 初始化"></a>WXSDKEngine 初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class WXApplication extends Application &#123;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onCreate() &#123;</div><div class="line">    super.onCreate();</div><div class="line">    InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();</div><div class="line">    WXSDKEngine.initialize(this,config);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用了 <code>WXSDKEngine.initialize()</code> 方法，这里有 <code>InitConfig</code> 作为参数来初始化。<br>先来看一下 <code>InitConfig</code> 类。<br><code>InitConfig</code> 使用 Builder 模式来构造一个 Weex 初始化配置的一个类。不熟悉 Builder 模式的同学可以先了解一下这个设计模式。<br><code>InitConfig</code> 主要是配置一些 Adapter：</p>
<ul>
<li>IWXHttpAdapter</li>
<li>IWXImgLoaderAdapter</li>
<li>IDrawableLoader</li>
<li>IWXUserTrackAdapter</li>
<li>IWXStorageAdapter</li>
<li>IWXSoLoaderAdapter</li>
<li>URIAdapter</li>
<li>IWXJSExceptionAdapter</li>
<li>framework</li>
<li>IWebSocketAdapterFactory</li>
</ul>
<p>配置了这些 Adapter，Weex 才能更好地实现一些功能。比如前面示例代码中，如果想显示一个图片的话就必须配置 <code>IWXImgLoaderAdapter</code>，自定义完成图片的加载工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">├── WXSDKEngine.initialize()</div><div class="line">    └── WXSDKEngine.doInitInternal()</div><div class="line">        ├── WXBridgeManager.getInstance().post()</div><div class="line">            ├── WXSDKManager.onSDKEngineInitialize()</div><div class="line">            ├── WXSDKManager.setInitConfig()</div><div class="line">            ├── WXSoInstallMgrSdk.init()</div><div class="line">            ├── WXSoInstallMgrSdk.initSo()</div><div class="line">            └── WXSDKManager.initScriptsFramework()</div><div class="line">                └── WXBridgeManager.initScriptsFramework()</div><div class="line">                    └── WXBridgeManager.invokeInitFramework()</div><div class="line">                        └── WXBridgeManager.initFramework()</div><div class="line">                            ├── WXBridge.initFrameworkEnv()</div><div class="line">                                ├── initFrameworkMultiProcess()</div><div class="line">                                └── initFramework()</div><div class="line">                            └── WXBridgeManager.registerDomModule()</div><div class="line">                                └── WXBridgeManager.registerModules()</div><div class="line">                                    └── WXBridgeManager.invokeRegisterModules()</div><div class="line">                                        └── WXBridge.execJS()</div><div class="line">        └── WXSDKEngine.register()</div><div class="line">            ├── WXSDKEngine.registerComponent()</div><div class="line">            ├── WXSDKEngine.registerModule()</div><div class="line">            └── WXSDKEngine.registerDomObject()</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doInitInternal</span><span class="params">(<span class="keyword">final</span> Application application,<span class="keyword">final</span> InitConfig config)</span></span>&#123;</div><div class="line">   WXEnvironment.sApplication = application;</div><div class="line"><span class="keyword">if</span>(application == <span class="keyword">null</span>)&#123;</div><div class="line">  WXLogUtils.e(TAG, <span class="string">" doInitInternal application is null"</span>);</div><div class="line">  WXExceptionUtils.commitCriticalExceptionRT(<span class="keyword">null</span>,</div><div class="line">		  WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorCode(),</div><div class="line">		  <span class="string">"doInitInternal"</span>,</div><div class="line">		  WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + <span class="string">"WXEnvironment sApplication is null"</span>,</div><div class="line">		  <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line">   WXEnvironment.JsFrameworkInit = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">   WXBridgeManager.getInstance().post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">       WXSDKManager sm = WXSDKManager.getInstance();</div><div class="line">       sm.onSDKEngineInitialize();</div><div class="line">       <span class="keyword">if</span>(config != <span class="keyword">null</span> ) &#123;</div><div class="line">         <span class="comment">//把初始化配置设置给 WXSDKManager</span></div><div class="line">         sm.setInitConfig(config);</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 加载 libweexjsc.so V8 引擎库。</span></div><div class="line">       WXSoInstallMgrSdk.init(application,</div><div class="line">                             sm.getIWXSoLoaderAdapter(),</div><div class="line">                             sm.getWXStatisticsListener());</div><div class="line">       <span class="keyword">boolean</span> isSoInitSuccess = WXSoInstallMgrSdk.initSo(V8_SO_NAME, <span class="number">1</span>, config!=<span class="keyword">null</span>?config.getUtAdapter():<span class="keyword">null</span>);</div><div class="line">       <span class="keyword">if</span> (!isSoInitSuccess) &#123;</div><div class="line">	  WXExceptionUtils.commitCriticalExceptionRT(<span class="keyword">null</span>,</div><div class="line">			  WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorCode(),</div><div class="line">			  <span class="string">"doInitInternal"</span>,</div><div class="line">			  WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + <span class="string">"isSoInit false"</span>,</div><div class="line">			  <span class="keyword">null</span>);</div><div class="line"></div><div class="line">         <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 初始化 js framework</span></div><div class="line">       sm.initScriptsFramework(config!=<span class="keyword">null</span>?config.getFramework():<span class="keyword">null</span>);</div><div class="line"></div><div class="line">       WXEnvironment.sSDKInitExecuteTime = System.currentTimeMillis() - start;</div><div class="line">       WXLogUtils.renderPerformanceLog(<span class="string">"SDKInitExecuteTime"</span>, WXEnvironment.sSDKInitExecuteTime);</div><div class="line">     &#125;</div><div class="line">   &#125;);</div><div class="line">   <span class="comment">// 注册 Component 、 Module 以及 DomObject</span></div><div class="line">   register();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里大部分的初始化工作是在 <code>WXBridgeManager.getInstance().post()</code> 方法中进行的，这个方法会把这些操作放到 WeexJSBridgeThread 线程中去执行。<br>有关 Weex 的线程模型后面文章再介绍。</p>
<h4 id="初始化-Js-Framework"><a href="#初始化-Js-Framework" class="headerlink" title="初始化 Js Framework"></a>初始化 Js Framework</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFramework</span><span class="params">(String framework)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!isJSFrameworkInit()) &#123;</div><div class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(framework)) &#123;</div><div class="line">      <span class="comment">// 这里如果在 InitConfig 没有配置 framework js 的话就默认加载 sdk 里面的 main.js</span></div><div class="line">      <span class="comment">// if (WXEnvironment.isApkDebugable()) &#123;</span></div><div class="line">      WXLogUtils.d(<span class="string">"weex JS framework from assets"</span>);</div><div class="line">      <span class="comment">// &#125;</span></div><div class="line">      framework = WXFileUtils.loadAsset(<span class="string">"main.js"</span>, WXEnvironment.getApplication());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果加载 js framework 不成功，报错返回。</span></div><div class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(framework)) &#123;</div><div class="line">      setJSFrameworkInit(<span class="keyword">false</span>);</div><div class="line">WXExceptionUtils.commitCriticalExceptionRT(<span class="keyword">null</span>, WXErrorCode.WX_ERR_JS_FRAMEWORK.getErrorCode(),</div><div class="line">		<span class="string">"initFramework"</span>, <span class="string">"framework is empty!! "</span>, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">if</span> (WXSDKManager.getInstance().getWXStatisticsListener() != <span class="keyword">null</span>) &#123;</div><div class="line">        WXSDKManager.getInstance().getWXStatisticsListener().onJsFrameworkStart();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">      String crashFile = <span class="string">""</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        crashFile = WXEnvironment.getApplication().getApplicationContext().getCacheDir().getPath();</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">boolean</span> pieSupport = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) &#123;</div><div class="line">          pieSupport = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      WXLogUtils.d(<span class="string">"[WXBridgeManager] initFrameworkEnv crashFile:"</span> + crashFile + <span class="string">" pieSupport:"</span> + pieSupport);</div><div class="line">      <span class="comment">// 调用 WXBridge.initFrameworkEnv() 方法调用 native 方法初始化 js framework</span></div><div class="line">      <span class="keyword">if</span> (mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport) == INIT_FRAMEWORK_OK) &#123;</div><div class="line">        WXEnvironment.sJSLibInitTime = System.currentTimeMillis() - start;</div><div class="line">        WXLogUtils.renderPerformanceLog(<span class="string">"initFramework"</span>, WXEnvironment.sJSLibInitTime);</div><div class="line">        WXEnvironment.sSDKInitTime = System.currentTimeMillis() - WXEnvironment.sSDKInitStart;</div><div class="line">        WXLogUtils.renderPerformanceLog(<span class="string">"SDKInitTime"</span>, WXEnvironment.sSDKInitTime);</div><div class="line">        setJSFrameworkInit(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (WXSDKManager.getInstance().getWXStatisticsListener() != <span class="keyword">null</span>) &#123;</div><div class="line">          WXSDKManager.getInstance().getWXStatisticsListener().onJsFrameworkReady();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        execRegisterFailTask();</div><div class="line">        WXEnvironment.JsFrameworkInit = <span class="keyword">true</span>;</div><div class="line">        <span class="comment">// 注册 DomModule，后面会统一介绍注册 Module 的步骤</span></div><div class="line">        registerDomModule();</div><div class="line">        String reinitInfo = <span class="string">""</span>;</div><div class="line">        <span class="keyword">if</span> (reInitCount &gt; <span class="number">1</span>) &#123;</div><div class="line">          reinitInfo = <span class="string">"reinit Framework:"</span>;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ......</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">      ......</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      介绍 Weex 的初始化过程
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- 相关类概述</title>
    <link href="http://yoursite.com/2018/03/10/open-source-weex-android-classes-introduction/"/>
    <id>http://yoursite.com/2018/03/10/open-source-weex-android-classes-introduction/</id>
    <published>2018-03-10T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.837Z</updated>
    
    <content type="html"><![CDATA[<p>这里先来介绍几个 Component 相关的几个类：</p>
<h2 id="WXSDKManager"><a href="#WXSDKManager" class="headerlink" title="WXSDKManager"></a>WXSDKManager</h2><p>这个是 weex 的核心所在，直接或者间接的管理着 weex 上下文相关的所有类。以组合的形式带上 <code>WXBridgeManager</code>、<code>WXRendermanager</code> 和 <code>WXDomManager</code>。三个管理类如名称一样，负责各自的功能区域。后面会分别再介绍这三个类</p>
<h2 id="WXBridgeManager"><a href="#WXBridgeManager" class="headerlink" title="WXBridgeManager"></a>WXBridgeManager</h2><p>主要负责 和 JS 引擎交互 ，发送 native 端 java 的请求到 jni 层，并接收js引擎处理后从jni上返回的消息。</p>
<h2 id="WXRendermanager"><a href="#WXRendermanager" class="headerlink" title="WXRendermanager"></a>WXRendermanager</h2><p>将对应的Dom的节点渲染成组件。<br><code>WXRenderManager</code> 中的 <code>WXRenderHandler</code> 根据代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public WXRenderHandler() &#123;</div><div class="line">  super(Looper.getMainLooper());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到是运行在 UI 线程中的，因此，渲染都是在 UI 线程中执行的。</p>
<h2 id="RenderActionContextImpl"><a href="#RenderActionContextImpl" class="headerlink" title="RenderActionContextImpl"></a>RenderActionContextImpl</h2><p>是 <code>RenderActionContext</code> 的实现类。是渲染动作的执行类。<code>mRegistry</code> 保存了 <code>WXSDKInstance</code> 对应的所有的组件。</p>
<h2 id="RenderAction"><a href="#RenderAction" class="headerlink" title="RenderAction"></a>RenderAction</h2><h2 id="WXDomManager"><a href="#WXDomManager" class="headerlink" title="WXDomManager"></a>WXDomManager</h2><p>负责构建客户端的dom结构，在 <code>WXBridgeManager</code> 接收到消息后，会交给 <code>WxDomManager</code> 处理，<code>WxDomManager</code> 根据消息创建自己的 Dom 结构，添加、删除、修改元素。<br>WXDomManager.batch() 批处理dom操作。<br><code>WXDomManager</code> 中的 <code>mDomHandler</code> 我们根据代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mDomThread = new WXThread(&quot;WeeXDomThread&quot;, new WXDomHandler(this));</div></pre></td></tr></table></figure>
<p>可以知道它是一个名称为 WeeXDomThread 的后台线程。</p>
<h2 id="DOMActionContextImpl"><a href="#DOMActionContextImpl" class="headerlink" title="DOMActionContextImpl"></a>DOMActionContextImpl</h2><h2 id="DOMAction"><a href="#DOMAction" class="headerlink" title="DOMAction"></a>DOMAction</h2><ul>
<li>AddEventAction</li>
<li>AnimationAction</li>
<li>RemoveElementAction</li>
<li>RemoveEventAction</li>
<li>ScrollToElementAction</li>
<li>UpdateAttributeAction</li>
<li>UpdateFinishAction</li>
<li>UpdateStyleAction</li>
</ul>
<h2 id="WXDomObject"><a href="#WXDomObject" class="headerlink" title="WXDomObject"></a>WXDomObject</h2><ul>
<li>DomObject 包括了 <code>&lt;template&gt;</code> 在 Dom 树中的所有信息，如 style、attr、event、ref（结点的唯一标识符）、parent、children</li>
</ul>
<h2 id="ImmutableDomObject"><a href="#ImmutableDomObject" class="headerlink" title="ImmutableDomObject"></a>ImmutableDomObject</h2><ul>
<li>表示一个 Dom 节点</li>
</ul>
<h2 id="WXComponent"><a href="#WXComponent" class="headerlink" title="WXComponent"></a>WXComponent</h2><ul>
<li>Component 负责承载 Native View，可以通过泛型指定承载 View的类型。</li>
<li>所有组件相关的类都要继承这个类。</li>
<li>Component 会保留 DomObject 的强引用，两者实例是一一对应的。</li>
<li><p>通过调用 initComponentHostView 创建 Component 需要承载的 View，所有 的Component 必须重写 initComponentHostView 方法，返回需要承载的 View 的最外层容器。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Component(lazyload = false)</div><div class="line">public class WXText extends WXComponent&lt;WXTextView&gt; implements FlatComponent&lt;TextWidget&gt; &#123;</div><div class="line"> protected WXTextView initComponentHostView(@NonNull Context context) &#123;</div><div class="line">   WXTextView textView =new WXTextView(context);</div><div class="line">   textView.holdComponent(this);</div><div class="line">   return textView;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="WXModule"><a href="#WXModule" class="headerlink" title="WXModule"></a>WXModule</h2><ul>
<li>通过 Module 可以将 Native Api 暴露给Js。</li>
<li>所有的模块都要继承这个类。</li>
</ul>
<h2 id="WXSDKInstance"><a href="#WXSDKInstance" class="headerlink" title="WXSDKInstance"></a>WXSDKInstance</h2><p>这个类前面的 demo 中已经展示了它的用法。</p>
<ul>
<li>Weex 的渲染单位，是 weex 渲染的实例对象。</li>
<li>它可以是一个纯 weex View，和可以和 Native 混合。</li>
<li>它提供了一系列跟页面渲染相关的接口：render()、renderByUrl()等。</li>
<li>提供了几个比较重要的回调接口，比如生命周期回调和渲染结果回调。方便开发者根据不同的业务场景去处理他们的逻辑。</li>
<li>这里明确两个容器的概念： <ul>
<li>Instance RootView：Weex 最外层容器， Native 接入方可以设置 Instance RootView 大小, 最终通过 <code>onViewCreated()</code> 返回给用户的View也就是 Instance RootView。用 <code>RenderContainer</code> 类来表示。</li>
<li>JS Root: JS 可以描述的最外层容器， 为 RootView 的唯一子节点， 受 JS 样式的控制。用 <code>WXComponent</code> 来表示。</li>
</ul>
</li>
<li>Instance 宽高设置遵循以下几个原则：<ul>
<li>Instance RootView 的宽高优先遵循 instance。 设置的宽高，如果开发者没有设置，则与 JS Root 节点的宽高保持一致。</li>
<li>JS Root 节点的宽高优先遵循 CSS 样式设置的宽高，如果没有设置，则使用 instance 上设置的宽高，如果 instance 也没有设置，则使用 layout 出来的宽高</li>
<li>特殊情况，当 <code>scroller</code> 和 <code>list</code> 作为 <code>JS Root</code> 时，如果不设置高度, 会给 <code>scroller</code> 和 <code>list</code> 设置 <code>flex:1</code>。</li>
<li>综上所述，Instance RootView 和 JS Root 的宽高可以不一致，应该根据需求正确的设置 Instance 的宽高，也可以在运行时动态的改变 Instance 的宽高。</li>
</ul>
</li>
</ul>
<h2 id="WXDomModule"><a href="#WXDomModule" class="headerlink" title="WXDomModule"></a>WXDomModule</h2><p>派发渲染指令的枢纽，提供了 <code>callDomMethod()</code> 和 <code>postAction()</code>方法来派发渲染指令。</p>
<ul>
<li>JSFramework 根据 Virtual Dom 计算出来的 dif，将渲染指令（Json）通过 Js Engine 发送给 Native Render 进行渲染。而 <code>WXDomModule</code> 会接收到所有渲染指令，然后将指令post 给 <code>DomHandler</code>，最后由 <code>DomHandler</code> 来派发渲染任务。</li>
<li><code>DomStatement</code> 在 Dom 线程中创建 <code>DomObject</code> 和 <code>Component</code>，<code>RenderStatement</code> 负责在 UI 线程中渲染 View；每个 <code>WXSDKInstance</code> 会持有一个 <code>DomStatement</code> 和 <code>RenderStatement</code> 实例。</li>
<li><code>RenderStatement</code> 会从 <code>DomStatementclone</code> 一份 <code>DomObject</code>，是为了避免两个线程同时操作 Dom 造成的同步问题。</li>
<li>主要有如下指令：<ul>
<li>createBody：<code>DomStatement</code> 首先在 Dom 线程中创建 JS Root 对应的 Component，然后会将 JS Root 添加到 <code>WXSDKInstance</code> 作为 GodCom 的子节点，从而生成 Component 树的最顶端。生成 Component 树后，将 createBody 任务 post 到 UI 线程，由<code>RenderStatement</code> 创建 <code>WXSDKInstance</code> 的 Rootview，并通过 onViewCreated 回调给 WXSDKInstance 的上下文。</li>
<li>addElement：首先，<code>DomStatement</code> 在 Dom 线程中创建 DomObject 和对应的 Component 实例，加入 Dom 树和 Component 树；然后将 addElement 任务 post 到 UI 线程，<code>RenderStatement</code> 会触发 Component 完成以下任务： createView（初始化 Component 承载的 View）、applyLayoutAndEvent（触发 setLayout 和 setPadding、绑定 Event）、bindData（给 View 设置 style、attr）、addChild（将 View 加入 View 树）</li>
<li>removeElement：是 addElement 的逆向操作，将 View、Component、DomObject 分别从各自的树中删除，并销毁数据回收资源。</li>
<li>moveElement：将 View、Component、DomObject 在树中移动位置，move 操作最终被拆分成一次 remove 操作和一次 add 操作。</li>
<li>addEvent：绑定事件。</li>
<li>removeEvent：撤销事件绑定。</li>
<li>updateAttrs：当结点 attr 被改变时，会触发 updateAttrs，最终会触发 <code>WXComponent</code> 中的 updateProperties 刷新 UI。</li>
<li>updateStyle：与 updateAttrs 类似。</li>
<li>createFinish：JsFramework 将所有渲染指令都发出后，会触发 createFinish，最后会触发 <code>onRenderSuccess</code> 回调。</li>
<li>updateFinish：JsFramework 将所有 update 指令发出后，会触发 updateFinish，最后会触发 <code>onUpdateFinish</code> 回调。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      介绍 Weex 里面比较重要的几个类
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Weex 源码研究 -- 序言</title>
    <link href="http://yoursite.com/2018/03/02/open-source-weex-android-introduction/"/>
    <id>http://yoursite.com/2018/03/02/open-source-weex-android-introduction/</id>
    <published>2018-03-02T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Weex-简介"><a href="#Weex-简介" class="headerlink" title="Weex 简介"></a>Weex 简介</h2><p>一套构建高性能、可扩展的原生应用跨平台开发方案。<br>Weex V8 引擎现在也已经开源。<br><a href="http://weex.apache.org/cn/index.html" target="_blank" rel="external">Weex 官网地址</a><br><a href="https://github.com/apache/incubator-weex/" target="_blank" rel="external">Weex 源码</a><br><a href="https://github.com/alibaba/weex_js_engine" target="_blank" rel="external">V8 引擎库 Github 地址</a></p>
<h2 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/apache/incubator-weex.git weex</div></pre></td></tr></table></figure>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">├── weex</div><div class="line">    ├── android</div><div class="line">        ├── sdk</div><div class="line">        ├── commons</div><div class="line">        └── playground</div><div class="line">    ├── ios</div><div class="line">    ├── runtime</div><div class="line">    ├── packages</div><div class="line">    ├── scripts</div><div class="line">    ├── pre-build</div><div class="line">    ├── bin</div><div class="line">    ├── build</div><div class="line">    ├── examples</div><div class="line">    ├── test</div><div class="line">    └── doc</div></pre></td></tr></table></figure>
<p>打开 Android Studio，导入 android 目录下的源码，发现会有三个 Module：</p>
<ul>
<li>weex_sdk：lib Module，顾名思义，就是 weex 的 Android sdk 源码。</li>
<li>commons：lib Module，在 playground Module 中用到的通用工具代码。</li>
<li>playground：app Module，Weex 官方的 Demo，展示了一些 Weex 教程、Weex 实例以及一些 Weex 资讯。</li>
</ul>
<p>现在你就可以尽情地研究 Weex 源码了，后面我的一系列博客也会进行一些 Weex 源码（源码的 Weex SDK Version 是基于0.17.0，JS Framework 是基于 0.23.9， 平台是基于 Android）的分析，欢迎大家关注。</p>
]]></content>
    
    <summary type="html">
    
      Weex 的一些简单介绍和源码目录结构
    
    </summary>
    
      <category term="Weex" scheme="http://yoursite.com/categories/Weex/"/>
    
    
      <category term="Weex" scheme="http://yoursite.com/tags/Weex/"/>
    
  </entry>
  
  <entry>
    <title>Python实战 -- 网络爬虫之解析爱奇艺视频</title>
    <link href="http://yoursite.com/2018/02/20/python-practice-web-crawler-iqiyi/"/>
    <id>http://yoursite.com/2018/02/20/python-practice-web-crawler-iqiyi/</id>
    <published>2018-02-20T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说到 Python 实战示例，肯定不能不提网络爬虫，Python 简介的语法和强大的数据处理能力以及一些成熟的框架成为做爬虫项目工程师的最爱，那么本篇博客就介绍利用 Python 来解析视频网站视频源播放地址。<br>说到这个就再顺便介绍一下 Kodi，其实就是 XBMC 的前身，我最早接触 Python 其实也是缘由一个 关于 XBMC 的项目，Kodi的很多插件就是用 Python 来写的，本篇博客的爱奇艺视频解析原理也是参考了 Kodi 的插件，为了便于理解，做了一些简化，只保留了一些基本的功能。<br>大家可以参考这个开源的 <a href="https://github.com/taxigps/xbmc-addons-chinese" target="_blank" rel="external">Kodi插件</a>。<br>前面我也写过一片关于如何分析爱奇艺视频播放地址的文章，大家也可以参考一下<a href="https://blog.csdn.net/heqiangflytosky/article/details/8931905" target="_blank" rel="external">XBMC视频插件开发系列–网页数据解析</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>废话不多说，现在开始进入正题。<br>做爬虫，网络请求是必不可少的，那么现在我们就先写一个网络数据请求的方法出来。</p>
<h3 id="网络请求方法"><a href="#网络请求方法" class="headerlink" title="网络请求方法"></a>网络请求方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def getHttpData(url):</div><div class="line">    req = urllib2.Request(url)</div><div class="line"></div><div class="line">    try:</div><div class="line">        reponse = urllib2.urlopen(req)</div><div class="line">        httpData = reponse.read()</div><div class="line">    except:</div><div class="line">        print &quot;get http data error&quot;</div><div class="line">        return &quot;&quot;</div><div class="line"></div><div class="line">    return httpData</div></pre></td></tr></table></figure>
<p>用百度主页来测试一下，OK，可以抓取到数据。</p>
<h3 id="获取分类列表"><a href="#获取分类列表" class="headerlink" title="获取分类列表"></a>获取分类列表</h3><p>我们进入<a href="http://www.iqiyi.com/" target="_blank" rel="external">爱奇艺视频主页</a>，我们会看到视频分类列表，点击这个列表，比如电影，就进入电影的分类页面，这个时候再点击一个检索条件，比如近期热门，就进入了分类检索页面。那么我们的解析工作也就从这个页面开始。<br>首先我们点击电影，发现网址变为：<a href="http://list.iqiyi.com/www/1/----------------iqiyi--.html。" target="_blank" rel="external">http://list.iqiyi.com/www/1/----------------iqiyi--.html。</a><br>再点击电影频道下方的免费分类：<a href="http://list.iqiyi.com/www/1/----------0---11-1-1-iqiyi--.html。" target="_blank" rel="external">http://list.iqiyi.com/www/1/----------0---11-1-1-iqiyi--.html。</a><br>再点击电视剧频道：<a href="http://list.iqiyi.com/www/2/----------------iqiyi--.html。" target="_blank" rel="external">http://list.iqiyi.com/www/2/----------------iqiyi--.html。</a><br>多点击几个你就会得到这样的规律：<br>频道对应的是 <a href="http://list.iqiyi.com/www/" target="_blank" rel="external">http://list.iqiyi.com/www/</a>&lt;频道&gt;/—————-iqiyi–.html，后面的 - 分割的各种检索条件，比如资费、地区和类型等等。<br>通过这种方式我们可以把频道对应的频道ID、排序方式ID和付费类型ID给整理好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CHANNEL_LIST = [[&apos;电影&apos;, &apos;1&apos;], [&apos;电视剧&apos;, &apos;2&apos;], [&apos;纪录片&apos;, &apos;3&apos;], [&apos;动漫&apos;, &apos;4&apos;], [&apos;音乐&apos;, &apos;5&apos;], [&apos;综艺&apos;, &apos;6&apos;], [&apos;娱乐&apos;, &apos;7&apos;],[&apos;旅游&apos;, &apos;9&apos;], [&apos;片花&apos;, &apos;10&apos;], [&apos;教育&apos;, &apos;12&apos;], [&apos;时尚&apos;, &apos;13&apos;]]</div><div class="line">ORDER_LIST = [[&apos;4&apos;, &apos;更新时间&apos;], [&apos;11&apos;, &apos;热门&apos;]]</div><div class="line">PAYTYPE_LIST = [[&apos;&apos;, &apos;全部影片&apos;], [&apos;0&apos;, &apos;免费影片&apos;], [&apos;1&apos;, &apos;会员免费&apos;], [&apos;2&apos;, &apos;付费点播&apos;]]</div></pre></td></tr></table></figure>
<p>那么就可以把获取视频类型的方法给写出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def rootList():</div><div class="line">    for name, id in CHANNEL_LIST:</div><div class="line">        u = sys.argv[0] + &quot;?mode=1&amp;name=&quot; + urllib.quote_plus(name) + &quot;&amp;id=&quot; + urllib.quote_plus(</div><div class="line">            id) + &quot;&amp;cat=&quot; + urllib.quote_plus(&quot;&quot;) + &quot;&amp;area=&quot; + urllib.quote_plus(&quot;&quot;) + &quot;&amp;year=&quot; + urllib.quote_plus(</div><div class="line">            &quot;&quot;) + &quot;&amp;order=&quot; + urllib.quote_plus(&quot;11&quot;) + &quot;&amp;page=&quot; + urllib.quote_plus(</div><div class="line">            &quot;1&quot;) + &quot;&amp;paytype=&quot; + urllib.quote_plus(&quot;0&quot;)</div><div class="line">        print name</div><div class="line">        print u</div></pre></td></tr></table></figure>
<p>通过这个方法，组装了各个分类视频需要的一些参数，这里把他们打印出来，根据需要再调用下面的方法获取各个视频。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">电影</div><div class="line">/Users/*****/iqiyi_custom.py?mode=1&amp;name=%E7%94%B5%E5%BD%B1&amp;id=1&amp;cat=&amp;area=&amp;year=&amp;order=11&amp;page=1&amp;paytype=0</div><div class="line">电视剧</div><div class="line">/Users/*****/iqiyi_custom.py?mode=1&amp;name=%E7%94%B5%E8%A7%86%E5%89%A7&amp;id=2&amp;cat=&amp;area=&amp;year=&amp;order=11&amp;page=1&amp;paytype=0</div><div class="line">......</div></pre></td></tr></table></figure>
<h3 id="获取视频列表"><a href="#获取视频列表" class="headerlink" title="获取视频列表"></a>获取视频列表</h3><p>有了视频分类列表，那么下一步就是获取你需要的视频列表以及每个视频所对应的播放页面地址了，先看代码吧，这里时主要来获取电影分类的，解析原理请看代码中的注释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#         id   c1   c2   c3   c4   c5     c11  c12   c14</span></div><div class="line"><span class="comment"># 电影     1 area  cat                paytype year order</span></div><div class="line"><span class="comment"># 电视剧   2 area  cat                paytype year order</span></div><div class="line"><span class="comment"># 纪录片   3  cat                     paytype      order</span></div><div class="line"><span class="comment"># 动漫     4 area  cat  ver  age      paytype      order</span></div><div class="line"><span class="comment"># 音乐     5 area lang       cat  grp paytype      order</span></div><div class="line"><span class="comment"># 综艺     6 area  cat                paytype      order</span></div><div class="line"><span class="comment"># 娱乐     7       cat area           paytype      order</span></div><div class="line"><span class="comment"># 旅游     9  cat area                paytype      order</span></div><div class="line"><span class="comment"># 片花    10      area       cat      paytype      order</span></div><div class="line"><span class="comment"># 教育    12            cat           paytype      order</span></div><div class="line"><span class="comment"># 时尚    13                      cat paytype      order</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">progList</span><span class="params">(name, id, page, cat, area, year, order, paytype)</span>:</span></div><div class="line">    c1 = <span class="string">''</span></div><div class="line">    c2 = <span class="string">''</span></div><div class="line">    c3 = <span class="string">''</span></div><div class="line">    c4 = <span class="string">''</span></div><div class="line">    <span class="keyword">if</span> id == <span class="string">'7'</span>:  <span class="comment"># 娱乐</span></div><div class="line">        c3 = area</div><div class="line">    <span class="keyword">elif</span> id <span class="keyword">in</span> (<span class="string">'9'</span>, <span class="string">'10'</span>):  <span class="comment"># 旅游&amp;片花</span></div><div class="line">        c2 = area</div><div class="line">    <span class="keyword">elif</span> id != <span class="string">'3'</span>:  <span class="comment"># 非纪录片</span></div><div class="line">        c1 = area</div><div class="line">    <span class="keyword">if</span> id <span class="keyword">in</span> (<span class="string">'3'</span>, <span class="string">'9'</span>):  <span class="comment"># 纪录片&amp;旅游</span></div><div class="line">        c1 = cat</div><div class="line">    <span class="keyword">elif</span> id <span class="keyword">in</span> (<span class="string">'5'</span>, <span class="string">'10'</span>):  <span class="comment"># 音乐&amp;片花</span></div><div class="line">        c4 = cat</div><div class="line">    <span class="keyword">elif</span> id == <span class="string">'12'</span>:  <span class="comment"># 教育</span></div><div class="line">        c3 = cat</div><div class="line">    <span class="keyword">elif</span> id == <span class="string">'13'</span>:  <span class="comment"># 时尚</span></div><div class="line">        c5 = cat</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        c2 = cat</div><div class="line">    <span class="comment"># 根据分类信息组装url</span></div><div class="line">    url = <span class="string">'http://list.iqiyi.com/www/'</span> + id + <span class="string">'/'</span> + c1 + <span class="string">'-'</span> + c2 + <span class="string">'-'</span> + c3 + <span class="string">'-'</span> + c4 + <span class="string">'-------'</span> + \</div><div class="line">          paytype + <span class="string">'-'</span> + year + <span class="string">'--'</span> + order + <span class="string">'-'</span> + page + <span class="string">'-1-iqiyi--.html'</span></div><div class="line">    <span class="keyword">print</span> url</div><div class="line">    currpage = int(page)</div><div class="line">    <span class="comment"># 抓取网页数据</span></div><div class="line">    link = getHttpData(url)</div><div class="line">    <span class="comment"># 根据 data-key=&lt;数字&gt; 这个标记字符串来获取页数，匹配出来多少项就有多少页</span></div><div class="line">    match1 = re.compile(<span class="string">'data-key="([0-9]+)"'</span>).findall(link)</div><div class="line">    <span class="keyword">if</span> len(match1) == <span class="number">0</span>:</div><div class="line">        totalpages = <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        totalpages = int(match1[len(match1) - <span class="number">1</span>])</div><div class="line"></div><div class="line">    <span class="comment"># &lt;div class="wrapper-piclist 和 &lt;!-- 页码 开始 --&gt; 中间的内容是有关视频列表的内容，用正则匹配获取相关内容</span></div><div class="line">    match = re.compile(<span class="string">'&lt;div class="wrapper-piclist"(.+?)&lt;!-- 页码 开始 --&gt;'</span>, re.DOTALL).findall(link)</div><div class="line">    <span class="keyword">if</span> match:</div><div class="line">        <span class="comment"># 匹配前面内容中的 &lt;li&gt; &lt;/li&gt;列表项，匹配多少项代表当前页有多少个视频</span></div><div class="line">        <span class="comment"># 正则表达式里面的 &lt;li[^&gt;]*&gt; 中[^&gt;]*非&gt;字符的0个或多个字符，防止&lt;li&gt;标签内带一些属性值</span></div><div class="line">        match = re.compile(<span class="string">'&lt;li[^&gt;]*&gt;(.+?)&lt;/li&gt;'</span>, re.DOTALL).findall(match[<span class="number">0</span>])</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">'-------'</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(match)):</div><div class="line">        <span class="comment"># 匹配alt=""冒号内的字符串，代码视频名称</span></div><div class="line">        p_name = re.compile(<span class="string">'alt="(.+?)"'</span>).findall(match[i])[<span class="number">0</span>]</div><div class="line">        <span class="comment"># 匹配src = ""冒号内的字符串，代表视频海报地址，\s* 代表0个或多个空白字符</span></div><div class="line">        p_thumb = re.compile(<span class="string">'src\s*=\s*"(.+?)"'</span>).findall(match[i])[<span class="number">0</span>]</div><div class="line">        <span class="comment"># 匹配href="([^"]*)"冒号内非"的0个或多个字符串，代表视频的播放界面，这个是后面解析视频播放地址的基础</span></div><div class="line">        p_id = re.compile(<span class="string">'href="([^"]*)"'</span>).search(match[i]).group(<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="comment"># 根据 data-qidanadd-episode 是否为1来判断是否是多集的影视剧</span></div><div class="line">            p_episode = re.compile(<span class="string">'data-qidanadd-episode="(\d)"'</span>).search(match[i]).group(<span class="number">1</span>) == <span class="string">'1'</span></div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            p_episode = <span class="keyword">False</span></div><div class="line">        <span class="comment"># 匹配 &lt;span class="icon-vInfo"&gt; 和 &lt;/span&gt;中间的内容</span></div><div class="line">        match1 = re.compile(<span class="string">'&lt;span class="icon-vInfo"&gt;([^&lt;]+)&lt;/span&gt;'</span>).search(match[i])</div><div class="line">        <span class="keyword">if</span> match1:</div><div class="line">            <span class="comment"># 去掉匹配内容的空格</span></div><div class="line">            msg = match1.group(<span class="number">1</span>).strip()</div><div class="line">            <span class="keyword">if</span> (msg.find(<span class="string">'更新至'</span>) == <span class="number">0</span>) <span class="keyword">or</span> (msg.find(<span class="string">'共'</span>) == <span class="number">0</span>):</div><div class="line">                <span class="comment"># 如果内容里面有'更新至' 或者 '共' 这样字符，表示是连续剧</span></div><div class="line">                p_episode = <span class="keyword">True</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> p_episode:</div><div class="line">            <span class="comment"># 如果是连续剧 mode 设置为2</span></div><div class="line">            mode = <span class="number">2</span></div><div class="line">            <span class="comment"># 获取视频id</span></div><div class="line">            p_id = re.compile(<span class="string">'data-qidanadd-albumid="(\d+)"'</span>).search(match[i]).group(<span class="number">1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="comment"># 否则 mode 设置为3，进入progList 方法</span></div><div class="line">            mode = <span class="number">3</span></div><div class="line">        <span class="comment"># 组装url</span></div><div class="line">        u = sys.argv[<span class="number">0</span>] + <span class="string">"?mode="</span> + str(mode) + <span class="string">"&amp;name="</span> + urllib.quote_plus(p_name) + <span class="string">"&amp;id="</span> + urllib.quote_plus(</div><div class="line">            p_id) + <span class="string">"&amp;thumb="</span> + urllib.quote_plus(p_thumb)</div><div class="line">        <span class="keyword">print</span> p_name</div><div class="line">        <span class="keyword">print</span> u</div></pre></td></tr></table></figure>
<p>调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">name = &apos;电影&apos;</div><div class="line">id = &apos;1&apos;</div><div class="line">cat = &apos;&apos;</div><div class="line">area = &apos;&apos;</div><div class="line">year = &apos;&apos;</div><div class="line">order = &apos;11&apos;</div><div class="line">page = &apos;1&apos;</div><div class="line">paytype = &apos;0&apos;</div><div class="line"></div><div class="line">print name, id, page, cat, area, year, order, paytype</div><div class="line">progList(name, id, page, cat, area, year, order, paytype)</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">反转人生</div><div class="line">/Users/****/iqiyi_custom.py?mode=3&amp;name=%E5%8F%8D%E8%BD%AC%E4%BA%BA%E7%94%9F&amp;id=http%3A%2F%2Fwww.iqiyi.com%2Fv_19rr7ph8kw.html%23vfrm%3D2-4-0-1&amp;thumb=%2F%2Fpic9.qiyipic.com%2Fimage%2F20180220%2Fbe%2F7a%2Fv_112880060_m_601_m2_180_236.jpg</div><div class="line">密战</div><div class="line">/Users/****/iqiyi_custom.py?mode=3&amp;name=%E5%AF%86%E6%88%98&amp;id=http%3A%2F%2Fwww.iqiyi.com%2Fv_19rrebyuec.html%23vfrm%3D2-4-0-1&amp;thumb=%2F%2Fpic4.qiyipic.com%2Fimage%2F20180220%2F38%2F76%2Fv_114269181_m_601_m2_180_236.jpg</div><div class="line">......</div></pre></td></tr></table></figure>
<h3 id="获取视频播放地址"><a href="#获取视频播放地址" class="headerlink" title="获取视频播放地址"></a>获取视频播放地址</h3><p>通过上一个方法我们可以得到一个视频列表以及该视频的播放页面地址，这里我们就选择《密战》这部电影来介绍吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">def getVMS(tvid, vid):</div><div class="line">    t = int(time.time() * 1000)</div><div class="line">    src = &apos;76f90cbd92f94a2e925d83e8ccd22cb7&apos;</div><div class="line">    key = &apos;d5fb4bd9d50c4be6948c97edd7254b0e&apos;</div><div class="line">    sc = hashlib.md5(str(t) + key + vid).hexdigest()</div><div class="line">    vmsreq = &apos;http://cache.m.iqiyi.com/tmts/&#123;0&#125;/&#123;1&#125;/?t=&#123;2&#125;&amp;sc=&#123;3&#125;&amp;src=&#123;4&#125;&apos;.format(tvid, vid, t, sc, src)</div><div class="line">    print &apos;vms地址&apos;</div><div class="line">    print vmsreq</div><div class="line">    return simplejson.loads(getHttpData(vmsreq))</div><div class="line"></div><div class="line">def PlayVideo(name, id, thumb):</div><div class="line">    id = id.split(&apos;,&apos;)</div><div class="line">    if len(id) == 1:</div><div class="line">        try:</div><div class="line">            if (&quot;http:&quot; in id[0]):</div><div class="line">                link = getHttpData(id[0])</div><div class="line">                tvId = re.compile(&apos;data-player-tvid=&quot;(.+?)&quot;&apos;, re.DOTALL).findall(link)[0]</div><div class="line">                videoId = re.compile(&apos;data-player-videoid=&quot;(.+?)&quot;&apos;, re.DOTALL).findall(link)[0]</div><div class="line">            else:</div><div class="line">                url = &apos;http://cache.video.qiyi.com/avlist/%s/&apos; % (id[0])</div><div class="line">                link = getHttpData(url)</div><div class="line">                data = link[link.find(&apos;=&apos;) + 1:]</div><div class="line">                json_response = simplejson.loads(data)</div><div class="line">                tvId = str(json_response[&apos;data&apos;][&apos;vlist&apos;][0][&apos;id&apos;])</div><div class="line">                videoId = json_response[&apos;data&apos;][&apos;vlist&apos;][0][&apos;vid&apos;].encode(&apos;utf-8&apos;)</div><div class="line">        except:</div><div class="line">            print &apos;未能获取视频地址&apos;</div><div class="line">            return</div><div class="line">    else:</div><div class="line">        tvId = id[0]</div><div class="line">        videoId = id[1]</div><div class="line"></div><div class="line">    # 根据一定规则获取视频流信息</div><div class="line">    info = getVMS(tvId, videoId)</div><div class="line">    if info[&quot;code&quot;] != &quot;A00000&quot;:</div><div class="line">        print &apos;无法播放此视频&apos;</div><div class="line">        return</div><div class="line"></div><div class="line">    vs = info[&quot;data&quot;][&quot;vidl&quot;]</div><div class="line">    sel = selResolution([x[&apos;vd&apos;] for x in vs])</div><div class="line">    if sel == -1:</div><div class="line">        return</div><div class="line">    # 根据分辨率获取对应地址</div><div class="line">    video_links = vs[sel][&quot;m3u&quot;]</div><div class="line"></div><div class="line">    print &apos;视频播放url&apos;</div><div class="line">    print video_links</div></pre></td></tr></table></figure>
<p>这里获得的url<code>http://cache.m.iqiyi.com/mus/870139400/ab59ce8ca82428c9a62cbaf9596d061c/afbe8fd3d73448c9//20171214/02/26/28e78579e4bfa8dcb7266c0f7487670a.m3u8?qd_originate=tmts_py&amp;tvid=870139400&amp;bossStatus=0&amp;qd_vip=0&amp;px=&amp;qd_src=3_31_312&amp;prv=&amp;previewType=&amp;previewTime=&amp;from=&amp;qd_time=1521815439747&amp;qd_p=0e7bff72&amp;qd_asc=2d335d24c5a9412e7da82ee3e003155c&amp;qypid=870139400_04022000001000000000_4&amp;qd_k=cd5ab91d76256006d732d157ce8ee616&amp;isdol=0&amp;code=2&amp;qd_s=otv&amp;vf=5299931f645288f5664953a7f30d65ea&amp;np_tag=nginx_part_tag</code>就是视频地址的url，根据这个url取得数据是m3u8格式的播放地址。这里可能要根据所使用播放器的m3u8的支持形式做一些转化。<br>其实这些分段的地址单个拿出来都是可以播放的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://dx.data.video.qiyi.com/videos/v0/20171214/02/26/d2c83af6c58ccbd91525ef8eee950886.ts?qdv=1&amp;qypid=870139400_04022000001000000000_4&amp;start=0&amp;end=334466&amp;hsize=2161&amp;tag=0&amp;v=&amp;contentlength=285384&amp;qd_uid=&amp;qd_vip=0&amp;qd_src=3_31_312&amp;qd_tm=1521816060630&amp;qd_ip=0e7bff72&amp;qd_p=0e7bff72&amp;qd_k=95668376716c9dcf32e2fbd6597c6f40&amp;sgti=&amp;dfp=&amp;qd_sc=947aee71a7bc4e65d241aeb5a4657439</div><div class="line">······</div></pre></td></tr></table></figure>
<p>好了，关于爱奇艺视频爬虫就介绍到这里。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/taxigps/xbmc-addons-chinese" target="_blank" rel="external">https://github.com/taxigps/xbmc-addons-chinese</a></p>
]]></content>
    
    <summary type="html">
    
      介绍使用 Python 来抓取爱奇艺视频网页内容来解析视频播放地址的方法
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android Architecture Components -- Room</title>
    <link href="http://yoursite.com/2017/12/02/android-architecture-components-room/"/>
    <id>http://yoursite.com/2017/12/02/android-architecture-components-room/</id>
    <published>2017-12-02T02:00:00.000Z</published>
    <updated>2018-03-11T13:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://developer.android.com/training/data-storage/room/index.html" target="_blank" rel="external">官方文档</a><br>首先来介绍一下 Google 推出的 Android 架构组件（Architecture Components），测试版组件 Google 2017 IO 大会上发布，1.0 稳定版已经于2017年11月07正式推出。为 App 开发构架提供指南，并为常见任务，如生命周期管理、数据持久性等提供了一系列库。有了这些基础组件的帮助，开发者能够使用更少的样板代码写出模块化 App，将精力用于创新而非重复体力劳动。</p>
<p>Room 相当于一个 ORM 框架，使用他能帮助程序员方便快捷地实现数据存储功能。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h3><ul>
<li>数据库（Database）：你可以使用该组件创建数据库的持有者。该注解定义了实体列表，该类的内容定义了数据库中的 DAO 列表。这也是访问底层连接的主要入口点。注解类应该是抽象的并且扩展自 <code>RoomDatabase</code>。在运行时，你可以通过调用 <code>Room.databaseBuilder()</code> 或者 <code>Room.inMemoryDatabaseBuilder()</code> 获取实例。</li>
<li>实体（Entity）：这个组件代表了持有数据库表记录的类。对每种实体来说，创建了一个数据库表来持有所有项。你必须通过 Database中 的 <code>entities</code> 数组来引用实体类。实体的每个成员变量都被持久化在数据库中，除非你注解其为 <code>@Ignore</code>。</li>
<li>数据访问对象（DAO）：这个组件代表了作为 DAO 的类或者接口。DAO 是 Room 的主要组件，负责定义访问数据库的方法。被注解 <code>@Database</code> 的类必须包含一个无参数的抽象方法并返回被 <code>@Dao</code> 注解的类型。当编译时生成代码时，Room 会创建该类的实现。</li>
</ul>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>在 build.gradle 中添加一下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">        maven &#123; url &apos;https://maven.google.com&apos; &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dependencies &#123;</div><div class="line">    implementation &quot;android.arch.persistence.room:runtime:1.0.0&quot;</div><div class="line">    annotationProcessor &quot;android.arch.persistence.room:compiler:1.0.0&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Database(entities = &#123;User.class&#125;, version = 1, exportSchema = false)</div><div class="line">public abstract class AppDatabase extends RoomDatabase &#123;</div><div class="line">    public abstract UserDao userDao();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">@Entity(tableName = &quot;user&quot;)</div><div class="line">public class User &#123;</div><div class="line">    @PrimaryKey</div><div class="line">    private int uid;</div><div class="line">    @ColumnInfo(name = &quot;first_name&quot;)</div><div class="line">    private String firstName;</div><div class="line">    @ColumnInfo(name = &quot;last_name&quot;)</div><div class="line">    private String lastName;</div><div class="line">    @Ignore</div><div class="line">    Bitmap picture;//不进行持久化</div><div class="line"></div><div class="line">    public int getUid() &#123;</div><div class="line">        return uid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUid(int uid) &#123;</div><div class="line">        this.uid = uid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getFirstName() &#123;</div><div class="line">        return firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setFirstName(String firstName) &#123;</div><div class="line">        this.firstName = firstName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLastName() &#123;</div><div class="line">        return lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLastName(String lastName) &#123;</div><div class="line">        this.lastName = lastName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Bitmap getPicture() &#123;</div><div class="line">        return picture;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPicture(Bitmap picture) &#123;</div><div class="line">        this.picture = picture;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当一个类被 <code>@Entity</code> 注解，并被 <code>@Database</code> 注解的 <code>entities</code> 属性引用时，Room 为这个实体在数据库中创建一个表。<br>默认情况，Room 为实体类的每个成员变量创建一个列。如果一个实体类的某个成员变量不想被持久化，你可以使用 <code>Ignore</code> 注解标记。<br>为了持久化成员变量，Room 必须可以访问它。你可以使成员变量是公共的，或者提供 <code>getter和setter</code> 方法。如果你使用 <code>getter/setter</code> 方法，请记住它们在 Room 中遵循 Java Beans 的概念。<br>默认情况下，Room 使用类名作为数据库表的表名。如果你想要数据库表有一个其他的名字，设置 <code>@Entity</code> 注解的 <code>tableName</code> 属性即可。<br>注意：SQLite中的表名是大小写敏感的。<br>和 <code>tablename</code> 属性相似，Room 使用成员名作为列名，如果你想要改变类名，在成员上添加 <code>@ColumnInfo</code> 注解并设置 <code>name</code> 即可。</p>
<h3 id="数据访问对象"><a href="#数据访问对象" class="headerlink" title="数据访问对象"></a>数据访问对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@Dao</div><div class="line">public interface UserDao &#123;</div><div class="line">    @Query(&quot;SELECT * FROM user&quot;)</div><div class="line">    List&lt;User&gt; getAll();</div><div class="line"></div><div class="line">    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)</div><div class="line">    List&lt;User&gt; loadAllByIds(int[] userIds);</div><div class="line"></div><div class="line">    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot;</div><div class="line">            + &quot;last_name LIKE :last LIMIT 1&quot;)</div><div class="line">    User findByName(String first, String last);</div><div class="line"></div><div class="line">    @Insert</div><div class="line">    void insertAll(User... users);</div><div class="line"></div><div class="line">    @Delete</div><div class="line">    void delete(User ... user);</div><div class="line"></div><div class="line">    @Update</div><div class="line">    void update(User... user);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public DBManager(Context context) &#123;</div><div class="line">    mDatabase = Room.databaseBuilder(context.getApplicationContext(),</div><div class="line">            AppDatabase.class, &quot;users&quot;).build();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过程中如果出现下面的警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:(11, 17) 警告: Schema export directory is not provided to the annotation processor so we cannot export the schema. You can either provide `room.schemaLocation` annotation processor argument OR set exportSchema to false.</div></pre></td></tr></table></figure>
<p>解决办法：<br>在 <code>AppDatabase</code> 中添加 <code>exportSchema = false</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Database(entities = &#123;User.class&#125;, version = 1, exportSchema = false)</div><div class="line">public abstract class AppDatabase extends RoomDatabase &#123;</div><div class="line">    public abstract UserDao userDao();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数据库升级"><a href="#数据库升级" class="headerlink" title="数据库升级"></a>数据库升级</h3><p>比如我们想在数据库中新加一个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class User &#123;</div><div class="line">    ...</div><div class="line">    @ColumnInfo(name = &quot;is_male&quot;)</div><div class="line">    private boolean isMale;</div><div class="line"></div><div class="line">    private String address;</div><div class="line">    ...</div><div class="line"></div><div class="line">    public boolean isMale() &#123;</div><div class="line">        return isMale;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setMale(boolean male) &#123;</div><div class="line">        isMale = male;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAddress(String address) &#123;</div><div class="line">        this.address = address;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Room允许你编写 <code>Migration</code> 类来保护用户数据。每个 <code>Migration</code> 类指定一个 startVersion 和 endVersion。在运行时，Room 运行每个 <code>Migration</code> 类的 <code>migrate()</code> 方法，使用正确的顺序迁移至数据库的更新版本。<br>然后在创建数据库的时候使用 <code>addMigrations()</code> 方法：<br><code>AppDatabase</code> 中的 <code>version</code> 必须增加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Database(entities = &#123;User.class&#125;, version = 3, exportSchema = false)</div><div class="line">public abstract class AppDatabase extends RoomDatabase &#123;</div><div class="line">    public abstract UserDao userDao();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E AndroidRuntime: java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you&apos;ve changed schema but forgot to update the version number. You can simply fix this by increasing the version number.</div><div class="line">E AndroidRuntime: 	at android.arch.persistence.room.RoomOpenHelper.checkIdentity(RoomOpenHelper.java:119)</div><div class="line">E AndroidRuntime: 	at android.arch.persistence.room.RoomOpenHelper.onOpen(RoomOpenHelper.java:100)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public DBManager(Context context) &#123;</div><div class="line">    mDatabase = Room.databaseBuilder(context.getApplicationContext(),</div><div class="line">            AppDatabase.class, &quot;users&quot;).addMigrations(MIGRATION_1_2,  MIGRATION_2_3).build();</div><div class="line">&#125;</div><div class="line"></div><div class="line">static final Migration MIGRATION_1_2 = new Migration(1, 2) &#123;</div><div class="line">    @Override</div><div class="line">    public void migrate(SupportSQLiteDatabase database) &#123;</div><div class="line">        database.execSQL(&quot;ALTER TABLE user ADD is_male INTEGER NOT NULL DEFAULT 0&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static final Migration MIGRATION_2_3 = new Migration(2, 3) &#123;</div><div class="line">    @Override</div><div class="line">    public void migrate(SupportSQLiteDatabase database) &#123;</div><div class="line">        database.execSQL(&quot;ALTER TABLE user ADD address TEXT&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里添加 <code>boolean</code> 型的字段，SQL 语句必须设置为 <code>NOT NULL</code>，而且要设置默认值，否则会报错。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.jianshu.com/p/587f48dccf0a" target="_blank" rel="external">http://www.jianshu.com/p/587f48dccf0a</a><br><a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="external">https://developer.android.com/topic/libraries/architecture/room.html</a></p>
]]></content>
    
    <summary type="html">
    
      本文介绍 Android 数据库架构组件 Room 的基本使用
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
      <category term="Room" scheme="http://yoursite.com/tags/Room/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2 源码分析二 -- RxJava2</title>
    <link href="http://yoursite.com/2017/11/10/open-source-retrofit-source-code-analysis-rxjava/"/>
    <id>http://yoursite.com/2017/11/10/open-source-retrofit-source-code-analysis-rxjava/</id>
    <published>2017-11-10T02:00:00.000Z</published>
    <updated>2018-05-06T07:22:25.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RxJava的优势这里不再赘述，可以参考我前面 RxJava 系列的博客。Retrofit 2 良好的扩展性使它非常方便的添加了 RxJava 的支持。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>参考我的博客<a href="http://www.heqiangfly.com/2017/10/22/open-source-retrofit-guide/" target="_blank" rel="external">Retrofit 2 使用指南 </a>。<br>和上一篇博客中用内置的适配器不同的是：<br>方法声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface RequestService &#123;</div><div class="line">    ...</div><div class="line">    // 支持RxJava</div><div class="line">    @GET(&quot;heqiang/urls&quot;)</div><div class="line">    Observable&lt;RequestManager.TestBean&gt; getDataRx();</div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = new Retrofit.Builder()</div><div class="line">        .client(client)</div><div class="line">        .baseUrl(&quot;http://172.17.137.69/&quot;)</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        //加入对RxJava2的支持</div><div class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">        .build();</div><div class="line">mMyService = retrofit.create(RequestService.class);</div></pre></td></tr></table></figure>
<p>方法执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public void getDataRx(final CallBack&lt;TestBean&gt; callBack)&#123;</div><div class="line">    mMyService.getDataRx().subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(new Observer&lt;TestBean&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public void onError(Throwable e) &#123;</div><div class="line">                    Log.e(&quot;Test&quot;,&quot;onError&quot;);</div><div class="line">                    callBack.onFail(new Exception(e));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onComplete() &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onSubscribe(Disposable d) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                @Override</div><div class="line">                public void onNext(TestBean testBean) &#123;</div><div class="line">                    Log.e(&quot;Test&quot;,&quot;onNext = &quot;+testBean.toString());</div><div class="line">                    callBack.onSuccess(testBean);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Rxjava 相关代码结构：</p>
<p><img src="/images/open-source-retrofit-source-code-analysis-rxjava/rxjava-classes.png" alt="效果图"></p>
<p>可以看到代码量不是很多。<br><code>RxJava2CallAdapterFactory</code> 和 <code>RxJava2CallAdapter</code> 两个类分别对应上篇博客分析使用内置适配器时的 <code>ExecutorCallAdapterFactory</code> 和 <code>ExecutorCallAdapterFactory.CallAdapter</code> 类，是适配器工厂和适配器类。</p>
<h3 id="RxJava2CallAdapterFactory"><a href="#RxJava2CallAdapterFactory" class="headerlink" title="RxJava2CallAdapterFactory"></a>RxJava2CallAdapterFactory</h3><p>先来看一下适配器工厂类。<br>上面的Demo中通过 <code>Retrofit.Builder()</code> 的 <code>addCallAdapterFactory(RxJava2CallAdapterFactory.create())</code> 方法指定了适配器工厂。<br><code>RxJava2CallAdapterFactory</code> 提供了三个静态的方法生成适配器工厂，它们分别可以生成同步的 <code>Observable</code>、异步的 <code>Observable</code> 以及可以制定线程调度器同步 <code>Observable</code>。<br>不理解没关系，下面会详细介绍他们的区别。<br>先来看一下这三个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 生成同步的 Observable 的适配器工厂</div><div class="line">public static RxJava2CallAdapterFactory create() &#123;</div><div class="line">  return new RxJava2CallAdapterFactory(null, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 生成异步的 Observable 的适配器工厂</div><div class="line">public static RxJava2CallAdapterFactory createAsync() &#123;</div><div class="line">  return new RxJava2CallAdapterFactory(null, true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 生成同步的 Observable 并制定线程调度器的适配器工厂</div><div class="line">@SuppressWarnings(&quot;ConstantConditions&quot;) // Guarding public API nullability.</div><div class="line">public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) &#123;</div><div class="line">  if (scheduler == null) throw new NullPointerException(&quot;scheduler == null&quot;);</div><div class="line">  return new RxJava2CallAdapterFactory(scheduler, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此在动态代理类的 <code>serviceMethod.callAdapter.adapt(okHttpCall)</code> 其实执行的是 <code>RxJava2CallAdapterFactory.get()</code> 方法生成的 <code>RxJava2CallAdapter</code> 对象的 <code>adapt()</code> 方法。<br>我们先来看一下 <code>RxJava2CallAdapterFactory.get()</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">  // 这里的 returnType 指的是请求方法定义的类型，比如 Observable&lt;RequestManager.TestBean&gt;</div><div class="line">  // 获取返回数据类型，比如Call&lt;Requestbody&gt;的Call，Observable&lt;RequestManager.TestBean&gt; 中的 Observable</div><div class="line">  Class&lt;?&gt; rawType = getRawType(returnType);</div><div class="line"></div><div class="line">  if (rawType == Completable.class) &#123;</div><div class="line">    // 当定义的返回值是Completable类时，对于Completable我们前面也介绍过，它的特点是用户只关心 onComplete 事件</div><div class="line">    return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,</div><div class="line">        false, true);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  boolean isFlowable = rawType == Flowable.class;</div><div class="line">  boolean isSingle = rawType == Single.class;</div><div class="line">  boolean isMaybe = rawType == Maybe.class;</div><div class="line">  if (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  boolean isResult = false;</div><div class="line">  boolean isBody = false;</div><div class="line">  Type responseType;</div><div class="line">  if (!(returnType instanceof ParameterizedType)) &#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">  // 获取响应数据类型，即泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody</div><div class="line">  Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType);</div><div class="line">  // 再次获取数据类型，observableType 是 Observable&lt;RequestManager.TestBean&gt; 中的 TestBean，这里还是返回 TestBean</div><div class="line">  Class&lt;?&gt; rawObservableType = getRawType(observableType);</div><div class="line">  if (rawObservableType == Response.class) &#123;</div><div class="line">    if (!(observableType instanceof ParameterizedType)) &#123;</div><div class="line">      throw new IllegalStateException(&quot;Response must be parameterized&quot;</div><div class="line">          + &quot; as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;&quot;);</div><div class="line">    &#125;</div><div class="line">    responseType = getParameterUpperBound(0, (ParameterizedType) observableType);</div><div class="line">  &#125; else if (rawObservableType == Result.class) &#123;</div><div class="line">    if (!(observableType instanceof ParameterizedType)) &#123;</div><div class="line">      throw new IllegalStateException(&quot;Result must be parameterized&quot;</div><div class="line">          + &quot; as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;&quot;);</div><div class="line">    &#125;</div><div class="line">    responseType = getParameterUpperBound(0, (ParameterizedType) observableType);</div><div class="line">    isResult = true;</div><div class="line">  &#125; else &#123;</div><div class="line">    responseType = observableType;</div><div class="line">    isBody = true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,</div><div class="line">      isSingle, isMaybe, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是生成来一个 <code>RxJava2CallAdapter</code> 对象。</p>
<h3 id="RxJava2CallAdapter"><a href="#RxJava2CallAdapter" class="headerlink" title="RxJava2CallAdapter"></a>RxJava2CallAdapter</h3><p>先来看一下构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">RxJava2CallAdapter(Type responseType, @Nullable Scheduler scheduler, boolean isAsync,</div><div class="line">    boolean isResult, boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,</div><div class="line">    boolean isCompletable) &#123;</div><div class="line">  this.responseType = responseType;</div><div class="line">  this.scheduler = scheduler;</div><div class="line">  this.isAsync = isAsync;</div><div class="line">  this.isResult = isResult;</div><div class="line">  this.isBody = isBody;</div><div class="line">  this.isFlowable = isFlowable;</div><div class="line">  this.isSingle = isSingle;</div><div class="line">  this.isMaybe = isMaybe;</div><div class="line">  this.isCompletable = isCompletable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是一些条件的配置。<br>对于这个类重点关注它的 <code>adapt()</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override public Object adapt(Call&lt;R&gt; call) &#123;</div><div class="line">  // 这里根据同步或者异步生成不同的 Observable，后面介绍</div><div class="line">  Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync</div><div class="line">      ? new CallEnqueueObservable&lt;&gt;(call)</div><div class="line">      : new CallExecuteObservable&lt;&gt;(call);</div><div class="line"></div><div class="line">  // 生成不同的 Observable</div><div class="line">  Observable&lt;?&gt; observable;</div><div class="line">  if (isResult) &#123;</div><div class="line">    observable = new ResultObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; else if (isBody) &#123;</div><div class="line">    observable = new BodyObservable&lt;&gt;(responseObservable);</div><div class="line">  &#125; else &#123;</div><div class="line">    observable = responseObservable;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (scheduler != null) &#123;</div><div class="line">    observable = observable.subscribeOn(scheduler);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (isFlowable) &#123;</div><div class="line">    return observable.toFlowable(BackpressureStrategy.LATEST);</div><div class="line">  &#125;</div><div class="line">  if (isSingle) &#123;</div><div class="line">    return observable.singleOrError();</div><div class="line">  &#125;</div><div class="line">  if (isMaybe) &#123;</div><div class="line">    return observable.singleElement();</div><div class="line">  &#125;</div><div class="line">  if (isCompletable) &#123;</div><div class="line">    return observable.ignoreElements();</div><div class="line">  &#125;</div><div class="line">  return RxJavaPlugins.onAssembly(observable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CallEnqueueObservable-和-CallExecuteObservable"><a href="#CallEnqueueObservable-和-CallExecuteObservable" class="headerlink" title="CallEnqueueObservable 和 CallExecuteObservable"></a>CallEnqueueObservable 和 CallExecuteObservable</h3><p>从名字就可以看出来，这两个类分别处理异步和同步的Observable。<br>这里主要看一下这两个类的 <code>subscribeActual()</code> 方法。</p>
<p>CallEnqueueObservable.subscribeActual()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</div><div class="line">  // Since Call is a one-shot type, clone it for each new observer.</div><div class="line">  Call&lt;T&gt; call = originalCall.clone();</div><div class="line">  CallCallback&lt;T&gt; callback = new CallCallback&lt;&gt;(call, observer);</div><div class="line">  observer.onSubscribe(callback);</div><div class="line">  call.enqueue(callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CallExecuteObservable.subscribeActual()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@Override protected void subscribeActual(Observer&lt;? super Response&lt;T&gt;&gt; observer) &#123;</div><div class="line">  // Since Call is a one-shot type, clone it for each new observer.</div><div class="line">  Call&lt;T&gt; call = originalCall.clone();</div><div class="line">  CallDisposable disposable = new CallDisposable(call);</div><div class="line">  observer.onSubscribe(disposable);</div><div class="line"></div><div class="line">  boolean terminated = false;</div><div class="line">  try &#123;</div><div class="line">    Response&lt;T&gt; response = call.execute();</div><div class="line">    if (!disposable.isDisposed()) &#123;</div><div class="line">      observer.onNext(response);</div><div class="line">    &#125;</div><div class="line">    if (!disposable.isDisposed()) &#123;</div><div class="line">      terminated = true;</div><div class="line">      observer.onComplete();</div><div class="line">    &#125;</div><div class="line">  &#125; catch (Throwable t) &#123;</div><div class="line">    Exceptions.throwIfFatal(t);</div><div class="line">    if (terminated) &#123;</div><div class="line">      RxJavaPlugins.onError(t);</div><div class="line">    &#125; else if (!disposable.isDisposed()) &#123;</div><div class="line">      try &#123;</div><div class="line">        observer.onError(t);</div><div class="line">      &#125; catch (Throwable inner) &#123;</div><div class="line">        Exceptions.throwIfFatal(inner);</div><div class="line">        RxJavaPlugins.onError(new CompositeException(t, inner));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实这里主要做了下面几件事：</p>
<ol>
<li>clone了原有的call，因为OkHttp.Call只能使用一次</li>
<li>设置了 CallDisposable，可用于解除订阅</li>
<li>调用 Call 的 execute() 或者 enqueue() 方法。</li>
<li>同步方法可能会调用onNext和onComplete，异步方法设置回调函数，在回调函数中调用这些方法。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      Retrofit 2 中 RxJava2 相关部分源码
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2 源码分析一 -- 数据请求流程解析</title>
    <link href="http://yoursite.com/2017/11/08/open-source-retrofit-source-code-analysis-request/"/>
    <id>http://yoursite.com/2017/11/08/open-source-retrofit-source-code-analysis-request/</id>
    <published>2017-11-08T02:00:00.000Z</published>
    <updated>2018-05-29T02:28:24.836Z</updated>
    
    <content type="html"><![CDATA[<p>分析之前可以参考一下我的前面的博客<a href="http://www.heqiangfly.com/2017/10/22/open-source-retrofit-guide/" target="_blank" rel="external">Retrofit 2 使用指南 </a>，熟悉一下它的基本使用。</p>
<p>本文用到的一些类图</p>
<p><img src="http://www.plantuml.com/plantuml/svg/bP51IWD144NtTOeYgsGHJp18H1HtGiW5ofu_qgJj6RkhHL5FuYbS2zv6l8PT4jlPPZUy-V_NWzvabQJbBj3EQm0ljj0q3bw_tp--tZuNH3ugqY0EV2uXy3CnRv6dCMPqkrF68rnHB5ULFuo-PyJxWeAbfM_4xIta3jyhUYKN96U-tb-fJfOvW8lVdJ4PEkjbgaSlnLNmT3B_PIlDWtdmKKBhjZj_O9Qnagdq2BWLHJKXOzozhDTpdGQFLIBwN-7k-3xJ1h6lJ_43" alt="效果图"></p>
<h1 id="初始化请求流程"><a href="#初始化请求流程" class="headerlink" title="初始化请求流程"></a>初始化请求流程</h1><p>先来看一下如何创建一个请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public interface RequestService &#123;</div><div class="line">    @GET(&quot;hq/urls&quot;)</div><div class="line">    Call&lt;RequestManager.TestBean&gt; getData();</div><div class="line">&#125;</div><div class="line">    ......</div><div class="line">    </div><div class="line">        Retrofit retrofit = new Retrofit.Builder()</div><div class="line">                .client(client)</div><div class="line">                .baseUrl(&quot;http://172.17.137.68/&quot;)</div><div class="line">                .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                //加入对RxJava2的支持</div><div class="line">                //.addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">                .build();</div><div class="line">        mRequestService = retrofit.create(RequestService.class);</div></pre></td></tr></table></figure>
<p>异步请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void getData(CallBack callBack)&#123;</div><div class="line">    Call&lt;TestBean&gt; call = mMyService.getData();</div><div class="line">    call.enqueue(new Callback&lt;TestBean&gt;() &#123;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onResponse(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response) &#123;</div><div class="line">            Log.e(&quot;Test&quot;,&quot;onResponse = &quot;+response.body().toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onFailure(Call&lt;TestBean&gt; call, Throwable t) &#123;</div><div class="line">            Log.e(&quot;Test&quot;,&quot;onFailure = &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public TestBean getDataSync()&#123;</div><div class="line">    Call&lt;TestBean&gt; call = mRequestService.getData();</div><div class="line">    Response&lt;TestBean&gt; data = null;</div><div class="line">    try &#123;</div><div class="line">        data = call.execute();</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return data != null ? data.body() : null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先这里是创建一个 <code>Retrofit</code> 对象，这里用到了建造者模式。<br>那么就先来看一下 <code>Builder().build()</code> 的源码。<br>先来看一下 <code>platform</code> 这个变量，因为后面会用到它。通过 <code>Builder</code> 的构造函数，可以看到它是通过 <code>Platform.get()</code> 来实例化的，在 Android 平台上是一个 <code>Platform.Android</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">public Retrofit build() &#123;</div><div class="line">  //  `baseUrl` 是必须设置的。</div><div class="line">  if (baseUrl == null) &#123;</div><div class="line">    throw new IllegalStateException(&quot;Base URL required.&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // callFactory 是 client() 方法设置的，如果不设置，会生成个默认的 OkHttpClient()。</div><div class="line">  okhttp3.Call.Factory callFactory = this.callFactory;</div><div class="line">  if (callFactory == null) &#123;</div><div class="line">    callFactory = new OkHttpClient();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // callbackExecutor 是callbackExecutor()方法设置的，如果不设置，会添加平台默认的回调执行器</div><div class="line">  Executor callbackExecutor = this.callbackExecutor;</div><div class="line">  if (callbackExecutor == null) &#123;</div><div class="line">    // 这里会返回一个 Android.MainThreadExecutor 对象</div><div class="line">    callbackExecutor = platform.defaultCallbackExecutor();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories);</div><div class="line">  // 这里会把 ExecutorCallAdapterFactory 添加到 adapterFactories 中。这个是 Retrofit 内置的适配器。</div><div class="line">  // callbackExecutor 为请求结果返回后调用客户端回调的执行器</div><div class="line">  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</div><div class="line"></div><div class="line">  // Make a defensive copy of the converters.</div><div class="line">  List&lt;Converter.Factory&gt; converterFactories =</div><div class="line">      new ArrayList&lt;&gt;(1 + this.converterFactories.size());</div><div class="line"></div><div class="line">  // 添加内置转换器</div><div class="line">  converterFactories.add(new BuiltInConverters());</div><div class="line">  converterFactories.addAll(this.converterFactories);</div><div class="line"></div><div class="line">  return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</div><div class="line">      callbackExecutor, validateEagerly);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下 <code>Retrofit.create</code>。<br>这部分是重点，因为请求方法的执行其实就是执行到了这里动态代理对象的 <code>invoke()</code> 方法。后面会分开来介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;</div><div class="line">  // InvocationHandler只能支持interface动态代理，这里检查一下service是否是interface</div><div class="line">  Utils.validateServiceInterface(service);</div><div class="line">  // validateEagerly默认为false，除非通过validateEagerly()方法配置</div><div class="line">  if (validateEagerly) &#123;</div><div class="line">    //这里会提前创建 ServiceMethod</div><div class="line">    eagerlyValidateMethods(service);</div><div class="line">  &#125;</div><div class="line">  // 返回一个动态代理对象，这里是重点</div><div class="line">  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;,</div><div class="line">      new InvocationHandler() &#123;</div><div class="line">        private final Platform platform = Platform.get();</div><div class="line"></div><div class="line">        @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)</div><div class="line">            throws Throwable &#123;</div><div class="line">          // 如果是Object的方法直接执行</div><div class="line">          if (method.getDeclaringClass() == Object.class) &#123;</div><div class="line">            return method.invoke(this, args);</div><div class="line">          &#125;</div><div class="line">          // Android平台这里返回false，如果是平台默认方法，直接执行</div><div class="line">          if (platform.isDefaultMethod(method)) &#123;</div><div class="line">            return platform.invokeDefaultMethod(method, service, proxy, args);</div><div class="line">          &#125;</div><div class="line">          // 创建 ServiceMethod</div><div class="line">          ServiceMethod&lt;Object, Object&gt; serviceMethod =</div><div class="line">              (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</div><div class="line">          // 生成一个 Call 对象，OkHttpCall实现了 Call 接口</div><div class="line">          OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</div><div class="line">          // 调用适配器的adapter生成一个 范型 对象（请求方法定义的返回类型）。</div><div class="line">          return serviceMethod.callAdapter.adapt(okHttpCall);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="执行请求流程"><a href="#执行请求流程" class="headerlink" title="执行请求流程"></a>执行请求流程</h1><p>比如我们Demo中的一个请求方法的执行 <code>mRequestService.getData()</code>，其实执行的方法体就是前面的动态代理对象的 <code>invoke()</code> 方法，返回一个 <code>RequestService</code> 接口中此方法定义的一个范型对象。<br>先来看一下如何生成 <code>ServiceMethod</code>：<br><code>ServiceMethod</code> 和我们前面定义的请求方法是一一对应关系的，每个 Method 对应一个 <code>ServiceMethod</code>。比如就像例子中我们调用 <code>RequestService.getData()</code> 方法就会生成一个对应的 <code>ServiceMethod</code> 对象，保存了 baseUrl、请求参数、请求类型等信息。<br>如果缓存里没有，则新建一个并放入到缓存中。至于这个 <code>ServiceMethod</code> 是我们后面再详细分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</div><div class="line">  ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</div><div class="line">  if (result != null) return result;</div><div class="line"></div><div class="line">  synchronized (serviceMethodCache) &#123;</div><div class="line">    result = serviceMethodCache.get(method);</div><div class="line">    if (result == null) &#123;</div><div class="line">      result = new ServiceMethod.Builder&lt;&gt;(this, method).build();</div><div class="line">      serviceMethodCache.put(method, result);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着会根据 <code>ServiceMethod</code> 对象和参数生成一个 <code>OkHttpCall</code> 对象，然后再根据适配器的 adapter 方法把 <code>OkHttpCall</code> 转化为 <code>ExecutorCallbackCall</code> （使用内置适配器时）。<br>这部分接下来也会详细介绍。</p>
<h2 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h2><p><code>ServiceMethod</code> 方法也比较简单，一些属性包含了一个Http请求的基本信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">final class ServiceMethod&lt;R, T&gt; &#123;</div><div class="line">  // Upper and lower characters, digits, underscores, and hyphens, starting with a character.</div><div class="line">  static final String PARAM = &quot;[a-zA-Z][a-zA-Z0-9_-]*&quot;;</div><div class="line">  static final Pattern PARAM_URL_REGEX = Pattern.compile(&quot;\\&#123;(&quot; + PARAM + &quot;)\\&#125;&quot;);</div><div class="line">  static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);</div><div class="line"></div><div class="line">  final okhttp3.Call.Factory callFactory;</div><div class="line">  final CallAdapter&lt;R, T&gt; callAdapter;</div><div class="line"></div><div class="line">  private final HttpUrl baseUrl;</div><div class="line">  private final Converter&lt;ResponseBody, R&gt; responseConverter;</div><div class="line">  private final String httpMethod;</div><div class="line">  private final String relativeUrl;</div><div class="line">  private final Headers headers;</div><div class="line">  private final MediaType contentType;</div><div class="line">  private final boolean hasBody;</div><div class="line">  private final boolean isFormEncoded;</div><div class="line">  private final boolean isMultipart;</div><div class="line">  private final ParameterHandler&lt;?&gt;[] parameterHandlers;</div><div class="line"></div><div class="line">  ServiceMethod(Builder&lt;R, T&gt; builder) &#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Request toRequest(@Nullable Object... args) throws IOException &#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  R toResponse(ResponseBody body) throws IOException &#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们重点来看一下 <code>ServiceMethod.Builder()</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Builder(Retrofit retrofit, Method method) &#123;</div><div class="line">  this.retrofit = retrofit;</div><div class="line">  this.method = method;</div><div class="line">  this.methodAnnotations = method.getAnnotations();</div><div class="line">  this.parameterTypes = method.getGenericParameterTypes();</div><div class="line">  this.parameterAnnotationsArray = method.getParameterAnnotations();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的构造函数会传入 <code>Retrofit</code> 和 <code>Method</code> 对象作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public ServiceMethod build() &#123;</div><div class="line">  // 获取该方法对应的适配器</div><div class="line">  callAdapter = createCallAdapter();</div><div class="line">  responseType = callAdapter.responseType();</div><div class="line">  ......</div><div class="line">  // 获取该方法对应的转换器</div><div class="line">  responseConverter = createResponseConverter();</div><div class="line"></div><div class="line">  // 解析方法注解，根据方法注解调用不同的方法生成请求参数</div><div class="line">  for (Annotation annotation : methodAnnotations) &#123;</div><div class="line">    parseMethodAnnotation(annotation);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ......</div><div class="line"></div><div class="line">  int parameterCount = parameterAnnotationsArray.length;</div><div class="line">  parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</div><div class="line">  for (int p = 0; p &lt; parameterCount; p++) &#123;</div><div class="line">    Type parameterType = parameterTypes[p];</div><div class="line">    if (Utils.hasUnresolvableType(parameterType)) &#123;</div><div class="line">      ......</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</div><div class="line">    ......</div><div class="line">    // 解析参数</div><div class="line">    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ......</div><div class="line"></div><div class="line">  return new ServiceMethod&lt;&gt;(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先来看一下 <code>build</code> 方法的调用流程（使用内置适配器时）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">├── ServiceMethod.Builder().build()</div><div class="line">    ├── ServiceMethod.Builder().createCallAdapter()</div><div class="line">        ├── Retrofit.callAdapter()</div><div class="line">            ├── Retrofit.nextCallAdapter()</div><div class="line">                ├── ExecutorCallAdapterFactory.get()</div><div class="line">                    └──  new CallAdapter()</div><div class="line">    ├── ServiceMethod.Builder().createResponseConverter()</div><div class="line">    ├── ServiceMethod.Builder().parseMethodAnnotation()</div><div class="line">    └── new ServiceMethod&lt;&gt;(this)</div></pre></td></tr></table></figure>
<h3 id="获取适配器"><a href="#获取适配器" class="headerlink" title="获取适配器"></a>获取适配器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,</div><div class="line">    Annotation[] annotations) &#123;</div><div class="line">  ......</div><div class="line"></div><div class="line">  int start = adapterFactories.indexOf(skipPast) + 1;</div><div class="line">  for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    // 获取可以处理当前请求的适配器</div><div class="line">    CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this);</div><div class="line">    if (adapter != null) &#123;</div><div class="line">      return adapter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ......</div><div class="line">  throw new IllegalArgumentException(builder.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会遍历我们添加的所有适配器，并调用适配器的 <code>get()</code> 方法，这个方法会根据当前请求方法的返回值类型来决定是否处理。<br>这里以内置的适配器来介绍一下：<br>ExecutorCallAdapterFactory.get():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</div><div class="line">  // 这个适配器工厂只处理返回值为 Call 的请求方法</div><div class="line">  if (getRawType(returnType) != Call.class) &#123;</div><div class="line">    return null;</div><div class="line">  &#125;</div><div class="line">  final Type responseType = Utils.getCallResponseType(returnType);</div><div class="line">  // 生成一个 CallAdapter</div><div class="line">  return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</div><div class="line">    @Override public Type responseType() &#123;</div><div class="line">      return responseType;</div><div class="line">    &#125;</div><div class="line">    // 后面在动态代理类里面调用serviceMethod.callAdapter.adapt(okHttpCall)时会生成一个ExecutorCallbackCall对象</div><div class="line">    @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">      return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取转换器"><a href="#获取转换器" class="headerlink" title="获取转换器"></a>获取转换器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">├── ServiceMethod.createResponseConverter()</div><div class="line">    └── Retrofit.responseBodyConverter(Type type, Annotation[] annotations)</div><div class="line">        └── Retrofit.nextResponseBodyConverter()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(</div><div class="line">    @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123;</div><div class="line">  ......</div><div class="line">  int start = converterFactories.indexOf(skipPast) + 1;</div><div class="line">  // 这里遍历所有的转换器，比如我们前面添加了 GsonConverterFactory，那么就有两个转换器，还有个默认的内置转换器 BuiltInConverters</div><div class="line">  // 我们看源码知道BuiltInConverters只处理 ResponseBody 和 Void两种返回结果，Demo中我们自定义RequestManager.TestBean返回结果，肯定是指定 GsonConverterFactory来作为转换器</div><div class="line">  for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</div><div class="line">    Converter&lt;ResponseBody, ?&gt; converter =</div><div class="line">        converterFactories.get(i).responseBodyConverter(type, annotations, this);</div><div class="line">    if (converter != null) &#123;</div><div class="line">      return (Converter&lt;ResponseBody, T&gt;) converter;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ......</div><div class="line">  throw new IllegalArgumentException(builder.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="处理方法注解"><a href="#处理方法注解" class="headerlink" title="处理方法注解"></a>处理方法注解</h3><p>这一部分主要是根据方法注解的类型解析生成 <code>ServiceMethod</code> 的一些属性，比如：<code>httpMethod</code>、<code>hasBody</code> 和 <code>relativeUrl</code> 等。<br><code>ServiceMethod.Builder.parseMethodAnnotation()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">private void parseMethodAnnotation(Annotation annotation) &#123;</div><div class="line">  if (annotation instanceof DELETE) &#123;</div><div class="line">    parseHttpMethodAndPath(&quot;DELETE&quot;, ((DELETE) annotation).value(), false);</div><div class="line">  &#125; else if (annotation instanceof GET) &#123;</div><div class="line">    parseHttpMethodAndPath(&quot;GET&quot;, ((GET) annotation).value(), false);</div><div class="line">  &#125; else if (annotation instanceof HEAD) &#123;</div><div class="line">    parseHttpMethodAndPath(&quot;HEAD&quot;, ((HEAD) annotation).value(), false);</div><div class="line">    if (!Void.class.equals(responseType)) &#123;</div><div class="line">      throw methodError(&quot;HEAD method must use Void as response type.&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125; else if (annotation instanceof PATCH) &#123;</div><div class="line">    ......//省略，具体代码可以看源码</div><div class="line">  &#125; else if (annotation instanceof FormUrlEncoded) &#123;</div><div class="line">    if (isMultipart) &#123;</div><div class="line">      throw methodError(&quot;Only one encoding annotation is allowed.&quot;);</div><div class="line">    &#125;</div><div class="line">    isFormEncoded = true;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) &#123;</div><div class="line">  if (this.httpMethod != null) &#123;</div><div class="line">    throw methodError(&quot;Only one HTTP method is allowed. Found: %s and %s.&quot;,</div><div class="line">        this.httpMethod, httpMethod);</div><div class="line">  &#125;</div><div class="line">  this.httpMethod = httpMethod;</div><div class="line">  this.hasBody = hasBody;</div><div class="line"></div><div class="line">  ......//省略，具体代码可以看源码</div><div class="line"></div><div class="line">  this.relativeUrl = value;</div><div class="line">  this.relativeUrlParamNames = parsePathParameters(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><p>这部分主要针对动态代理类中 <code>OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args)</code> 这段方法的执行。<br>前面我们说过，适配器处理对网络请求（内置适配器是生成的 Call 对象）都是委托给 OkHttpCall 来处理的。<br>先来看一下这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123;</div><div class="line">  private final ServiceMethod&lt;T, ?&gt; serviceMethod;</div><div class="line">  private final @Nullable Object[] args;</div><div class="line"></div><div class="line">  private volatile boolean canceled;</div><div class="line"></div><div class="line">  @GuardedBy(&quot;this&quot;)</div><div class="line">  private @Nullable okhttp3.Call rawCall;</div><div class="line">  @GuardedBy(&quot;this&quot;)</div><div class="line">  private @Nullable Throwable creationFailure; // Either a RuntimeException or IOException.</div><div class="line">  @GuardedBy(&quot;this&quot;)</div><div class="line">  private boolean executed;</div><div class="line"></div><div class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123;</div><div class="line">    this.serviceMethod = serviceMethod;</div><div class="line">    this.args = args;</div><div class="line">  &#125;</div><div class="line">  @Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">    checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">    okhttp3.Call call;</div><div class="line">    Throwable failure;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</div><div class="line">      executed = true;</div><div class="line"></div><div class="line">      call = rawCall;</div><div class="line">      failure = creationFailure;</div><div class="line">      if (call == null &amp;&amp; failure == null) &#123;</div><div class="line">        try &#123;</div><div class="line">          call = rawCall = createRawCall();</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          failure = creationFailure = t;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (failure != null) &#123;</div><div class="line">      callback.onFailure(this, failure);</div><div class="line">      return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (canceled) &#123;</div><div class="line">      call.cancel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    call.enqueue(new okhttp3.Callback() &#123;</div><div class="line">      @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse)</div><div class="line">          throws IOException &#123;</div><div class="line">        Response&lt;T&gt; response;</div><div class="line">        try &#123;</div><div class="line">          response = parseResponse(rawResponse);</div><div class="line">        &#125; catch (Throwable e) &#123;</div><div class="line">          callFailure(e);</div><div class="line">          return;</div><div class="line">        &#125;</div><div class="line">        callSuccess(response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      @Override public void onFailure(okhttp3.Call call, IOException e) &#123;</div><div class="line">        callFailure(e);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callFailure(Throwable e) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onFailure(OkHttpCall.this, e);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      private void callSuccess(Response&lt;T&gt; response) &#123;</div><div class="line">        try &#123;</div><div class="line">          callback.onResponse(OkHttpCall.this, response);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">          t.printStackTrace();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public Response&lt;T&gt; execute() throws IOException &#123;</div><div class="line">    okhttp3.Call call;</div><div class="line"></div><div class="line">    synchronized (this) &#123;</div><div class="line">      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);</div><div class="line">      executed = true;</div><div class="line"></div><div class="line">      if (creationFailure != null) &#123;</div><div class="line">        if (creationFailure instanceof IOException) &#123;</div><div class="line">          throw (IOException) creationFailure;</div><div class="line">        &#125; else &#123;</div><div class="line">          throw (RuntimeException) creationFailure;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      call = rawCall;</div><div class="line">      if (call == null) &#123;</div><div class="line">        try &#123;</div><div class="line">          call = rawCall = createRawCall();</div><div class="line">        &#125; catch (IOException | RuntimeException e) &#123;</div><div class="line">          creationFailure = e;</div><div class="line">          throw e;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (canceled) &#123;</div><div class="line">      call.cancel();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return parseResponse(call.execute());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>execute()</code> 对应的就是同步请求方法。<br>主要来分析一下 <code>enqueue()</code> 方法，这个方法对应的就是异步请求方法。请求加入队列的方法最终也是由 <code>okhttp3.Call</code> 来执行的。那么就要来看一下 <code>okhttp3.Call</code> 是如何生成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private okhttp3.Call createRawCall() throws IOException &#123;</div><div class="line">  // 调用 ServiceMethod.toRequest() 方法生成请求</div><div class="line">  Request request = serviceMethod.toRequest(args);</div><div class="line">  // 生成 okhttp3.Call</div><div class="line">  okhttp3.Call call = serviceMethod.callFactory.newCall(request);</div><div class="line">  if (call == null) &#123;</div><div class="line">    throw new NullPointerException(&quot;Call.Factory returned null.&quot;);</div><div class="line">  &#125;</div><div class="line">  return call;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>serviceMethod.callFactory.newCall(request)</code> 会调用 <code>Retrofit.callFactory</code> 来生成请求，<code>Retrofit.callFactory</code> 是通过 <code>Retrofit.client(OkHttpClient client)</code> 方法来设置的。<br>因此， <code>okhttp3.Call</code> 是最终由 <code>OkHttpClient</code> 来创建的，那么请求的执行也是由 <code>OkHttpClient</code> 来执行的。 </p>
<h2 id="CallAdapter-和-CallAdapter-Factory"><a href="#CallAdapter-和-CallAdapter-Factory" class="headerlink" title="CallAdapter 和 CallAdapter.Factory"></a>CallAdapter 和 CallAdapter.Factory</h2><p><code>CallAdapter</code>是一个接口，前文所说的适配器都是实现了这个接口。<code>ExecutorCallAdapterFactory</code> 的匿名内部类和 <code>RxJava2CallAdapter</code>。<br>这里再来介绍一下 <code>CallAdapter.Factory</code> 类。它是 <code>CallAdapter</code> 的工厂类，是一个抽象类，<code>ExecutorCallAdapterFactory</code> 和 <code>RxJava2CallAdapterFactory</code> 都是继承这个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public interface CallAdapter&lt;R, T&gt; &#123;</div><div class="line">  // 从http的响应数据转换成java类时用到的数据的类型 如Call&lt;T&gt; 中的 T</div><div class="line">  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数</div><div class="line">  Type responseType();</div><div class="line"></div><div class="line">  // 这个方法就是动态代理类中执行的方法，委托Call生成一个T对象	</div><div class="line">  T adapt(Call&lt;R&gt; call);</div><div class="line"></div><div class="line">  // 用于向Retrofit提供CallAdapter的工厂类</div><div class="line">  abstract class Factory &#123;</div><div class="line">    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和Observable&lt;Requestbody&gt;</div><div class="line">    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型</div><div class="line">    // 不支持时返回null</div><div class="line">    public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</div><div class="line">        Retrofit retrofit);</div><div class="line"></div><div class="line">    // 用于根据index获取泛型的参数 如 Call&lt;Requestbody&gt; 中 index为0时的Requestbody，</div><div class="line">    // index为 1 时 Map&lt;String, ? extends Runnable&gt; 的 Runnable</div><div class="line">    protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123;</div><div class="line">      return Utils.getParameterUpperBound(index, type);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call</div><div class="line">    // 上面的get方法需要使用该方法。</div><div class="line">    protected static Class&lt;?&gt; getRawType(Type type) &#123;</div><div class="line">      return Utils.getRawType(type);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="适配器处理请求流程"><a href="#适配器处理请求流程" class="headerlink" title="适配器处理请求流程"></a>适配器处理请求流程</h2><p>适配器处理请求是在动态代理类的 <code>serviceMethod.callAdapter.adapt(okHttpCall)</code> 方法处理。我们前面已经介绍过，使用使用内置适配器时，会由 <code>ExecutorCallAdapterFactory.get()</code> 方法生成的 <code>CallAdapter</code> 对象的 <code>adapt()</code> 方法执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123;</div><div class="line">  return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法返回了 <code>ExecutorCallAdapterFactor.ExecutorCallbackCall</code> 对象，以 <code>Android.MainThreadExecutor</code> 和 <code>OkHttpCall</code> 来作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</div><div class="line">  this.callbackExecutor = callbackExecutor;</div><div class="line">  this.delegate = delegate;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建请求流程一节中我们展示的Demo中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Call&lt;TestBean&gt; call = mRequestService.getData();</div><div class="line">call.enqueue(new Callback&lt;TestBean&gt;() &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onResponse(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response) &#123;</div><div class="line">        Log.e(&quot;Test&quot;,&quot;onResponse = &quot;+response.body().toString());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onFailure(Call&lt;TestBean&gt; call, Throwable t) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>mRequestService.getData()</code> 返回的其实就是 <code>ExecutorCallAdapterFactor.ExecutorCallbackCall</code> 对象，后面的 <code>call.enqueue</code> 方式其实就是调用的 <code>ExecutorCallAdapterFactor.ExecutorCallbackCall.enqueue()</code> 方法。<br>返回相应结果时，需要调用客户端设置的回调方法，这个回调方法是在客户端设置的回调执行器中调用的，如果没有设置，那么默认就是 <code>Android.MainThreadExecutor</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Override public void enqueue(final Callback&lt;T&gt; callback) &#123;</div><div class="line">  checkNotNull(callback, &quot;callback == null&quot;);</div><div class="line"></div><div class="line">  delegate.enqueue(new Callback&lt;T&gt;() &#123;</div><div class="line">    @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123;</div><div class="line">      // 结果的执行由客户端设置的回调执行器来执行。</div><div class="line">      callbackExecutor.execute(new Runnable() &#123;</div><div class="line">        @Override public void run() &#123;</div><div class="line">          if (delegate.isCanceled()) &#123;</div><div class="line">            // Emulate OkHttp&apos;s behavior of throwing/delivering an IOException on cancellation.</div><div class="line">            callback.onFailure(ExecutorCallbackCall.this, new IOException(&quot;Canceled&quot;));</div><div class="line">          &#125; else &#123;</div><div class="line">            callback.onResponse(ExecutorCallbackCall.this, response);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123;</div><div class="line">      callbackExecutor.execute(new Runnable() &#123;</div><div class="line">        @Override public void run() &#123;</div><div class="line">          callback.onFailure(ExecutorCallbackCall.this, t);</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到，<code>ExecutorCallbackCall</code> （使用内置适配器时）中相关的请求操作其实都是委托给 <code>OkHttpCall</code> 来执行的。执行的结果通过 <code>Android.MainThreadExecutor</code> 在主线程中执行回调函数。<br>具体的执行流程请看上面一节。</p>
<h2 id="处理响应结果"><a href="#处理响应结果" class="headerlink" title="处理响应结果"></a>处理响应结果</h2><p>这部分比较简单，主要是调用转换器的 <code>convert()</code> 方法把消息体转换成我们想要的数据类。<code>Response&lt;T&gt;</code> 这里用到了范型，是在定义请求方法时我们指定的类，比如 <code>RequestManager.TestBean</code>。<br>这里以我们前面Demo中定义的 <code>GsonConverterFactory</code> 转换器来看一下执行流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">├── OkHttpCall.parseResponse()</div><div class="line">    └── ServiceMethod.toResponse()</div><div class="line">        └── GsonResponseBodyConverter.convert()</div></pre></td></tr></table></figure>
<p><code>OkHttpCall.parseResponse()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123;</div><div class="line">  ResponseBody rawBody = rawResponse.body();</div><div class="line"></div><div class="line">  rawResponse = rawResponse.newBuilder()</div><div class="line">      .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</div><div class="line">      .build();</div><div class="line"></div><div class="line">  int code = rawResponse.code();</div><div class="line">  if (code &lt; 200 || code &gt;= 300) &#123;</div><div class="line">    try &#123;</div><div class="line">      // Buffer the entire body to avoid future I/O.</div><div class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</div><div class="line">      return Response.error(bufferedBody, rawResponse);</div><div class="line">    &#125; finally &#123;</div><div class="line">      rawBody.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (code == 204 || code == 205) &#123;</div><div class="line">    rawBody.close();</div><div class="line">    return Response.success(null, rawResponse);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);</div><div class="line">  try &#123;</div><div class="line">    T body = serviceMethod.toResponse(catchingBody);</div><div class="line">    return Response.success(body, rawResponse);</div><div class="line">  &#125; catch (RuntimeException e) &#123;</div><div class="line">    catchingBody.throwIfCaught();</div><div class="line">    throw e;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，Retrofit 数据请求流程部分源码解析已经完成。</p>
]]></content>
    
    <summary type="html">
    
      Retrofit 2 数据请求流程的简单介绍
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2 源码分析 -- 启动篇</title>
    <link href="http://yoursite.com/2017/11/06/open-source-retrofit-source-code-analysis-start/"/>
    <id>http://yoursite.com/2017/11/06/open-source-retrofit-source-code-analysis-start/</id>
    <published>2017-11-06T02:00:00.000Z</published>
    <updated>2018-05-06T07:22:25.867Z</updated>
    
    <content type="html"><![CDATA[<p>使用过 Retrofit 的同学都知道用 Retrofit 进行网络请求是非常便利的，学会了使用之后，我们一般都按捺不住要去研究源码去一查究竟了。通过研究源代码，才能更好地理解并掌握它的使用。<br>Retrofit 其实就是对 OKHttp 做了一层封装，使用了一些精妙的设计模式，使用面向接口的方式进行网络请求。</p>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p><a href="https://github.com/square/retrofit" target="_blank" rel="external">GitHub 源码地址</a><br><a href="http://square.github.io/retrofit/" target="_blank" rel="external">官方文档地址</a></p>
<h2 id="导入源码"><a href="#导入源码" class="headerlink" title="导入源码"></a>导入源码</h2><p><code>Retrofit</code> 是 Maven 项目，对于经常使用 Android Studio 的我们还是希望在 AS 中看代码的，这样就需要将 Maven 项目转化成 AS 项目：<br>其实很简单，只需要在 Maven 根目录下运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gradle init --type pom</div></pre></td></tr></table></figure>
<p>然后用 Android Studio 打开根目录即可倒入源码。</p>
<p>参考<a href="http://www.cnblogs.com/softidea/p/5631341.html" target="_blank" rel="external">链接</a></p>
<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><img src="/images/open-source-retrofit-source-code-analysis-start/retrofit-source-code-structure.png" alt="效果图"></p>
<p>adapter-<em> 和 converter-</em> 这几个模块是官方提供的适配器和转化器，Retrofit 的主要代码在 retrofit 模块中。</p>
<p><img src="/images/open-source-retrofit-source-code-analysis-start/retrofit-source-code-classes.png" alt="效果图"></p>
<p>可以看到 Retrofit 的源码其实比较简单的，后面我进一步进行分析。</p>
<!-- 
https://www.jianshu.com/p/52f3ca09e2ed
https://www.jianshu.com/p/7148b70f923f
https://www.jianshu.com/p/c40267f8e9b8
-->
]]></content>
    
    <summary type="html">
    
      Retrofit 2 源码的简单介绍
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit 2 使用指南</title>
    <link href="http://yoursite.com/2017/10/22/open-source-retrofit-guide/"/>
    <id>http://yoursite.com/2017/10/22/open-source-retrofit-guide/</id>
    <published>2017-10-22T02:00:00.000Z</published>
    <updated>2018-04-28T15:12:51.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Retrofit 是 Squareup 公司开源的网络请求框架，它其实是对 OkHttp 的一层封装，使用面向接口的方式进行网络请求，利用动态生成的代理类封装了网络接口请求的底层，并且提供了对 RxJava 的支持。<br>写这篇文章的时候，Retrofit 已经发布 2.3.0 了，本文就以此版本来介绍。<br><a href="https://github.com/square/retrofit" target="_blank" rel="external">GitHub 地址</a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">compile &apos;com.squareup.retrofit2:retrofit:2.3.0&apos;</div><div class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos;</div><div class="line">compile &apos;com.squareup.retrofit2:adapter-rxjava2:2.3.0&apos;</div></pre></td></tr></table></figure>
<p>注意 <code>compile &#39;com.squareup.retrofit2:adapter-rxjava2:2.3.0&#39;</code> 是添加了对RxJava2的支持，一定要注意RxJava的版本对应问题，否则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Caused by: java.lang.IllegalArgumentException: Unable to create call adapter for io.reactivex.Observable&lt;com.example.heqiang.testsomething.testretrofit.RequestManager$TestBean&gt;</div><div class="line">   for method RequestService.getDataRx</div><div class="line">   at retrofit2.ServiceMethod$Builder.methodError(ServiceMethod.java:752)</div><div class="line">   at retrofit2.ServiceMethod$Builder.createCallAdapter(ServiceMethod.java:237)</div><div class="line">   at retrofit2.ServiceMethod$Builder.build(ServiceMethod.java:162)</div><div class="line">   at retrofit2.Retrofit.loadServiceMethod(Retrofit.java:170)</div><div class="line">   at retrofit2.Retrofit$1.invoke(Retrofit.java:147)</div><div class="line">   at java.lang.reflect.Proxy.invoke(Proxy.java:393)</div><div class="line">   at $Proxy0.getDataRx(Unknown Source)</div><div class="line">   at com.example.heqiang.testsomething.testretrofit.RequestManager.getDataRx(RequestManager.java:68)</div><div class="line">   at com.example.heqiang.testsomething.rxjava.RxJavaActivity.testRetrofitRx(RxJavaActivity.java:105)</div><div class="line">   	... 11 more</div><div class="line">Caused by: java.lang.IllegalArgumentException: Could not locate call adapter for io.reactivex.Observable&lt;com.example.heqiang.testsomething.testretrofit.RequestManager$TestBean&gt;.</div><div class="line"> Tried:</div><div class="line">  * retrofit2.adapter.rxjava.RxJavaCallAdapterFactory</div><div class="line">  * retrofit2.ExecutorCallAdapterFactory</div><div class="line">   at retrofit2.Retrofit.nextCallAdapter(Retrofit.java:241)</div><div class="line">   at retrofit2.Retrofit.callAdapter(Retrofit.java:205)</div><div class="line">   at retrofit2.ServiceMethod$Builder.createCallAdapter(ServiceMethod.java:235)</div></pre></td></tr></table></figure>
<p>先上代码：</p>
<p>CallBack.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface CallBack&lt;T&gt; &#123;</div><div class="line">    void onSuccess(T t);</div><div class="line">    void onFail(Exception e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RequestService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestService</span> </span>&#123;</div><div class="line">    <span class="meta">@GET</span>(<span class="string">"hq/urls"</span>)</div><div class="line">    Call&lt;RequestManager.TestBean&gt; getData();</div><div class="line">    <span class="comment">// 支持RxJava</span></div><div class="line">    <span class="meta">@GET</span>(<span class="string">"hq/urls"</span>)</div><div class="line">    Observable&lt;RequestManager.TestBean&gt; getDataRx();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RequestManager.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RequestService mRequestService;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RequestManager sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RequestManager</span><span class="params">(Context context)</span></span>&#123;</div><div class="line"></div><div class="line">        Cache cache = <span class="keyword">new</span> Cache(<span class="keyword">new</span> File(context.getExternalCacheDir(),<span class="string">"test"</span>),<span class="number">100</span>*<span class="number">1024</span>*<span class="number">1024</span>);</div><div class="line">        Log.e(<span class="string">"Test"</span>, <span class="string">"cache dir = "</span> + context.getExternalCacheDir());</div><div class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">                .retryOnConnectionFailure(<span class="keyword">true</span>)</div><div class="line">                .connectTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</div><div class="line">                .cache(cache)</div><div class="line">                .build();</div><div class="line"></div><div class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">                <span class="comment">//这里如果不指定client，那么会生成一个默认的OkHttpClient</span></div><div class="line">                .client(client)</div><div class="line">                .baseUrl(<span class="string">"http://*.*.*.*/"</span>)</div><div class="line">                .addConverterFactory(GsonConverterFactory.create())</div><div class="line">                <span class="comment">//加入对RxJava2的支持</span></div><div class="line">                <span class="comment">//.addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span></div><div class="line">                .build();</div><div class="line">        mRequestService = retrofit.create(RequestService.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span> (RequestManager.class)&#123;</div><div class="line">                <span class="keyword">if</span>(sInstance == <span class="keyword">null</span>)&#123;</div><div class="line">                    sInstance = <span class="keyword">new</span> RequestManager();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</div><div class="line">        Call&lt;TestBean&gt; call = mRequestService.getData();</div><div class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;TestBean&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;TestBean&gt; call, Response&lt;TestBean&gt; response)</span> </span>&#123;</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"onResponse = "</span>+response.body().toString());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;TestBean&gt; call, Throwable t)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span></span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span>  code;</div><div class="line">        <span class="keyword">public</span> String message;</div><div class="line">        <span class="keyword">public</span> String redirect;</div><div class="line">        <span class="keyword">public</span> ArrayList&lt;String&gt; value;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"code = "</span>+code+<span class="string">", message = "</span>+message+<span class="string">",redirect = "</span>+ redirect+<span class="string">", value="</span>+value.toString();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结合RxJava和RxAndroid"><a href="#结合RxJava和RxAndroid" class="headerlink" title="结合RxJava和RxAndroid"></a>结合RxJava和RxAndroid</h2><p>在上面的代码中去掉 <code>addCallAdapterFactory(RxJava2CallAdapterFactory.create())</code> 的注释，再加上定义的 <code>Observable&lt;RequestManager.TestBean&gt; getDataRx()</code> 方法，就添加了对 RxJava2 的支持。<br>如果需要使用 RxAndroid 还要在build.gradle中添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDataRx</span><span class="params">(<span class="keyword">final</span> CallBack&lt;TestBean&gt; callBack)</span></span>&#123;</div><div class="line">    mRequestService.getDataRx().subscribeOn(Schedulers.io())</div><div class="line">            <span class="comment">// 依赖RxAndroid</span></div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Observer&lt;TestBean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                    Log.e(<span class="string">"Test"</span>,<span class="string">"onError"</span>);</div><div class="line">                    callBack.onFail(<span class="keyword">new</span> Exception(e));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(TestBean testBean)</span> </span>&#123;</div><div class="line">                    Log.e(<span class="string">"Test"</span>,<span class="string">"onNext = "</span>+testBean.toString());</div><div class="line">                    callBack.onSuccess(testBean);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<h2 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h2><p><code>CallAdapter</code> 其实就是对 <code>Call</code> 的转换，上面的对 RxJava 支持时用到的 <code>RxJava2CallAdapterFactory</code> 其实就是 <code>CallAdapter.Factory</code> 的子类，当然我们也可以自定义实现一个 <code>CallAdapter</code>。</p>
<h2 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h2><p>在默认情况下 Retrofit 只支持将 HTTP 的响应体转换换为 <code>ResponseBody</code>，那么接口的返回值都是 <code>Call&lt;ResponseBody&gt;</code>，如果我们需要把 <code>ResponseBody</code> 转换成我们需要的类型就需要 <code>Converter</code>。<br><code>Converter</code> 就是对数据的转换，代码中 <code>addConverterFactory(GsonConverterFactory.create())</code> 就是指定了 Gson 将 <code>ResponseBody</code>转换我们想要的类型。<br>显然我们也可以自定义一个 <code>Converter</code>。</p>
<h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>PATCH</li>
<li>HEAD</li>
<li>OPTIONS</li>
<li>HTTP</li>
</ul>
<p>前面 6 种都是HTTP协议请求方式，使用方法和前面例子中的类似，都接受一个字符串来和 BaseUrl 组成请求Url。<br>HTTP 方式是对上面 6 中的扩展，用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@HTTP</span>(method = <span class="string">"GET"</span>, path = <span class="string">"blog"</span>, hasBody = <span class="keyword">false</span>)</div><div class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">getBlog</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><ul>
<li>Path</li>
<li>Query</li>
<li>QueryMap</li>
</ul>
<p>上面三种都是一个完整Url的组成部分，Path 用在 Url 的 path 部分，Query 和 QueryMap 用在参数部分，也就是Url中的 ? 后面的部分。QueryMap 相当于多个 Query。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"day/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;"</span>)</div><div class="line"><span class="function">Observable&lt;DailyDataResponse&gt; <span class="title">getDailyData</span><span class="params">(</span></span></div><div class="line">        @Path(<span class="string">"year"</span>) <span class="keyword">int</span> year,@<span class="title">Path</span><span class="params">(<span class="string">"month"</span>)</span> <span class="keyword">int</span> month,@<span class="title">Path</span><span class="params">(<span class="string">"day"</span>)</span> <span class="keyword">int</span> day);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"day"</span>)</div><div class="line"><span class="function">Call&lt;Response&gt; <span class="title">getDailyData</span><span class="params">(</span></span></div><div class="line">        @Query(<span class="string">"year"</span>) <span class="keyword">int</span> year,@<span class="title">Query</span><span class="params">(<span class="string">"month"</span>)</span> <span class="keyword">int</span> month,@<span class="title">Query</span><span class="params">(<span class="string">"day"</span>)</span> <span class="keyword">int</span> day);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"day"</span>)</div><div class="line"><span class="function">Call&lt;Response&gt; <span class="title">getDailyData</span><span class="params">(</span></span></div><div class="line">        @QueryMap Map&lt;String, Integer&gt; map);</div></pre></td></tr></table></figure>
<ul>
<li>Field ：POST请求，提交单个数据</li>
<li>FieldMap：POST请求，和@Filed作用一致，用于不确定表单参数</li>
<li>Body：POST请求，以对象的形式提交，多用于post请求发送非表单数据,比如想要以post方式传递json格式数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FormUrlEncoded</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"add2gank"</span>)</div><div class="line"><span class="function">Observable&lt;AddToGankResponse&gt; <span class="title">add2Gank</span><span class="params">(@Field(<span class="string">"url"</span>)</span> String url, @<span class="title">Field</span><span class="params">(<span class="string">"desc"</span>)</span> String desc, @<span class="title">Field</span><span class="params">(<span class="string">"who"</span>)</span> String who,</span></div><div class="line">                            @<span class="title">Field</span><span class="params">(<span class="string">"type"</span>)</span> String type,@<span class="title">Field</span><span class="params">(<span class="string">"debug"</span>)</span> <span class="keyword">boolean</span> debug);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span>(<span class="string">"add2gank"</span>)</div><div class="line"><span class="function">Call&lt;Response&gt; <span class="title">add2Gank</span><span class="params">(@Body ExtrasBean bean)</span></span>;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FormUrlEncoded</span></div><div class="line"><span class="meta">@POST</span>(<span class="string">"add2gank"</span>)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add2Gank</span><span class="params">(@FieldMap Map&lt;String, String&gt; map)</span></span></div></pre></td></tr></table></figure>
<p>可以看到这里多了一个 <code>@FormUrlEncoded</code> 注解，如果去掉 <code>@FromUrlEncoded</code> 在 post 请求中使用 <code>@Field</code> 和 <code>@FieldMap</code>，那么程序会抛出 <code>java.lang.IllegalArgumentException: @Field parameters can only be used with form encoding. (parameter #1)</code> 的错误异常。<br>如果将 <code>@FromUrlEncoded</code> 添加在 <code>@GET</code> 上面呢，同样的也会抛出 <code>java.lang.IllegalArgumentException:FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST)</code> 的错误异常。<br>如果是使用 <code>@Body</code>，也是不用加 <code>@FormUrlEncoded</code> 注解的。</p>
<h3 id="动态Url"><a href="#动态Url" class="headerlink" title="动态Url"></a>动态Url</h3><p>前面的使用都是基于BaseUrl的，如果我们想请求不同Url时只能重新生成一个 Retrofit 实例，实际上我们还可以通过 <code>@Url</code> 来操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span></div><div class="line"><span class="function"><span class="keyword">public</span> Call&lt;ResponseBody&gt; <span class="title">getImage</span><span class="params">(@Url String url)</span></span>;</div></pre></td></tr></table></figure>
<p>如果参数指定的 url 是一个以 <code>http</code> 开头的 url，那么就完全使用这个url，和前面指定的 BaseUrl 完全没有联系，如果 url 指定的只有类似 <code>/id/name</code> 的path，而没有指定 scheme 和 host，那么它就会用 BaseUrl 的 scheme 和 host。<br><strong> <font color="#ff0000">这里注意</font> </strong>：只是用 BaseUrl 的 scheme 和 host，如果 BaseUrl 是 <a href="http://www.test.com/v/" target="_blank" rel="external">http://www.test.com/v/</a> ，那么还是会把 path 中的 v  去掉，组成 <a href="http://www.test.com/id/name" target="_blank" rel="external">http://www.test.com/id/name</a> 。</p>
<!--  
http://www.jianshu.com/p/308f3c54abdd
-->
]]></content>
    
    <summary type="html">
    
      介绍 Retrofit 2 的一些基本用法
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 使用指南 -- Single、Completable 和 Maybe 的用法</title>
    <link href="http://yoursite.com/2017/10/18/open-source-rxjava-single-completable-maybe/"/>
    <id>http://yoursite.com/2017/10/18/open-source-rxjava-single-completable-maybe/</id>
    <published>2017-10-18T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面在 <a href="http://www.heqiangfly.com/2017/10/10/open-source-rxjava-guide-base/" target="_blank" rel="external">RxJava 使用指南（一）– 基本概念、数据流创建和线程调度 </a> 一文中简单介绍了几种观察者模式组合的组合。</p>
<ul>
<li>Observable/Observer</li>
<li>Flowable/Subscriber</li>
<li>Single/SingleObserver</li>
<li>Completable/CompletableObserver</li>
<li>Maybe/MaybeObserver</li>
</ul>
<p>其中 <code>Observable/Observer</code> 和 <code>Flowable/Subscriber</code> 比较常用，前面也用了大量篇幅来介绍，本文就来介绍一下 <code>Single/SingleObserver</code>、<code>Completable/CompletableObserver</code> 和 <code>Maybe/MaybeObserver</code> 这三个组合的用法。</p>
<h2 id="Single-SingleObserver-的用法"><a href="#Single-SingleObserver-的用法" class="headerlink" title="Single/SingleObserver 的用法"></a>Single/SingleObserver 的用法</h2><p>先来看一下代码中如何实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Single.create(new SingleOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void subscribe(@NonNull SingleEmitter&lt;String&gt; e) throws Exception &#123;</div><div class="line">        e.onSuccess(&quot;Success&quot;);</div><div class="line">        //e.onError(new Throwable(&quot;Error&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(new SingleObserver&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onSubscribe(@NonNull Disposable d) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onSuccess(@NonNull String s) &#123;</div><div class="line">                Log.e(&quot;Test&quot;,&quot;onSuccess &quot;+s);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(@NonNull Throwable e) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们先从代码上来分析 <code>Single/SingleObserver</code> 和 <code>Observable/Observer</code> 的区别。<br><code>SingleEmitter</code> 和 <code>ObservableEmitter</code> 的区别：<br><code>SingleEmitter</code> 发射数据的方法只有 <code>onSuccess()</code> 和 <code>onError()</code>，而 <code>ObservableEmitter</code> 多了个 <code>onNext()</code> 方法。<br>再来看一下 <code>SingleObserver</code> 和 <code>Observer</code> 的区别：<br><code>SingleObserver</code> 处理结果的方法有 <code>onSubscribe()</code>、<code>onSuccess()</code> 和 <code>onError()</code>。而 <code>Observer</code> 多了个 <code>onNext()</code> 和 <code>onComplete()</code> 方法，而没有 <code>onSuccess()</code> 方法。<br>结合 <code>Single</code> 本身的名字，我们可以联想到，这个组合是只能发射单个数据或者一条异常通知，不能发射完成通知，其中数据与通知只能发射一个。<br>那么 <code>Single/SingleObserver</code> 有什么使用场景呢？<br>我们在实际应用中，有时候需要发射的数据并不是数据流的形式，而只是一条单一的数据，比如发起一次网络请求。在这种情况下，如果我们使用 <code>Observable</code>，<code>onComplete</code> 会紧跟着 <code>onNext</code> 被调用，为什么不能将这连个方法合二为一呢。如果再这种情况下我们再使用 <code>Observable</code> 就显得有点大材小用，因为我们不需要处理 <code>onNext()</code> 的数据。于是，为了满足这种单一数据的使用场景，便出现了 <code>Single</code>。</p>
<h3 id="转化为其他观察者模式"><a href="#转化为其他观察者模式" class="headerlink" title="转化为其他观察者模式"></a>转化为其他观察者模式</h3><p><code>Single</code> 基本上实现了 <code>Observable</code> 所有的操作符，如果你发现需要用到一个 <code>Observable</code> 的操作符而 <code>Single</code> 并不支持，你可以用 <code>toObservable</code> 操作符把 <code>Single&lt;T&gt;</code> 转换为 <code>Observable&lt;T&gt;</code>。<br>另外 <code>Single</code> 还提供了其他转换方法：</p>
<ul>
<li>toCompletable()</li>
<li>toMaybe()</li>
<li>toFlowable()</li>
<li>toFuture()</li>
</ul>
<h2 id="Completable-CompletableObserver-的用法"><a href="#Completable-CompletableObserver-的用法" class="headerlink" title="Completable/CompletableObserver 的用法"></a>Completable/CompletableObserver 的用法</h2><p>先通过代码来看一下用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Completable.create(new CompletableOnSubscribe() &#123;</div><div class="line">    @Override</div><div class="line">    public void subscribe(@NonNull CompletableEmitter e) throws Exception &#123;</div><div class="line">        e.onComplete();</div><div class="line">        //e.onError(new Throwable(&quot;Error&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">        .observeOn(Schedulers.io())</div><div class="line">        .subscribe(new CompletableObserver() &#123;</div><div class="line">            @Override</div><div class="line">            public void onSubscribe(@NonNull Disposable d) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.e(&quot;Test&quot;, &quot;onComplete&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(@NonNull Throwable e) &#123;</div><div class="line">                Log.e(&quot;Test&quot;, &quot;onError&quot;+e.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>照例先来看一下 <code>CompletableEmitter</code>：<br>它提供的数据和通知的方法如下：</p>
<ul>
<li>onComplete()</li>
<li>onError()</li>
</ul>
<p><code>CompletableObserver</code> 的相关的方法：</p>
<ul>
<li>onSubscribe()</li>
<li>onComplete()</li>
<li>onError()</li>
</ul>
<p>可以看到，这里面没有数据处理的方法，只有通知相关的方法。它只发射一条完成通知，或者一条异常通知，不能发射数据，其中完成通知与异常通知只能发射一个。<br>那么 <code>Completable/CompletableObserver</code> 有什么使用场景呢？<br>和前面 <code>Single/SingleObserver</code> 的用法比较类似，只是这里不对数据进行处理，只有个通知的结果。比如：我们向服务器发起一个更新数据的请求，服务器更新数据以后是返回的是更新的结果。这个时候我们或许只是关心的是服务器更新数据是否成功，而不需要对数据进行处理，那么这个时候用 <code>Completable/CompletableObserver</code>  就可以了。<br><code>Completable</code> 也提供了对 <code>Observable</code>、<code>Flowable</code>、<code>Single</code> 和 <code>Maybe</code> 的转换。</p>
<h2 id="Maybe-MaybeObserver-的用法"><a href="#Maybe-MaybeObserver-的用法" class="headerlink" title="Maybe/MaybeObserver 的用法"></a>Maybe/MaybeObserver 的用法</h2><p>再来看一下 <code>Maybe</code> 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Maybe.create(new MaybeOnSubscribe&lt;String&gt;()&#123;</div><div class="line">    @Override</div><div class="line">    public void subscribe(@NonNull MaybeEmitter&lt;String&gt; e) throws Exception &#123;</div><div class="line">        e.onSuccess(&quot;onSuccess&quot;);</div><div class="line">        //e.onError(new Throwable(&quot;Error&quot;));</div><div class="line">        //e.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">        .observeOn(Schedulers.io())</div><div class="line">        .subscribe(new MaybeObserver&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void onSubscribe(@NonNull Disposable d) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onSuccess(@NonNull String s) &#123;</div><div class="line">                Log.e(&quot;Test&quot;,&quot;onSuccess&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onError(@NonNull Throwable e) &#123;</div><div class="line">                Log.e(&quot;Test&quot;,&quot;onError&quot;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onComplete() &#123;</div><div class="line">                Log.e(&quot;Test&quot;,&quot;onComplete&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p><code>Maybe</code>可发射一条单一的数据，以及发射一条完成通知，或者一条异常通知，其中完成通知和异常通知只能发射一个，发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。</p>
]]></content>
    
    <summary type="html">
    
      本文介绍 RxJava 中 Single、Completable 和 Maybe 的用法
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 使用指南 -- Flowable 和 Subscriber</title>
    <link href="http://yoursite.com/2017/10/14/open-source-rxjava-guide-flowable/"/>
    <id>http://yoursite.com/2017/10/14/open-source-rxjava-guide-flowable/</id>
    <published>2017-10-14T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面文章已经介绍过，Flowable/Subscriber 也是一对观察者模式的组合，和 Observable/Observer 的区别是 Flowable/Subscriber 是支持背压的，背压是个什么呢？</p>
<h2 id="Backpressure（背压）"><a href="#Backpressure（背压）" class="headerlink" title="Backpressure（背压）"></a>Backpressure（背压）</h2><p>背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。<br>在 Observable/Observer 组合的使用中是不支持背压的，下面通过一个例子来看一下这种场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; Long.MAX_VALUE)&#123;</div><div class="line">            e.onNext(i);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.newThread())</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"i = "</span>+integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这里上游数据发射和下游的数据处理在各自的独立线程中执行，如果在同一个线程中不存在背压的情形。下游对数据的处理会堵塞上游数据的发送，上游发送一条数据后会等下游处理完之后再发送下一条。<br>在例子中，上游发射数据时，并不知道下游数据有没有处理完，就会源源不断的发射数据，而下游数据会间隔两秒钟才处理一次，这样就会产生很多下游没来得及处理的数据，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是 Rxjava 中的背压问题。<br>可以通过 Monitors 发现内存使用快速增长。</p>
<p><img src="/images/open-source-rxjava-guide-flowable/observer.png" alt="效果图"></p>
<h2 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h2><p><code>Flowable</code> 就是为了解决背压问题的产物，因此才会把它们和 Observable/Observer 区分开来使用。<br>由于基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比 <code>Observable</code> 低得多。<br>因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。<br>所以，如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用 <code>Flowable</code>，以免影响性能。<br><code>Flowable</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull FlowableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; Long.MAX_VALUE)&#123;</div><div class="line">            e.onNext(i);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, BackpressureStrategy.DROP)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">                s.request(Long.MAX_VALUE);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"i = "</span>+integer);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这里注意三点：</p>
<ol>
<li><code>Flowable.create</code> 参数中多了个 <code>BackpressureStrategy</code>。</li>
<li><code>onSubscribe</code> 回调的参数不是 <code>Disposable</code> 而是 <code>Subscription</code>。而且需要调用 <code>Subscription.request</code> 发起数据请求，否则Subscriber不会接受数据。</li>
<li>数据发射器是 <code>FlowableEmitter</code> 而不是 <code>ObservableEmitter</code>。</li>
</ol>
<p><img src="/images/open-source-rxjava-guide-flowable/drop.png" alt="效果图"></p>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">E/Test: i = 110</div><div class="line">E/Test: i = 111</div><div class="line">E/Test: i = 112</div><div class="line">E/Test: i = 113</div><div class="line">E/Test: i = 114</div><div class="line">E/Test: i = 115</div><div class="line">E/Test: i = 116</div><div class="line">E/Test: i = 117</div><div class="line">E/Test: i = 118</div><div class="line">E/Test: i = 119</div><div class="line">E/Test: i = 120</div><div class="line">E/Test: i = 121</div><div class="line">E/Test: i = 122</div><div class="line">E/Test: i = 123</div><div class="line">E/Test: i = 124</div><div class="line">E/Test: i = 125</div><div class="line">E/Test: i = 126</div><div class="line">E/Test: i = 127</div><div class="line">E/Test: i = 19044130</div><div class="line">E/Test: i = 19044131</div><div class="line">E/Test: i = 19044132</div><div class="line">E/Test: i = 19044133</div><div class="line">E/Test: i = 19044134</div><div class="line">E/Test: i = 19044135</div><div class="line">E/Test: i = 19044136</div><div class="line">E/Test: i = 19044137</div><div class="line">E/Test: i = 19044138</div></pre></td></tr></table></figure>
<p>可以看到 127 —— 19044130 中间的数据被丢掉了，这是因为前面128条数据是正常发射的，后面的数据由于异步缓存池处于存满的状态而无法接收，当清理缓存池时上游正在发射19044130，此时可以放入缓存池从而可以正常接收。</p>
<h2 id="BackpressureStrategy（背压策略）"><a href="#BackpressureStrategy（背压策略）" class="headerlink" title="BackpressureStrategy（背压策略）"></a>BackpressureStrategy（背压策略）</h2><p><code>Flowable</code> 的异步缓存池不同于 <code>Observable</code>，<code>Observable</code>的异步缓存池没有大小限制，可以无限制向里添加数据，直至OOM,而 <code>Flowable</code> 的异步缓存池有个固定容量，其大小为128。<br><code>BackpressureStrategy</code> 的作用便是用来设置 <code>Flowable</code> 异步缓存池中的存储数据超限时的策略。<br><code>BackpressureStrategy</code> 提供了一下几种背压策略：</p>
<ul>
<li>MISSING：这种策略模式下相当于没有指定任何的背压策略，不会对数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</li>
<li>ERROR：这种策略模式下如果缓存池中的数据超限了，则会抛出 <code>MissingBackpressureException</code> 异常</li>
<li>BUFFER：这种策略模式下没有为异步缓存池限制大小，可以无限制向里添加数据，不会抛出 <code>MissingBackpressureException</code> 异常，但会导致OOM。</li>
<li>DROP：这种策略模式下如果异步缓存池满了，会丢掉将要放入缓存池中的数据。</li>
<li>LATEST：这种策略模式下与 Drop 策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，LATEST都会将最后一条数据强行放入缓存池中。</li>
</ul>
<h2 id="背压操作符"><a href="#背压操作符" class="headerlink" title="背压操作符"></a>背压操作符</h2><p>RxJava 提供了下面的操作符来指定背压策略。</p>
<ul>
<li>onBackpressureBuffer()：对应BUFFER策略</li>
<li>onBackpressureDrop()：对应DROP策略</li>
<li>onBackpressureLatest()：对应LATEST策略</li>
</ul>
<p>因此下面代码效果是等同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull FlowableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; <span class="number">800</span>)&#123;</div><div class="line">            e.onNext(i);</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, BackpressureStrategy.DROP)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"i = "</span>+integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Flowable.range(<span class="number">0</span>, <span class="number">800</span>)</div><div class="line">        .onBackpressureDrop()</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"i = "</span>+integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h2><p>前我们已经介绍过，<code>Flowable</code> 的 <code>subscribe</code> 方法需要的参数是 <code>Subscription</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><code>request(long n)</code> 用于发起接收数据的请求，如果不调用这个方法，虽然被观察者会正常发送数据，但是观察者是不会去接收数据的。参数 <code>n</code> 代表请求的数据量。<br>但是要注意一点，上游数据的发送是不受这个影响的，无论你设置多少，上游数据都正常发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">Flowable.create(<span class="keyword">new</span> FlowableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull FlowableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i &lt; <span class="number">100</span>)&#123;</div><div class="line">            e.onNext(i);</div><div class="line">            i++;</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, BackpressureStrategy.DROP)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.newThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">                s.request(<span class="number">10</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                Log.e(<span class="string">"Test"</span>,<span class="string">"i = "</span>+integer);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>上面的代码只完成了 10 条数据的接收。<code>request(long n)</code>是可以累加的，比如下面代码可以完成 20 条数据的接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</div><div class="line">    s.request(<span class="number">10</span>);</div><div class="line">    s.request(<span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><p><code>cancel()</code> 方法用于取消订阅关系。</p>
<h2 id="FlowableEmitter"><a href="#FlowableEmitter" class="headerlink" title="FlowableEmitter"></a>FlowableEmitter</h2><p><code>FlowableEmitter</code> 有如下方法：</p>
<ul>
<li>setDisposable：设置Disposable</li>
<li>setCancellable：设置Cancellable</li>
<li>requested：当前未完成的请求数量</li>
<li>isCancelled：订阅关系是否取消</li>
<li>serialize：</li>
<li>tryOnError：</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文介绍 RxJava 中 Flowable 和 Subscriber的用法
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 使用指南 -- 操作符介绍</title>
    <link href="http://yoursite.com/2017/10/12/open-source-rxjava-guide-operator/"/>
    <id>http://yoursite.com/2017/10/12/open-source-rxjava-guide-operator/</id>
    <published>2017-10-12T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.976Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍一些常用 RxJava 的操作符的用法。</p>
<h2 id="创建Observable-操作符"><a href="#创建Observable-操作符" class="headerlink" title="创建Observable 操作符"></a>创建Observable 操作符</h2><p>前面的例子介绍了使用 <code>Observable.create()</code> 操作符来创建 <code>Observable</code>，下面再介绍一下 RxJava 提供的其他方法。</p>
<h3 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h3><p><code>just(T item1, ...)</code>创建 <code>Observable</code> 并自动调用 <code>onNext()</code>发射数据，可以接受一个或者多个参数， <code>just()</code> 中传递的参数将在 <code>Observer</code> 的 <code>onNext()</code> 方法中接收到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"onNext : "</span> + s);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"onComplete"</span>);</div><div class="line">            &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/RxJava: onNext : Hello</div><div class="line">I/RxJava: onNext : World</div><div class="line">I/RxJava: onComplete</div></pre></td></tr></table></figure>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><p><code>defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</code> 当观察者订阅时，才创建 Observable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.defer(<span class="keyword">new</span> Callable&lt;ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ObservableSource&lt;String&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"defer call"</span>);</div><div class="line">        <span class="keyword">return</span> Observable.just(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"accept : "</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里新建了一个 <code>Consumer</code> 对象来作为观察者。</p>
<h3 id="fromArray"><a href="#fromArray" class="headerlink" title="fromArray()"></a>fromArray()</h3><p><code>fromArray(T... items)</code> 接受一个数组参数，创建 <code>Observable</code> 并自动调用 <code>onNext()</code> 将数组中的数据逐一发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.fromArray(<span class="keyword">new</span> String[]&#123;<span class="string">"Hello"</span>,<span class="string">"World"</span>&#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="fromIterable"><a href="#fromIterable" class="headerlink" title="fromIterable()"></a>fromIterable()</h3><p><code>fromIterable(Iterable&lt;? extends T&gt; source)</code> 接受一个集合参数，创建 <code>Observable</code> 并将集合中的数据逐一发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</div><div class="line">list.add(<span class="string">"Hello"</span>);</div><div class="line">list.add(<span class="string">"World"</span>);</div><div class="line">Observable.fromIterable(list)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h3><p><code>interval(long period, TimeUnit unit)</code> 按照一个固定的时间间隔 <code>period</code> 来发射数据，可以作为一个定时器来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</div><div class="line">                mDisposable = d;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull Long aLong)</span> </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"onNext : "</span> + aLong);</div><div class="line">                <span class="keyword">if</span>(aLong == <span class="number">5</span>)</div><div class="line">                    mDisposable.dispose();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>上面例子中当数据等于5解除订阅关系，停止发射数据。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p><code>range(final int start, final int count)</code> 创建一个被观察者并发射从 <code>start</code> 到 <code>count</code> 的整数序列给观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.range(<span class="number">1</span>,<span class="number">5</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h3><p><code>timer(long delay, TimeUnit unit)</code>创建一个 Observable 并在它在一个给定的延迟 <code>delay</code> 后发射一个特殊的值（0）给观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.timer(<span class="number">5</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat()</code> 方法会将参数中的多个数据源合并，并按顺序发射。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Observable source1 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123;</div><div class="line">        e.onNext(&quot;Hello&quot;);</div><div class="line">        e.onComplete();</div><div class="line">        //e.onError(new Exception(&quot;Test Error&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Observable source2 = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123;</div><div class="line">        e.onNext(&quot;World&quot;);</div><div class="line">        e.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Observable.concat(source1, source2).subscribeOn(Schedulers.io())</div><div class="line">.observeOn(Schedulers.io())</div><div class="line">.subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void accept(String s) throws Exception &#123;</div><div class="line">        Log.e(&quot;Test&quot;,s);</div><div class="line">    &#125;</div><div class="line">&#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void accept(Throwable throwable) throws Exception &#123;</div><div class="line">        Log.e(&quot;Test&quot;,throwable.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里需要注意的是，如果前一个数据源发出 <code>onError</code>，那么将会中断后面数据的发射。</p>
<h3 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h3><p>再来介绍一下 <code>first()</code> 操作符，只发送符合条件的第一个事件，可以与前面的 <code>contact</code> 操作符结合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.concat(source1, source2).subscribeOn(Schedulers.io())</div><div class="line">        .first(&quot;Default&quot;)</div><div class="line">        .subscribe(new Consumer&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(String s) throws Exception &#123;</div><div class="line">                Log.e(&quot;Test&quot;,s);</div><div class="line">            &#125;</div><div class="line">        &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void accept(Throwable throwable) throws Exception &#123;</div><div class="line">                Log.e(&quot;Test&quot;,throwable.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>如果 source1 和 source2 都有条件发射数据，那么就只发射 source1 的数据。如果只有 source2 有条件发射数据，那么就发送 source2 的数据。如果都不发射，就发送 <code>first()</code> 默认数据。<br>就是说顺序发射数据时，只要有一个 <code>Observable</code> 发射了数据，那么就不会发射后面的数据了。如果都不发射数据，那么就发送 <code>first(default)</code> 参数里面的默认数据。</p>
<p>这个操作符做网络缓存的时候很有用。举个例子：依次检查 Disk 与 Network，如果 Disk 存在缓存，则不做网络请求，否则进行网络请求。</p>
<h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h3><h2 id="map-和-flatmap-（变换）"><a href="#map-和-flatmap-（变换）" class="headerlink" title="map 和 flatmap （变换）"></a>map 和 flatmap （变换）</h2><p>这一组操作符提供数据的变换工作，就是把数据对象变换成其他类型的数据对象，它们都接受一个 <code>Function</code> 类型的参数。但是它们的用法上还是有区别的。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>先来说一下 <code>map()</code> 操作的使用场景，如果在数据流的传递过程中，我们需要根据当前数据流对象转换或提取生成一种其他类型的数据流对象，可以使用 <code>map()</code> 。<br>它需要一个 <code>Function</code> 参数，<code>Function</code> 对象的两个参数是转换的源数据和目标数据类型。<br>比如我们有一个请求网络图片的场景，被订阅者发出的数据是原始的 <code>byte</code> 类型数据，在设置给 <code>ImageView</code> 前我们要转换成 <code>Bitmap</code> 类型的数据，那么就可以用这个操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;<span class="keyword">byte</span> []&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;<span class="keyword">byte</span> []&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">byte</span> [] data = getBitmapDataSync(mUrl);</div><div class="line">        observableEmitter.onNext(data);</div><div class="line">        observableEmitter.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .map(<span class="keyword">new</span> Function&lt;<span class="keyword">byte</span>[], Bitmap&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Bitmap <span class="title">apply</span><span class="params">(@NonNull <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> generateBitmap(bytes);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Bitmap&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h3><p><code>flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)</code> 中同样需要一个 <code>Function</code> 对象作为参数，但是 <code>Function</code> 的目标数据类型变成了 <code>Observable</code>。<br><code>flatMap</code> 一般用于输出一个 <code>Observable</code>，而其随后的 <code>subscribe</code> 中的参数也跟 <code>Observable</code> 中的参数一样。<br>下面再提供一个使用场景，这个场景属于嵌套的网络请求，比如我们想先进行一次网络请求得到图片的url，然后根据url再进行网络请求得到图片，最后设置给 <code>ImageView</code> ，这种情况下由url到 <code>Bitmap</code> 的转换用 <code>map</code> 是无法实现的，可以使用 <code>flatmap</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;String&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String url = getImageUrl(mUrl);</div><div class="line">        observableEmitter.onNext(url);</div><div class="line">        observableEmitter.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.io())</div><div class="line">        .flatMap(<span class="keyword">new</span> Function&lt;String, ObservableSource&lt;Bitmap&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> ObservableSource&lt;Bitmap&gt; <span class="title">apply</span><span class="params">(@NonNull <span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Bitmap&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Bitmap&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                        Bitmap bitmap = getBitmap(url);</div><div class="line">                        observableEmitter.onNext(bitmap);</div><div class="line">                        observableEmitter.onComplete();</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Bitmap&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="filter-和-distinct-（过滤）"><a href="#filter-和-distinct-（过滤）" class="headerlink" title="filter 和 distinct （过滤）"></a>filter 和 distinct （过滤）</h2><p>这一组操作符提供数据的过滤工作，<code>filter</code> 对不符合条件的数据进行过滤，<code>distinct</code> 提供去重的功能。最常用的用法之一是过滤 null 对象,它帮我们免去了在 <code>onNext()</code> 函数调用中再去检测 null 值。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter(Predicate&lt;? super T&gt; predicate)</code> 接受 <code>Predicate</code> 对象参数，它的 <code>test()</code> 方法给出一个过滤条件，如果满足条件，则继续向下传递，如果不满足，则过滤掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.range(<span class="number">0</span>,<span class="number">10</span>)</div><div class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(@NonNull Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的示例会过滤掉奇数，把偶数打印出来。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p><code>distinct()</code> 过滤掉重复的数据项，过滤规则为：只允许还没有发射过的数据项通过。它还有重载的两个方法 <code>distinct(Function&lt;? super T, K&gt; keySelector)</code> 和 <code>distinct(Function&lt;? super T, K&gt; keySelector, Callable&lt;? extends Collection&lt;? super K&gt;&gt; collectionSupplier)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>)</div><div class="line">        .distinct()</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="mergeWith-和-concatWith-（组合）"><a href="#mergeWith-和-concatWith-（组合）" class="headerlink" title="mergeWith 和 concatWith （组合）"></a>mergeWith 和 concatWith （组合）</h2><p>这一组操作符提供数据的组合工作。</p>
<h3 id="mergeWith"><a href="#mergeWith" class="headerlink" title="mergeWith"></a>mergeWith</h3><p><code>mergeWith(ObservableSource&lt;? extends T&gt; other)</code> 合并两个 <code>Observable</code>，它们数据可能会交错发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .mergeWith(Observable.just(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="concatWith"><a href="#concatWith" class="headerlink" title="concatWith"></a>concatWith</h3><p><code>concatWith(ObservableSource&lt;? extends T&gt; other)</code>合并两个 <code>Observable</code>，它们数据会按顺序发射，一个 <code>Observable</code> 的数据发送完了另外一个才会发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .concatWith(Observable.just(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="zipWith（聚合）"><a href="#zipWith（聚合）" class="headerlink" title="zipWith（聚合）"></a>zipWith（聚合）</h2><p><code>zipWith(ObservableSource&lt;? extends U&gt; other, BiFunction&lt;? super T, ? super U, ? extends R&gt; zipper)</code> 将两个 <code>Obversable</code> 发射的数据，通过一个函数 <code>BiFunction</code> 的 <code>apply()</code> 方法对对应位置的数据处理后放到一个新的 <code>Observable</code> 中发射，所发射的数据个数与最少的 <code>Observabel</code> 中的一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .zipWith(Observable.just(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>, <span class="string">"five"</span>), <span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(@NonNull Integer integer, @NonNull String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer + s;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"accept : "</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">I/RxJava: accept : 1one</div><div class="line">I/RxJava: accept : 2two</div><div class="line">I/RxJava: accept : 3three</div><div class="line">I/RxJava: accept : 4four</div><div class="line">I/RxJava: accept : 5five</div></pre></td></tr></table></figure>
<h2 id="take、-takeLast、takeUntil-和-takeWhile"><a href="#take、-takeLast、takeUntil-和-takeWhile" class="headerlink" title="take、 takeLast、takeUntil 和 takeWhile"></a>take、 takeLast、takeUntil 和 takeWhile</h2><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take(long count)</code> 观察者只接受被观察者发出的前 <code>count</code> 个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .take(<span class="number">3</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h3><p><code>takeLast(int count)</code> 观察者只接受被观察者发出的后面 <code>count</code> 个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .take(<span class="number">3</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h3><p><code>takeUntil(Predicate&lt;? super T&gt; stopPredicate)</code> 当条件满足是停止发射数据，<code>takeUntil(ObservableSource&lt;U&gt; other)</code> 当 other 发射第一个数据后即停止第一个 <code>Observable</code> 数据的发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .takeUntil(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(@NonNull Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer == <span class="number">3</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h3><p><code>takeWhile(Predicate&lt;? super T&gt; predicate)</code> 当满足条件是才会发射数据，遇到不满足条件的情况，就中断退出发射。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div><div class="line">        .takeWhile(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(@NonNull Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer &lt; <span class="number">3</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h2 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h2><p><code>sample(long period, TimeUnit unit)</code> 相当于采样操作，它会定时地扫描被观察者发送的数据，并接收被观察者最近发射的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(Schedulers.io())</div><div class="line">        .sample(<span class="number">3</span>, TimeUnit.SECONDS)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">I/RxJava: accept : 0</div><div class="line">I/RxJava: accept : 1</div><div class="line">I/RxJava: accept : 3</div><div class="line">I/RxJava: accept : 4</div><div class="line">I/RxJava: accept : 6</div><div class="line">I/RxJava: accept : 7</div><div class="line">I/RxJava: accept : 9</div><div class="line">I/RxJava: accept : 10</div><div class="line">I/RxJava: accept : 12</div></pre></td></tr></table></figure>
<h2 id="skip-和-skipLast"><a href="#skip-和-skipLast" class="headerlink" title="skip 和 skipLast"></a>skip 和 skipLast</h2><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p><code>skip(long count)</code> 用于过滤被观察者发送的前 n 项数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .skip(<span class="number">6</span>)</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Long aLong)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">I/RxJava: accept : 6</div><div class="line">I/RxJava: accept : 7</div><div class="line">I/RxJava: accept : 8</div><div class="line">I/RxJava: accept : 9</div><div class="line">I/RxJava: accept : 10</div></pre></td></tr></table></figure>
<h3 id="skipLast"><a href="#skipLast" class="headerlink" title="skipLast"></a>skipLast</h3><p><code>skipLast(int count)</code> 用于过滤最后 n 项数据。</p>
<h2 id="repeat、repeatUntil-和-repeatWhen"><a href="#repeat、repeatUntil-和-repeatWhen" class="headerlink" title="repeat、repeatUntil 和 repeatWhen"></a>repeat、repeatUntil 和 repeatWhen</h2><p>这组操作符提供在调用 <code>onCompleted()</code> 事件后提供重复调用 <code>Observable</code> 事件的操作。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code> 提供重复调用 <code>Observable</code> 事件的操作。</p>
<ul>
<li>repeat()：无限次重复（Long.MAX_VALUE）</li>
<li>repeat(long times)：重复 times 次</li>
</ul>
<h3 id="repeatUntil"><a href="#repeatUntil" class="headerlink" title="repeatUntil"></a>repeatUntil</h3><p><code>repeatUntil(BooleanSupplier stop)</code> 重复调用 <code>Observable</code> 事件的操作直到 stop 条件满足。</p>
<h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen"></a>repeatWhen</h3><p><code>repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)</code> 当满足一定条件重复调用 <code>Observable</code> 事件的操作。</p>
<h2 id="retry、retryUntil-和-retryWhen"><a href="#retry、retryUntil-和-retryWhen" class="headerlink" title="retry、retryUntil 和 retryWhen"></a>retry、retryUntil 和 retryWhen</h2><p>这组操作符提供在调用 <code>onError()</code> 事件后提供重新调用 <code>Observable</code> 事件的操作。</p>
<h2 id="时间节点处理操作"><a href="#时间节点处理操作" class="headerlink" title="时间节点处理操作"></a>时间节点处理操作</h2><p>特定的时间节点处理方法：</p>
<ul>
<li>doOnEach：发射数据的时候执行</li>
<li>doAfterNext：数据发射成功后</li>
<li>doOnNext：调用onNext方法时</li>
<li>doOnComplete：调用onComplete方法时</li>
<li>doOnError：调用onError时</li>
<li>doFinally：onComplete，onError或者取消订阅关系后</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文介绍 RxJava 的操作符的用法
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava 使用指南 -- 基本概念、数据流创建和线程调度</title>
    <link href="http://yoursite.com/2017/10/10/open-source-rxjava-guide-base/"/>
    <id>http://yoursite.com/2017/10/10/open-source-rxjava-guide-base/</id>
    <published>2017-10-10T02:00:00.000Z</published>
    <updated>2018-06-02T09:24:04.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RxJava 很早就开始接触和使用了，但只是仅仅会一些简单的使用而已，于是打算通过一系列的博客来加深对RxJava的理解。<br><a href="https://github.com/ReactiveX/RxJava/" target="_blank" rel="external">RxJava Github地址</a><br>写这篇文章的时候，RxJava最新版本已经是 <code>2.1.5</code> 了，那么我们就以最新版本为基础来介绍 RxJava 的使用。<br>使用之前要加入一下依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;io.reactivex.rxjava2:rxjava:2.1.5&apos;</div><div class="line">    compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RxAndroid 是一个 RxJava 扩展库，更好的兼容了 Android 特性，比如主线程，UI事件等。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>RxJava 官方的解释是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库。简要概括一下，它就是一个实现异步操作的库。它的本质体现在异步两个字上面。<br>RxJava 的异步的实现，是通过一种扩展的观察者模式来实现的，观察者模式相信我们都不陌生。<br>RxJava 提供众多的操作符以及它的链式操作可以替代深度回调逻辑，可以使代码简短优雅。<br>想要使用RxJava，我们先来了解一下几个基本概念。</p>
<ul>
<li><font color="#ff0000">Observable/Observer (可观察者，即被观察者/观察者)</font>：发射数据流/接收数据流</li>
<li>Consumer：它也是一个 Observer，只有一个 accept() 回调</li>
<li>subscribe (订阅)：建立 Observable 和 Observer 的联系</li>
<li>subscribeOn：为 Observable 对数据的处理指定一个调度器</li>
<li>observeOn：为下游对数据的操作指定一个调度器</li>
<li>Disposable：用于解除订阅以及查询订阅关系是否解除</li>
<li>Operators操作符：可以理解为对数据流的操作，包括创建、过滤、变换、组合、聚合等。</li>
<li><font color="#ff0000">Flowable/Subscriber：(被观察者/观察者)</font>：一种观察者模式组合，支持背压</li>
<li>Publisher：Flowable 的父类</li>
<li>Subscription：可以通过request发起请求数据，通过cancel取消订阅关系。</li>
<li><font color="#ff0000">Single/SingleObserver</font>：一种观察者模式组合</li>
<li><font color="#ff0000">Completable/CompletableObserver</font>：一种观察者模式组合</li>
<li><font color="#ff0000">Maybe/MaybeObserver</font>：一种观察者模式组合</li>
</ul>
<p>订阅关系：Observable/Observer是一对，Flowable/Subscriber是一对。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>正如我们实现一个基本的观察者模式一样，你要创建被观察者和观察者，然后通过订阅事件使他们联系起来。<br>下面介绍一个RxJava的最基本的实现：</p>
<h3 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable&lt;String&gt; observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;String&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        observableEmitter.onNext(<span class="string">"Hello "</span>);</div><div class="line">        observableEmitter.onNext(<span class="string">"World"</span>);</div><div class="line">        observableEmitter.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>ObservableEmitter</code> 相当于一个事件发射器，每执行一次 <code>onNext()</code>，观察者就会收到一次数据，数据发送完毕后调用 <code>onComplete()</code> 方法。<br>在事件处理过程中出异常时，触发<code>onError()</code> ，同时队列自动终止，不允许再有事件发出。在一个正确运行的事件序列中， <code>onCompleted()</code> 和 <code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<h3 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull String s)</span> </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"onNext : "</span> + s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"onComplete"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>观察者的 <code>onNext()</code> 回调会收到被观察者发送的数据。</p>
<h3 id="subscribe（订阅）"><a href="#subscribe（订阅）" class="headerlink" title="subscribe（订阅）"></a>subscribe（订阅）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<p>执行后输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/RxJava: onNext : Hello </div><div class="line">I/RxJava: onNext : World</div><div class="line">I/RxJava: onComplete</div></pre></td></tr></table></figure>
<p>通过上面三步实现了 RxJava 最简单的用法，其中并没有涉及到线程切换等操作，这些后面再介绍。</p>
<h2 id="创建Observable-1"><a href="#创建Observable-1" class="headerlink" title="创建Observable"></a>创建Observable</h2><p>关于这方面请看 <a href="http://www.heqiangfly.com/2017/10/12/open-source-rxjava-guide-operator/" target="_blank" rel="external">RxJava 使用指南（二）– 操作符介绍 </a>一文。</p>
<h2 id="创建Observer-1"><a href="#创建Observer-1" class="headerlink" title="创建Observer"></a>创建Observer</h2><p>RxJava 支持多种不同方式的 <code>Observer</code> 回调。</p>
<ul>
<li>subscribe()：忽略 <code>onNext</code> 以及 <code>onComplete</code> 等事件。</li>
<li>subscribe(Observer&lt;? super T&gt; observer)：以 <code>Observer</code> 为参数。</li>
<li>subscribe(Consumer&lt;? super T&gt; onNext)：只接受 <code>onNext</code></li>
<li>subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError)：接受 <code>onNext</code> 和 <code>onError</code></li>
<li>subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete)：接受 <code>onNext</code> <code>onError</code> 和 <code>onComplete</code></li>
<li>subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError, Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe)：接受 <code>onNext</code> <code>onError</code> 和 <code>onComplete</code>，接受参数为 <code>Disposable</code> 的一个回调，用于解除订阅，这中实现就和 <code>Observer</code> 类似了，四个回调。</li>
</ul>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="Scheduler（调度器）"><a href="#Scheduler（调度器）" class="headerlink" title="Scheduler（调度器）"></a>Scheduler（调度器）</h3><p>在上面的例子中，并没有涉及到线程切换的操作。如果只是这样在一个线程中同步使用还没有将RxJava的优势体现出来。我们在使用过程中会经常遇到这种情况，比如，我们会将网络请求等耗时操作放到后台线程中，将UI操作放到主线程中执行。<br>RxJava 提供了线程调度的功能，我们可以借助于 <code>Scheduler</code> 来完成。另外 RxAndroid 提供了 <code>AndroidSchedulers</code> 调度器来供开发者使用。<br><code>Scheduler</code> 和 <code>AndroidSchedulers</code> 提供了6种线程调度器：</p>
<table>
<thead>
<tr>
<th style="text-align:center">调度器</th>
<th style="text-align:center">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Schedulers.io()</td>
<td style="text-align:center">主要用于一些耗时IO操作，比如读写文件，数据库存取，网络交互等。这个调度器具有线程缓存机制，它会根据需要，增加或者减少线程池中的线程数量。需要注意的是Schedulers.io()中的线程池数量是无限制大的，大量的I/0操作将创建许多线程，我们需要在性能和线程数量中做出取舍。</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.computation()</td>
<td style="text-align:center">计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.newThread()</td>
<td style="text-align:center">开启一个新的线程，不具有线程缓存机制，因为创建一个新的线程比复用一个线程更耗时耗力，因此，Schedulers.newThread( )的效率没有Schedulers.io( )高。</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.from(Executor executor)</td>
<td style="text-align:center">使用指定的 Executor 来作为线程调度器</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.single()</td>
<td style="text-align:center">拥有一个线程单例，所有的任务都在这一个线程中执行。</td>
</tr>
<tr>
<td style="text-align:center">Schedulers.trampoline()</td>
<td style="text-align:center">在当前线程执行一个任务，但不是立即执行，用trampoline()将它加入队列。这个调度器将会处理它的队列并且按程序运行队列中每一个任务。</td>
</tr>
<tr>
<td style="text-align:center">AndroidSchedulers.mainThread()</td>
<td style="text-align:center">Android中的主线程执行任务，为Android开发定制。</td>
</tr>
</tbody>
</table>
<h3 id="实现线程调度"><a href="#实现线程调度" class="headerlink" title="实现线程调度"></a>实现线程调度</h3><p>实现线程的调度可以通过 <code>subscribeOn()</code> 和 <code>observerOn()</code> 实现。</p>
<ul>
<li>subscribeOn()：指定被观察者在哪个调度器上执行，跟调用的位置没有关系。直到遇到observeOn改变线程调度器。</li>
<li>observerOn()：指定下游观察者对数据的操作运行在哪个调度器上。在调用位置切换线程。</li>
</ul>
<p>使用时需要注意：</p>
<ul>
<li><code>subscribeOn()</code> 可以多次调用，但只有第一次的调用会起作用。</li>
<li><code>observerOn()</code> 可以多次调用，每调用一次切换一次线程。</li>
</ul>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>在这个例子中，我们通过 <code>subscribeOn(Schedulers.io())</code> 指定被观察者在IO线程中进行图片下载，然后通过 <code>observeOn(AndroidSchedulers.mainThread())</code> 在主线程中更新UI。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Bitmap&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Bitmap&gt; observableEmitter)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"current thread : "</span>+Thread.currentThread().getName());</div><div class="line">        Bitmap bitmap = mHttpModel.getBitmapSync(mUrl);</div><div class="line">        observableEmitter.onNext(bitmap);</div><div class="line">        observableEmitter.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Bitmap&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(@NonNull Disposable d)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(@NonNull Bitmap bitmap)</span> </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"current thread : "</span>+Thread.currentThread().getName());</div><div class="line">                mImageView.setImageBitmap(bitmap);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull Throwable e)</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RxJava: current thread : RxCachedThreadScheduler-1</div><div class="line">RxJava: current thread : main</div></pre></td></tr></table></figure>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>这个例子主要来介绍一下线程调度的时机问题，被观察者所在的线程肯定是由 <code>subscribeOn()</code> 来指定，然后就直到遇到 <code>observeOn()</code> 再切换线程，否则就在当前线程执行下去。<br>看下面一段伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.create                           <span class="comment">//被观察者在io线程执行，因为后面通过subscribeOn指定io线程</span></div><div class="line">.map                                        <span class="comment">//没有遇到线程操作，依然在io线程</span></div><div class="line">.subscribeOn(Schedulers.io())</div><div class="line">.map                                        <span class="comment">//没有遇到线程操作，依然在io线程</span></div><div class="line">.observeOn(AndroidSchedulers.mainThread())  <span class="comment">//切换线程</span></div><div class="line">.map                                        <span class="comment">//遇到线程切换，在主线程</span></div><div class="line">.observeOn(Schedulers.io())                 <span class="comment">//切换线程</span></div><div class="line">.subscribe                                  <span class="comment">//遇到线程切换，在io线程</span></div></pre></td></tr></table></figure>
<blockquote>
<p>如果我们不指定线程调度器，被观察者和观察者会在什么线程执行呢？我们通过在前面的例子中添加一些打印信息会发现，它们会默认在当前线程中执行。</p>
</blockquote>
<h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h3><p>这里再提一个方法 <code>doOnSubscribe()</code>，它是在 <code>subscribe()</code> 调用后而且在事件发送前执行。前面我们说过，有多个 <code>subscribeOn()</code> 来对别观察者指定线程，只会有第一个起作用，但是多个 <code>subscribeOn()</code> 却可以影响 <code>doOnSubscribe()</code> 的执行线程。<br>先来测试一下我们的结论：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"subscribe current thread : "</span>+Thread.currentThread().getName());</div><div class="line">        e.onNext(<span class="number">1</span>);</div><div class="line">        e.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept current thread : "</span>+Thread.currentThread().getName());</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这里通过 <code>subscribeOn</code> 两次指定被观察者执行线程，一个是IO线程，一个指定主线程。<br>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I/RxJava: subscribe current thread : RxCachedThreadScheduler-1</div><div class="line">I/RxJava: accept current thread : RxCachedThreadScheduler-1</div><div class="line">I/RxJava: accept : 1</div></pre></td></tr></table></figure>
<p>执行在 IO 线程，是第一次指定生效。<br>上面例子稍加改动，再来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(@NonNull ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.i(TAG,<span class="string">"subscribe current thread : "</span>+Thread.currentThread().getName());</div><div class="line">        e.onNext(<span class="number">1</span>);</div><div class="line">        e.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">        .doOnSubscribe(<span class="keyword">new</span> Consumer&lt;Disposable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Disposable disposable)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"doOnSubscribe current thread : "</span>+Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                Log.i(TAG,<span class="string">"accept current thread : "</span>+Thread.currentThread().getName());</div><div class="line">                Log.i(TAG,<span class="string">"accept : "</span> + integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">I/RxJava: doOnSubscribe current thread : main</div><div class="line">I/RxJava: subscribe current thread : RxCachedThreadScheduler-1</div><div class="line">I/RxJava: accept current thread : RxCachedThreadScheduler-1</div><div class="line">I/RxJava: accept : 1</div></pre></td></tr></table></figure>
<p>可以看到，<code>subscribeOn</code> 是可以重新指定 <code>doOnSubscribe</code> 的执行线程的。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">http://gank.io/post/560e15be2dca930e00da1083</a></p>
]]></content>
    
    <summary type="html">
    
      本文介绍 RxJava 的基本概念以及简单使用，介绍 Observable 创建数据流的多种操作符的用法以及线程调度的方法和它们之间的区别。
    
    </summary>
    
      <category term="Android开源项目" scheme="http://yoursite.com/categories/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Android开源项目" scheme="http://yoursite.com/tags/Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android -- 使用 TaskDescription 定制任务管理器 Title</title>
    <link href="http://yoursite.com/2017/10/08/android-knowledge-point-taskdescription/"/>
    <id>http://yoursite.com/2017/10/08/android-knowledge-point-taskdescription/</id>
    <published>2017-10-08T02:00:00.000Z</published>
    <updated>2017-12-01T15:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近有个需求，就是要代码动态修改 APP 在任务管理器中名称显示，不要问我问什么有这样的需求，因为需求就这样。哈哈……<br>对于如何控制 APP 在任务管理器中的 Title，我们可能知道，可以通过在 AndroidManifest.xml 中设置 <code>application</code> 或者主 <code>activity</code> 的 <code>android:label</code> 来实现，而且 <code>activity</code> 的优先级高于 <code>application</code>，也就是说两者都设置这个标签的话，主 <code>activity</code> 的值覆盖 <code>application</code>,在桌面上的 APP 名称和 <code>activity</code> 的 <code>title</code> 的名称都是 <code>activity</code> 的 <code>label</code> 值。<br>但是 <code>label</code> 的值在代码中是无法进行动态设置的，而且 <code>ActivityInfo</code> 的生成是在 AMS 进程进行的，想要修改也不太容易，后面甚至想到了用 HOOK 技术 HOOK PMS 以及 AMS 相关 API 的方法。<br>由于一直想当然的认为任务管理器中也是读取的是 <code>ActivityInfo</code> 的 <code>labelRes</code> 或者 <code>nonLocalizedLabel</code> 来实现的，因此就一直在修改 <code>android:label</code> 上想办法。<br>这里再来个插曲介绍一下 <code>nonLocalizedLabel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageItemInfo</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> labelRes;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> CharSequence nonLocalizedLabel;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它是怎么赋值的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TypedValue v = args.sa.peekValue(args.labelRes);</div><div class="line"><span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; (outInfo.labelRes=v.resourceId) == <span class="number">0</span>) &#123;</div><div class="line">    outInfo.nonLocalizedLabel = v.coerceToString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看明白了吗？<br>这里的 <code>labelRes</code> 就代表 <code>android:label</code> 的资源ID，如果资源ID为0,那么表示不是通过给资源ID的方式来赋值的，可能就直接给 <code>android:label</code> 了一个字符串。<br>类似这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:label=<span class="string">"Test"</span></div></pre></td></tr></table></figure>
<h2 id="使用TaskDescription"><a href="#使用TaskDescription" class="headerlink" title="使用TaskDescription"></a>使用TaskDescription</h2><p>后面通过查看任务管理器的源码发现，里面用到了一个 <code>TaskDescription</code>，通过获取 <code>TaskDescription</code> 来获得 Task 的 Title。<br><code>TaskDescription</code> 是 Android 5.0 加入的一个类，通过它可以设置或者获取任务列表里面的 <code>Activity</code> 信息。<br><code>Activity</code> 提供了 <code>setTaskDescription()</code> 方法，其需要 <code>TaskDescription</code> 实例，而 <code>TaskDescription</code> 提供了多个构造器，注意 <code>color</code> 传入必须是非透明。<br>在 <code>Activity</code> 里面使用下面代码解决了该需求问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String title = ...;</div><div class="line">Bitmap icon = ...;</div><div class="line">setTaskDescription(<span class="keyword">new</span> ActivityManager.TaskDescription(</div><div class="line">        title, icon, getResources().getColor(R.color.colorPrimary)));</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      介绍使用 TaskDescription 定制任务管理器 Title
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="TaskDescription" scheme="http://yoursite.com/tags/TaskDescription/"/>
    
  </entry>
  
  <entry>
    <title>Android 架构 android-architecture 之 todo-mvp 介绍</title>
    <link href="http://yoursite.com/2017/09/06/android-architecture-google-mvp-basic/"/>
    <id>http://yoursite.com/2017/09/06/android-architecture-google-mvp-basic/</id>
    <published>2017-09-06T02:00:00.000Z</published>
    <updated>2018-07-10T11:07:46.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>todo-mvp 是对 MVP 的一种基础的实现，里面没有用到其他的框架，下面来具体分析一下。<br><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">Github地址</a></p>
<h2 id="源码简介"><a href="#源码简介" class="headerlink" title="源码简介"></a>源码简介</h2><p>按功能划分模块，包结构如图：</p>
<p><img src="/images/android-architecture-google-mvp-basic/image1.png" alt="效果图"></p>
<ol>
<li>tasks、addedittask、taskdetail和statistics：四个功能界面</li>
<li>data：数据层的代码，即 MVP 中的 Model 层</li>
<li>util：一些工具类</li>
<li>BasePresenter和BaseView：Presenter和View的基类</li>
</ol>
<p>各个包中的类：</p>
<p><img src="/images/android-architecture-google-mvp-basic/image2.png" alt="效果图"></p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>定义一个协议类 <code>Contract</code>，它定义了两个接口 <code>View</code> 和 <code>Presenter</code>，分别继承自 V 和 P 的基类 <code>BaseView</code> 和 <code>BasePresenter</code>。</li>
<li>创建一个 <code>Presenter</code>，并实现协议类中的 <code>Presenter</code> 接口，实现<code>Presenter</code> 类的两个参数分别是 <code>TasksRepository</code> （M）和 <code>View</code> （V）实现类，建立 M 和 V 联系的桥梁。</li>
<li>在 <code>Activity</code> 中实例化 <code>Presenter</code>，建立 M 和 V 的联系，实例化 <code>Fragment</code>。</li>
<li>在 <code>Fragment</code> 中实现了 <code>View</code> 接口，作为 <code>View</code> （V）实现类。</li>
</ol>
<p>V 层监听用户的操作，并把用户的操作传递到P层，并把P层中的指令转化为UI操作，并呈现出来。<br>P 层建立 M 和 V 的联系，响应 V 层的操作并向 M 层获取数据，然后传递到 V 层。<br>M 层负责数据的存储与查询。</p>
<p>以 taskdetail 为例，用一个类图来展示它们的关系：</p>
<p><img src="http://www.plantuml.com/plantuml/svg/XLHBJiCm4Dtx55PNYL1xWYugg92Gg5JHgdjZ3wr5OaVsj1M2xhW5Kk_0XWqIjw5S0pjfVeQqMJbltlER6OyziiWChjE4p2KcG7kJnVIm_pZiNt_UFx_Vldg4I8LW7XW7EcVsqOuPifbU6mw4a4jcOI5XIuSl_NuU7mCocLnfXOPn7FWWwS2TQ31eYAuDMwQWa9IBSDUAaFjE3LZmkNMQLmnoAXYcKQj8K73Dj7UGQIjHcwSZgmRei9NDoIIADdJm6vsl-lnCBgW5h4ZHd6RbEYQxK5CNcGlzMKS1hIihBzXeARpThMP2gkMD4f8pLsDqhtK2J577bXk8A-fARoVIMiVrsqOnzLyPNKa1-PH5BK41pT0u5KN_4pSLOx3So0obLcrTCt1KYnewNsMxD_cs82GMYPU8W0GGsXZNQVONpLl1AjIvyuHP-y_uEh_JuqhJUWZE77VeqIog7uugJSFPxRop1RK8v7TuHqQWX7ieVW40" alt="效果图"></p>
<!--  
@startuml
Title "MVP架构类图"

interface TasksDataSource


BaseView <|-- TaskDetailContract.View
TaskDetailContract.View <|.. TaskDetailFragment
Fragment <|-- TaskDetailFragment

BasePresenter <|-- TaskDetailContract.Presenter
TaskDetailContract.Presenter <|.. TaskDetailPresenter

TasksDataSource <|.. TasksRepository

TasksRepository <-- TaskDetailPresenter
TaskDetailContract.View <-- TaskDetailPresenter

interface BaseView {
+ setPresenter(T presenter)
}

interface BasePresenter {
+ start()
}

interface TaskDetailContract.View {
+ void setLoadingIndicator(boolean active)
+ void showMissingTask()     
+ void hideTitle()
+ void showTitle(String title)
+ void hideDescription()
+ void showDescription(String description)
}

interface TaskDetailContract.Presenter {
+ void editTask()
+ void deleteTask()
+ void completeTask()
+ void activateTask()
}

class TaskDetailFragment {
- TaskDetailContract.Presenter mPresenter
+ setPresenter(T presenter)
}

class TaskDetailPresenter {
- TasksRepository mTasksRepository
- TaskDetailContract.View mTaskDetailView
}
@enduml
-->
<h3 id="V-和-P-的基类"><a href="#V-和-P-的基类" class="headerlink" title="V 和 P 的基类"></a>V 和 P 的基类</h3><p>先来看一下 V 的基类 <code>BaseView&lt;T&gt;</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>BaseView</code> 是一个泛型接口，里面只有一个抽象方法 <code>setPresenter(T presenter)</code> ，用来设置 Presenter 。<br>P 的基类 <code>BasePresenter</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它也只定义来一个方法 <code>start()</code>，用来在 <code>Activity</code> 或者 Fragm<code>ent</code> 的 <code>onResume()</code> 方法中调用，来进行数据的查询。</p>
<h3 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h3><ul>
<li>tasks：包括菜单抽屉界面，主界面显示任务列表</li>
<li>addedittask：点击添加任务界面</li>
<li>taskdetail：点击任务后的详情界面</li>
<li>statistics：任务统计界面，点击抽屉菜单可以弹出</li>
</ul>
<p>这四个包对应了四个功能界面，它们内部的结构大同小异，包括了：</p>
<ul>
<li>Activity</li>
<li>Fragment</li>
<li>Contract</li>
<li>Presenter</li>
</ul>
<p>那么我们就选取其中的 taskdetail 模块来进行介绍。</p>
<p>在 <code>TaskDetailActivity</code> 中实例化 <code>TaskDetailFragment</code>、<code>TasksRepository</code> 和 <code>TaskDetailPresenter</code>，其中 <code>TaskDetailFragment</code> 和 <code>TasksRepository</code> 作为 <code>TaskDetailPresenter</code> 的参数。<br>来看一下 <code>TaskDetailPresenter</code> 的构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskDetailPresenter</span><span class="params">(@Nullable String taskId,</span></span></div><div class="line">                           @NonNull TasksRepository tasksRepository,</div><div class="line">                           @NonNull TaskDetailContract.View taskDetailView) &#123;</div><div class="line">    mTaskId = taskId;</div><div class="line">    mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null!"</span>);</div><div class="line">    mTaskDetailView = checkNotNull(taskDetailView, <span class="string">"taskDetailView cannot be null!"</span>);</div><div class="line"></div><div class="line">    mTaskDetailView.setPresenter(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里调用了 <code>TaskDetailFragment</code> 的 <code>setPresenter</code> 方法来设置 P 模块。</p>
<p>分别调用 <code>TasksRepository</code>  和 <code>TaskDetailFragment</code> 的相应的方法来实现数据的操作以及视图的更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    openTask();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (Strings.isNullOrEmpty(mTaskId)) &#123;</div><div class="line">        mTaskDetailView.showMissingTask();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mTaskDetailView.setLoadingIndicator(<span class="keyword">true</span>);</div><div class="line">    mTasksRepository.getTask(mTaskId, <span class="keyword">new</span> TasksDataSource.GetTaskCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span> </span>&#123;</div><div class="line">            <span class="comment">// The view may not be able to handle UI updates anymore</span></div><div class="line">            <span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mTaskDetailView.setLoadingIndicator(<span class="keyword">false</span>);</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == task) &#123;</div><div class="line">                mTaskDetailView.showMissingTask();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                showTask(task);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// The view may not be able to handle UI updates anymore</span></div><div class="line">            <span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            mTaskDetailView.showMissingTask();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showTask</span><span class="params">(@NonNull Task task)</span> </span>&#123;</div><div class="line">    String title = task.getTitle();</div><div class="line">    String description = task.getDescription();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Strings.isNullOrEmpty(title)) &#123;</div><div class="line">        mTaskDetailView.hideTitle();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mTaskDetailView.showTitle(title);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Strings.isNullOrEmpty(description)) &#123;</div><div class="line">        mTaskDetailView.hideDescription();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mTaskDetailView.showDescription(description);</div><div class="line">    &#125;</div><div class="line">    mTaskDetailView.showCompletionStatus(task.isCompleted());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>TaskDetailFragment</code> 中调用 <code>TaskDetailPresenter</code> 的对应方法来实现数据的增删改查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onResume();</div><div class="line">    mPresenter.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">    fab.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            mPresenter.editTask();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (item.getItemId()) &#123;</div><div class="line">        <span class="keyword">case</span> R.id.menu_delete:</div><div class="line">            mPresenter.deleteTask();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showCompletionStatus</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> complete)</span> </span>&#123;</div><div class="line">    Preconditions.checkNotNull(mDetailCompleteStatus);</div><div class="line"></div><div class="line">    mDetailCompleteStatus.setChecked(complete);</div><div class="line">    mDetailCompleteStatus.setOnCheckedChangeListener(</div><div class="line">            <span class="keyword">new</span> CompoundButton.OnCheckedChangeListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (isChecked) &#123;</div><div class="line">                        mPresenter.completeTask();</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        mPresenter.activateTask();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Data-Model层"><a href="#Data-Model层" class="headerlink" title="Data Model层"></a>Data Model层</h3><p>App需要的数据都是通过Data模块来提供，由它去完成访问网络和数据库等。</p>
<p><img src="http://www.plantuml.com/plantuml/svg/dPB1IWCn48RlUOhGKqNR9-XXfO88RH5Rl8_9j0sTtPHaTa7KcsyXz1syU15y6-jh6BVhrYvn1M_9Fr--6S8adi5ndfAO6IQKdV7rvNRpijqyZgr6-dX-VNzwwmWn0x_oPy0mjRbJA0Vt_Ruimv5LGFjA2tc5Q-iDMtVR2gMMyOUlwjre8mUzNjpQ54H9OJ96DuTGRevo9uxb0hcCkyd4PfESI8uiw38Q0j4Dg9LKrU4ey8Kr-llH_isKdSaMaaDueKzadP_lmDzD7WeyL7tTIb7DA9kk2VcVtC5eDGkAJG5_E-DStAa8mGsh8NPVsAsB3kSE_RAHXhqBx2bHD6zj-Y0Ip7HOvqy0" alt="效果图"></p>
<ul>
<li>接口 <code>TasksDataSource</code> 定义了操作数据的各种方法。</li>
<li>类 <code>TasksLocalDataSource</code> 实现了<code>TasksDataSource</code> 接口，可以操作本地数据库来实现数据的存储和读取。 </li>
<li>类 <code>TasksRemoteDataSource</code> 实现了<code>TasksDataSource</code> 接口，用来模拟网络数据的读取上上传。</li>
<li>类 <code>TasksRepository</code> 实现了<code>TasksDataSource</code> 接口，提供来对数据访问的能力，它持有 <code>TasksLocalDataSource</code> 和 <code>TasksRemoteDataSource</code> 的对象，由它们真正实现对本地数据和网络数据的操作。</li>
</ul>
<h3 id="util工具类"><a href="#util工具类" class="headerlink" title="util工具类"></a>util工具类</h3><p>这部分不再介绍，想了解详情的看代码即可。</p>
]]></content>
    
    <summary type="html">
    
      介绍 Google 开源的 Android 架构中的 MVP 架构
    
    </summary>
    
      <category term="Android 架构" scheme="http://yoursite.com/categories/Android-%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="Android 架构" scheme="http://yoursite.com/tags/Android-%E6%9E%B6%E6%9E%84/"/>
    
      <category term="android-architecture" scheme="http://yoursite.com/tags/android-architecture/"/>
    
  </entry>
  
</feed>
